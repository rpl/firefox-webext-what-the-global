{"activityLog":[{"filepath":"toolkit/components/extensions/parent/ext-activityLog.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.activityLog = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      activityLog: {\n        onExtensionActivity: new ExtensionCommon.EventManager({\n          context,\n          name: \"activityLog.onExtensionActivity\",\n          register: (fire, id) => {\n            function handler(details) {\n              fire.async(details);\n            }\n\n            ExtensionActivityLog.addListener(id, handler);\n            return () => {\n              ExtensionActivityLog.removeListener(id, handler);\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"Alarm":[{"filepath":"toolkit/components/extensions/parent/ext-alarms.js","kind":"function","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"function Alarm(api, name, alarmInfo) {\n  this.api = api;\n  this.name = name;\n  this.when = alarmInfo.when;\n  this.delayInMinutes = alarmInfo.delayInMinutes;\n  this.periodInMinutes = alarmInfo.periodInMinutes;\n  this.canceled = false;\n  let delay, scheduledTime;\n\n  if (this.when) {\n    scheduledTime = this.when;\n    delay = this.when - Date.now();\n  } else {\n    if (!this.delayInMinutes) {\n      this.delayInMinutes = this.periodInMinutes;\n    }\n\n    delay = this.delayInMinutes * 60 * 1000;\n    scheduledTime = Date.now() + delay;\n  }\n\n  this.scheduledTime = scheduledTime;\n  let timer = Cc[\"@mozilla.org/timer;1\"].createInstance(Ci.nsITimer);\n  delay = delay > 0 ? delay : 0;\n  timer.init(this, delay, Ci.nsITimer.TYPE_ONE_SHOT);\n  this.timer = timer;\n}"}],"alarms":[{"filepath":"toolkit/components/extensions/parent/ext-alarms.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.alarms = class extends ExtensionAPI {\n  constructor(extension) {\n    super(extension);\n    this.alarms = new Map();\n    this.callbacks = new Set();\n  }\n\n  onShutdown() {\n    for (let alarm of this.alarms.values()) {\n      alarm.clear();\n    }\n  }\n\n  getAPI(context) {\n    const self = this;\n    return {\n      alarms: {\n        create: function (name, alarmInfo) {\n          name = name || \"\";\n\n          if (self.alarms.has(name)) {\n            self.alarms.get(name).clear();\n          }\n\n          let alarm = new Alarm(self, name, alarmInfo);\n          self.alarms.set(alarm.name, alarm);\n        },\n        get: function (name) {\n          name = name || \"\";\n\n          if (self.alarms.has(name)) {\n            return Promise.resolve(self.alarms.get(name).data);\n          }\n\n          return Promise.resolve();\n        },\n        getAll: function () {\n          let result = Array.from(self.alarms.values(), alarm => alarm.data);\n          return Promise.resolve(result);\n        },\n        clear: function (name) {\n          name = name || \"\";\n\n          if (self.alarms.has(name)) {\n            self.alarms.get(name).clear();\n            return Promise.resolve(true);\n          }\n\n          return Promise.resolve(false);\n        },\n        clearAll: function () {\n          let cleared = false;\n\n          for (let alarm of self.alarms.values()) {\n            alarm.clear();\n            cleared = true;\n          }\n\n          return Promise.resolve(cleared);\n        },\n        onAlarm: new EventManager({\n          context,\n          name: \"alarms.onAlarm\",\n          register: fire => {\n            let callback = alarm => {\n              fire.sync(alarm.data);\n            };\n\n            self.callbacks.add(callback);\n            return () => {\n              self.callbacks.delete(callback);\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"Transferable":[{"filepath":"toolkit/components/extensions/parent/ext-clipboard.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const Transferable = Components.Constructor(\"@mozilla.org/widget/transferable;1\", \"nsITransferable\");"}],"clipboard":[{"filepath":"toolkit/components/extensions/parent/ext-clipboard.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.clipboard = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      clipboard: {\n        async setImageData(imageData, imageType) {\n          if (AppConstants.platform == \"android\") {\n            return Promise.reject({\n              message: \"Writing images to the clipboard is not supported on Android\"\n            });\n          }\n\n          let img;\n\n          try {\n            img = imgTools.decodeImageFromArrayBuffer(imageData, `image/${imageType}`);\n          } catch (e) {\n            return Promise.reject({\n              message: `Data is not a valid ${imageType} image`\n            });\n          }\n\n          let transferable = new Transferable();\n          transferable.init(null);\n          const kNativeImageMime = \"application/x-moz-nativeimage\";\n          transferable.addDataFlavor(kNativeImageMime);\n          transferable.setTransferData(kNativeImageMime, img, 1);\n          Services.clipboard.setData(transferable, null, Services.clipboard.kGlobalClipboard);\n        }\n\n      }\n    };\n  }\n\n}"}],"ExtensionParent":[{"filepath":"toolkit/components/extensions/parent/ext-backgroundPage.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionParent\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionParent.jsm\");"},{"filepath":"toolkit/components/extensions/parent/ext-runtime.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionParent\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionParent.jsm\");"},{"filepath":"browser/components/extensions/parent/ext-url-overrides.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionParent\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionParent.jsm\");"},{"filepath":"mobile/android/components/extensions/ext-pageAction.js","kind":"var","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"var {\n  ExtensionParent\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionParent.jsm\");"},{"filepath":"browser/components/extensions/parent/ext-devtools.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionParent\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionParent.jsm\");"},{"filepath":"browser/components/extensions/parent/ext-pageAction.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionParent\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionParent.jsm\");"},{"filepath":"browser/components/extensions/parent/ext-sidebarAction.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionParent\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionParent.jsm\");"},{"filepath":"browser/components/extensions/parent/ext-urlbar.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionParent\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionParent.jsm\");"},{"filepath":"browser/components/extensions/parent/ext-chrome-settings-overrides.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionParent\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionParent.jsm\");"},{"filepath":"browser/components/extensions/parent/ext-devtools-panels.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionParent\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionParent.jsm\");"},{"filepath":"browser/components/extensions/parent/ext-browserAction.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionParent\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionParent.jsm\");"},{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionParent\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionParent.jsm\");"}],"HiddenExtensionPage":[{"filepath":"toolkit/components/extensions/parent/ext-backgroundPage.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  HiddenExtensionPage,\n  promiseExtensionViewLoaded\n} = ExtensionParent;"},{"filepath":"browser/components/extensions/parent/ext-devtools.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  HiddenExtensionPage,\n  watchExtensionProxyContextLoad\n} = ExtensionParent;"}],"promiseExtensionViewLoaded":[{"filepath":"toolkit/components/extensions/parent/ext-backgroundPage.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  HiddenExtensionPage,\n  promiseExtensionViewLoaded\n} = ExtensionParent;"}],"backgroundPage":[{"filepath":"toolkit/components/extensions/parent/ext-backgroundPage.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.backgroundPage = class extends ExtensionAPI {\n  build() {\n    if (this.bgPage) {\n      return;\n    }\n\n    let {\n      extension\n    } = this;\n    let {\n      manifest\n    } = extension;\n    this.bgPage = new BackgroundPage(extension, manifest.background);\n    return this.bgPage.build();\n  }\n\n  onManifestEntry(entryName) {\n    let {\n      extension\n    } = this;\n    this.bgPage = null;\n\n    if (PrivateBrowsingUtils.permanentPrivateBrowsing && !extension.privateBrowsingAllowed) {\n      return;\n    }\n\n    const startBackgroundPage = async () => {\n      if (!this.extension) {\n        return;\n      }\n\n      await this.build();\n    };\n\n    if (this.extension.canSuspendBackgroundContext) {\n      const initEventPageListeners = async () => {\n        const stopBackgroundPage = async () => {\n          if (!this.extension || !this.bgPage) {\n            return;\n          }\n\n          extension.persistentListeners = null;\n          EventManager.primeListeners(extension);\n          await this.bgPage.shutdown();\n          this.bgPage = null;\n          extension.once(\"background-page-event\", async () => {\n            extension.emit(\"start-background-page\");\n          });\n          extension.emit(\"background-page-suspended\");\n        };\n\n        extension.on(\"start-background-page\", startBackgroundPage);\n        extension.on(\"suspend-background-page\", stopBackgroundPage);\n      };\n\n      return this.build().then(initEventPageListeners);\n    }\n\n    if (extension.startupReason !== \"APP_STARTUP\" || !DELAYED_STARTUP) {\n      return this.build();\n    }\n\n    EventManager.primeListeners(extension);\n    extension.once(\"start-background-page\", startBackgroundPage);\n    extension.once(\"background-page-event\", async () => {\n      await ExtensionParent.browserPaintedPromise;\n      extension.emit(\"start-background-page\");\n    });\n    ExtensionParent.browserStartupPromise.then(() => {\n      extension.emit(\"start-background-page\");\n    });\n  }\n\n  onShutdown() {\n    if (this.bgPage) {\n      this.bgPage.shutdown();\n    } else {\n      EventManager.clearPrimedListeners(this.extension, false);\n    }\n\n    if (this.extension.canSuspendBackgroundContext) {\n      this.extension.off(\"start-background-page\");\n      this.extension.off(\"suspend-background-page\");\n    }\n  }\n\n}"},{"filepath":"toolkit/components/extensions/child/ext-backgroundPage.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"this.backgroundPage = class extends ExtensionAPI {\n  getAPI(context) {\n    function getBackgroundPage() {\n      for (let view of context.extension.views) {\n        if (view.viewType == \"background\" && context.principal.subsumes(view.principal)) {\n          return view.contentWindow;\n        }\n      }\n\n      return null;\n    }\n\n    return {\n      extension: {\n        getBackgroundPage\n      },\n      runtime: {\n        getBackgroundPage() {\n          return context.cloneScope.Promise.resolve(getBackgroundPage());\n        }\n\n      }\n    };\n  }\n\n}"}],"nameForCPSState":[{"filepath":"toolkit/components/extensions/parent/ext-captivePortal.js","kind":"function","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"function nameForCPSState(state) {\n  switch (state) {\n    case gCPS.UNKNOWN:\n      return \"unknown\";\n\n    case gCPS.NOT_CAPTIVE:\n      return \"not_captive\";\n\n    case gCPS.UNLOCKED_PORTAL:\n      return \"unlocked_portal\";\n\n    case gCPS.LOCKED_PORTAL:\n      return \"locked_portal\";\n\n    default:\n      return \"unknown\";\n  }\n}"}],"ExtensionError":[{"filepath":"toolkit/components/extensions/parent/ext-captivePortal.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/parent/ext-contentScripts.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError,\n  getUniqueId\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/parent/ext-geckoProfiler.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/parent/ext-permissions.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/parent/ext-storage.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/parent/ext-userScripts.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"browser/components/extensions/parent/ext-devtools-network.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"browser/components/extensions/parent/ext-search.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/child/ext-contentScripts.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/child/ext-userScripts.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"var {\n  DefaultMap,\n  ExtensionError,\n  getUniqueId\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/parent/ext-browserSettings.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/parent/ext-contextualIdentities.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/parent/ext-management.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/parent/ext-privacy.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/parent/ext-proxy.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"browser/components/extensions/parent/ext-bookmarks.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"browser/components/extensions/parent/ext-find.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"browser/components/extensions/parent/ext-sidebarAction.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"browser/components/extensions/parent/ext-sessions.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError,\n  promiseObserved\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/child/ext-userScripts-content.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"browser/components/extensions/child/ext-menus.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":false,"child":true},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/parent/ext-cookies.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"mobile/android/components/extensions/ext-utils.js","kind":"var","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"var {\n  DefaultWeakMap,\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"browser/components/extensions/parent/ext-browserAction.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  DefaultWeakMap,\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"browser/components/extensions/parent/ext-browser.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  DefaultMap,\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"browser/components/extensions/parent/ext-tabs.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/parent/ext-tabs-base.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  DefaultMap,\n  DefaultWeakMap,\n  ExtensionError,\n  getWinUtils\n} = ExtensionUtils;"}],"captivePortal":[{"filepath":"toolkit/components/extensions/parent/ext-captivePortal.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.captivePortal = class extends ExtensionAPI {\n  getAPI(context) {\n    function checkEnabled() {\n      if (!gCaptivePortalEnabled) {\n        throw new ExtensionError(\"Captive Portal detection is not enabled\");\n      }\n    }\n\n    return {\n      captivePortal: {\n        getState() {\n          checkEnabled();\n          return nameForCPSState(gCPS.state);\n        },\n\n        getLastChecked() {\n          checkEnabled();\n          return gCPS.lastChecked;\n        },\n\n        onStateChanged: new EventManager({\n          context,\n          name: \"captivePortal.onStateChanged\",\n          register: fire => {\n            checkEnabled();\n\n            let observer = (subject, topic) => {\n              fire.async({\n                state: nameForCPSState(gCPS.state)\n              });\n            };\n\n            Services.obs.addObserver(observer, \"ipc:network:captive-portal-set-state\");\n            return () => {\n              Services.obs.removeObserver(observer, \"ipc:network:captive-portal-set-state\");\n            };\n          }\n        }).api(),\n        onConnectivityAvailable: new EventManager({\n          context,\n          name: \"captivePortal.onConnectivityAvailable\",\n          register: fire => {\n            checkEnabled();\n\n            let observer = (subject, topic, data) => {\n              fire.async({\n                status: data\n              });\n            };\n\n            Services.obs.addObserver(observer, \"network:captive-portal-connectivity\");\n            return () => {\n              Services.obs.removeObserver(observer, \"network:captive-portal-connectivity\");\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"ExtensionUtils":[{"filepath":"toolkit/components/extensions/parent/ext-contentScripts.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionUtils\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionUtils.jsm\");"},{"filepath":"toolkit/components/extensions/parent/ext-userScripts.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionUtils\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionUtils.jsm\");"},{"filepath":"mobile/android/components/extensions/ext-utils.js","kind":"var","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"var {\n  ExtensionUtils\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionUtils.jsm\");"}],"getUniqueId":[{"filepath":"toolkit/components/extensions/parent/ext-contentScripts.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError,\n  getUniqueId\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/child/ext-userScripts.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"var {\n  DefaultMap,\n  ExtensionError,\n  getUniqueId\n} = ExtensionUtils;"}],"contentScripts":[{"filepath":"toolkit/components/extensions/parent/ext-contentScripts.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.contentScripts = class extends ExtensionAPI {\n  getAPI(context) {\n    const {\n      extension\n    } = context;\n    const parentScriptsMap = new Map();\n    context.callOnClose({\n      close() {\n        if (parentScriptsMap.size === 0) {\n          return;\n        }\n\n        const scriptIds = Array.from(parentScriptsMap.keys());\n\n        for (let scriptId of scriptIds) {\n          extension.registeredContentScripts.delete(scriptId);\n        }\n\n        extension.updateContentScripts();\n        extension.broadcast(\"Extension:UnregisterContentScripts\", {\n          id: extension.id,\n          scriptIds\n        });\n      }\n\n    });\n    return {\n      contentScripts: {\n        async register(details) {\n          for (let origin of details.matches) {\n            if (!extension.whiteListedHosts.subsumes(new MatchPattern(origin))) {\n              throw new ExtensionError(`Permission denied to register a content script for ${origin}`);\n            }\n          }\n\n          const contentScript = new ContentScriptParent({\n            context,\n            details\n          });\n          const {\n            scriptId\n          } = contentScript;\n          parentScriptsMap.set(scriptId, contentScript);\n          const scriptOptions = contentScript.serialize();\n          await extension.broadcast(\"Extension:RegisterContentScript\", {\n            id: extension.id,\n            options: scriptOptions,\n            scriptId\n          });\n          extension.registeredContentScripts.set(scriptId, scriptOptions);\n          extension.updateContentScripts();\n          return scriptId;\n        },\n\n        async unregister(scriptId) {\n          const contentScript = parentScriptsMap.get(scriptId);\n\n          if (!contentScript) {\n            Cu.reportError(new Error(`No such content script ID: ${scriptId}`));\n            return;\n          }\n\n          parentScriptsMap.delete(scriptId);\n          extension.registeredContentScripts.delete(scriptId);\n          extension.updateContentScripts();\n          contentScript.destroy();\n          await extension.broadcast(\"Extension:UnregisterContentScripts\", {\n            id: extension.id,\n            scriptIds: [scriptId]\n          });\n        }\n\n      }\n    };\n  }\n\n}"},{"filepath":"toolkit/components/extensions/child/ext-contentScripts.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"this.contentScripts = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      contentScripts: {\n        register(options) {\n          return context.cloneScope.Promise.resolve().then(async () => {\n            const scriptId = await context.childManager.callParentAsyncFunction(\"contentScripts.register\", [options]);\n            const registeredScript = new ContentScriptChild(context, scriptId);\n            return Cu.cloneInto(registeredScript.api(), context.cloneScope, {\n              cloneFunctions: true\n            });\n          });\n        }\n\n      }\n    };\n  }\n\n}"}],"dnssFlags":[{"filepath":"toolkit/components/extensions/parent/ext-dns.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const dnssFlags = {\n  allow_name_collisions: Ci.nsIDNSService.RESOLVE_ALLOW_NAME_COLLISION,\n  bypass_cache: Ci.nsIDNSService.RESOLVE_BYPASS_CACHE,\n  canonical_name: Ci.nsIDNSService.RESOLVE_CANONICAL_NAME,\n  disable_ipv4: Ci.nsIDNSService.RESOLVE_DISABLE_IPV4,\n  disable_ipv6: Ci.nsIDNSService.RESOLVE_DISABLE_IPV6,\n  disable_trr: Ci.nsIDNSService.RESOLVE_DISABLE_TRR,\n  offline: Ci.nsIDNSService.RESOLVE_OFFLINE,\n  priority_low: Ci.nsIDNSService.RESOLVE_PRIORITY_LOW,\n  priority_medium: Ci.nsIDNSService.RESOLVE_PRIORITY_MEDIUM,\n  speculate: Ci.nsIDNSService.RESOLVE_SPECULATE\n};"}],"getErrorString":[{"filepath":"toolkit/components/extensions/parent/ext-dns.js","kind":"function","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"function getErrorString(nsresult) {\n  let e = new Components.Exception(\"\", nsresult);\n  return e.name;\n}"}],"dns":[{"filepath":"toolkit/components/extensions/parent/ext-dns.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.dns = class extends ExtensionAPI {\n  getAPI(context) {\n    const dnss = Cc[\"@mozilla.org/network/dns-service;1\"].getService(Ci.nsIDNSService);\n    return {\n      dns: {\n        resolve: function (hostname, flags) {\n          let dnsFlags = flags.reduce((mask, flag) => mask | dnssFlags[flag], 0);\n          return new Promise((resolve, reject) => {\n            let request;\n            let response = {\n              addresses: []\n            };\n            let listener = {\n              onLookupComplete: function (inRequest, inRecord, inStatus) {\n                if (inRequest === request) {\n                  if (!Components.isSuccessCode(inStatus)) {\n                    return reject({\n                      message: getErrorString(inStatus)\n                    });\n                  }\n\n                  if (dnsFlags & Ci.nsIDNSService.RESOLVE_CANONICAL_NAME) {\n                    try {\n                      response.canonicalName = inRecord.canonicalName;\n                    } catch (e) {}\n                  }\n\n                  response.isTRR = inRecord.IsTRR();\n\n                  while (inRecord.hasMore()) {\n                    let addr = inRecord.getNextAddrAsString();\n\n                    if (!response.addresses.includes(addr)) {\n                      response.addresses.push(addr);\n                    }\n                  }\n\n                  return resolve(response);\n                }\n              }\n            };\n\n            try {\n              request = dnss.asyncResolve(hostname, dnsFlags, listener, null, {});\n            } catch (e) {\n              return reject({\n                message: e.name\n              });\n            }\n          });\n        }\n      }\n    };\n  }\n\n}"}],"i18n":[{"filepath":"toolkit/components/extensions/parent/ext-i18n.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.i18n = class extends ExtensionAPI {\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    return {\n      i18n: {\n        getMessage: function (messageName, substitutions) {\n          return extension.localizeMessage(messageName, substitutions, {\n            cloneScope: context.cloneScope\n          });\n        },\n        getAcceptLanguages: function () {\n          let result = extension.localeData.acceptLanguages;\n          return Promise.resolve(result);\n        },\n        getUILanguage: function () {\n          return extension.localeData.uiLocale;\n        },\n        detectLanguage: function (text) {\n          return LanguageDetector.detectLanguage(text).then(result => ({\n            isReliable: result.confident,\n            languages: result.languages.map(lang => {\n              return {\n                language: lang.languageCode,\n                percentage: lang.percent\n              };\n            })\n          }));\n        }\n      }\n    };\n  }\n\n}"}],"Services":[{"filepath":"toolkit/components/extensions/parent/ext-geckoProfiler.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  Services\n} = ChromeUtils.import(\"resource://gre/modules/Services.jsm\");"},{"filepath":"toolkit/components/extensions/parent/ext-theme.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  Services\n} = ChromeUtils.import(\"resource://gre/modules/Services.jsm\");"},{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  Services\n} = ChromeUtils.import(\"resource://gre/modules/Services.jsm\");"}],"PREF_ASYNC_STACK":[{"filepath":"toolkit/components/extensions/parent/ext-geckoProfiler.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const PREF_ASYNC_STACK = \"javascript.options.asyncstack\";"}],"ASYNC_STACKS_ENABLED":[{"filepath":"toolkit/components/extensions/parent/ext-geckoProfiler.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const ASYNC_STACKS_ENABLED = Services.prefs.getBoolPref(PREF_ASYNC_STACK, false);"}],"symbolCache":[{"filepath":"toolkit/components/extensions/parent/ext-geckoProfiler.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const symbolCache = new Map();"}],"primeSymbolStore":[{"filepath":"toolkit/components/extensions/parent/ext-geckoProfiler.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const primeSymbolStore = libs => {\n  for (const {\n    path,\n    debugName,\n    debugPath,\n    breakpadId\n  } of libs) {\n    symbolCache.set(`${debugName}/${breakpadId}`, {\n      path,\n      debugPath\n    });\n  }\n};"}],"isRunningObserver":[{"filepath":"toolkit/components/extensions/parent/ext-geckoProfiler.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const isRunningObserver = {\n  _observers: new Set(),\n\n  observe(subject, topic, data) {\n    switch (topic) {\n      case \"profiler-started\":\n      case \"profiler-stopped\":\n        const isRunningPromise = Promise.resolve(topic === \"profiler-started\");\n\n        for (let observer of this._observers) {\n          isRunningPromise.then(observer);\n        }\n\n        break;\n    }\n  },\n\n  _startListening() {\n    Services.obs.addObserver(this, \"profiler-started\");\n    Services.obs.addObserver(this, \"profiler-stopped\");\n  },\n\n  _stopListening() {\n    Services.obs.removeObserver(this, \"profiler-started\");\n    Services.obs.removeObserver(this, \"profiler-stopped\");\n  },\n\n  addObserver(observer) {\n    if (this._observers.size === 0) {\n      this._startListening();\n    }\n\n    this._observers.add(observer);\n\n    observer(Services.profiler.IsActive());\n  },\n\n  removeObserver(observer) {\n    if (this._observers.delete(observer) && this._observers.size === 0) {\n      this._stopListening();\n    }\n  }\n\n};"}],"geckoProfiler":[{"filepath":"toolkit/components/extensions/parent/ext-geckoProfiler.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.geckoProfiler = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      geckoProfiler: {\n        async start(options) {\n          const {\n            bufferSize,\n            windowLength,\n            interval,\n            features,\n            threads\n          } = options;\n          Services.prefs.setBoolPref(PREF_ASYNC_STACK, false);\n\n          if (threads) {\n            Services.profiler.StartProfiler(bufferSize, interval, features, threads, windowLength);\n          } else {\n            Services.profiler.StartProfiler(bufferSize, interval, features, [], windowLength);\n          }\n        },\n\n        async stop() {\n          if (ASYNC_STACKS_ENABLED !== null) {\n            Services.prefs.setBoolPref(PREF_ASYNC_STACK, ASYNC_STACKS_ENABLED);\n          }\n\n          Services.profiler.StopProfiler();\n        },\n\n        async pause() {\n          Services.profiler.PauseSampling();\n        },\n\n        async resume() {\n          Services.profiler.ResumeSampling();\n        },\n\n        async dumpProfileToFile(fileName) {\n          if (!Services.profiler.IsActive()) {\n            throw new ExtensionError(\"The profiler is stopped. \" + \"You need to start the profiler before you can capture a profile.\");\n          }\n\n          if (fileName.includes(\"\\\\\") || fileName.includes(\"/\")) {\n            throw new ExtensionError(\"Path cannot contain a subdirectory.\");\n          }\n\n          let fragments = [OS.Constants.Path.profileDir, \"profiler\", fileName];\n          let filePath = OS.Path.join(...fragments);\n\n          try {\n            await Services.profiler.dumpProfileToFileAsync(filePath);\n          } catch (e) {\n            Cu.reportError(e);\n            throw new ExtensionError(`Dumping profile to ${filePath} failed.`);\n          }\n        },\n\n        async getProfile() {\n          if (!Services.profiler.IsActive()) {\n            throw new ExtensionError(\"The profiler is stopped. \" + \"You need to start the profiler before you can capture a profile.\");\n          }\n\n          return Services.profiler.getProfileDataAsync();\n        },\n\n        async getProfileAsArrayBuffer() {\n          if (!Services.profiler.IsActive()) {\n            throw new ExtensionError(\"The profiler is stopped. \" + \"You need to start the profiler before you can capture a profile.\");\n          }\n\n          return Services.profiler.getProfileDataAsArrayBuffer();\n        },\n\n        async getProfileAsGzippedArrayBuffer() {\n          if (!Services.profiler.IsActive()) {\n            throw new ExtensionError(\"The profiler is stopped. \" + \"You need to start the profiler before you can capture a profile.\");\n          }\n\n          return Services.profiler.getProfileDataAsGzippedArrayBuffer();\n        },\n\n        async getSymbols(debugName, breakpadId) {\n          if (symbolCache.size === 0) {\n            primeSymbolStore(Services.profiler.sharedLibraries);\n          }\n\n          const cachedLibInfo = symbolCache.get(`${debugName}/${breakpadId}`);\n\n          if (!cachedLibInfo) {\n            throw new Error(`The library ${debugName} ${breakpadId} is not in the Services.profiler.sharedLibraries list, ` + \"so the local path for it is not known and symbols for it can not be obtained. \" + \"This usually happens if a content process uses a library that's not used in the parent \" + \"process - Services.profiler.sharedLibraries only knows about libraries in the parent process.\");\n          }\n\n          const {\n            path,\n            debugPath\n          } = cachedLibInfo;\n\n          if (!OS.Path.split(path).absolute) {\n            throw new Error(`Services.profiler.sharedLibraries did not contain an absolute path for the library ${debugName} ${breakpadId}, ` + \"so symbols for this library can not be obtained.\");\n          }\n\n          return ProfilerGetSymbols.getSymbolTable(path, debugPath, breakpadId);\n        },\n\n        onRunning: new EventManager({\n          context,\n          name: \"geckoProfiler.onRunning\",\n          register: fire => {\n            isRunningObserver.addObserver(fire.async);\n            return () => {\n              isRunningObserver.removeObserver(fire.async);\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"extension":[{"filepath":"toolkit/components/extensions/parent/ext-extension.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.extension = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      extension: {\n        get lastError() {\n          return context.lastError;\n        },\n\n        isAllowedIncognitoAccess() {\n          return context.privateBrowsingAllowed;\n        },\n\n        isAllowedFileSchemeAccess() {\n          return false;\n        }\n\n      }\n    };\n  }\n\n}"},{"filepath":"toolkit/components/extensions/child/ext-extension.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"this.extension = class extends ExtensionAPI {\n  getAPI(context) {\n    let api = {\n      getURL(url) {\n        return context.extension.baseURI.resolve(url);\n      },\n\n      get lastError() {\n        return context.lastError;\n      },\n\n      get inIncognitoContext() {\n        return context.incognito;\n      }\n\n    };\n\n    if (context.envType === \"addon_child\") {\n      api.getViews = function (fetchProperties) {\n        let result = Cu.cloneInto([], context.cloneScope);\n\n        for (let view of context.extension.views) {\n          if (!view.active) {\n            continue;\n          }\n\n          if (!context.principal.subsumes(view.principal)) {\n            continue;\n          }\n\n          if (fetchProperties !== null) {\n            if (fetchProperties.type !== null && view.viewType != fetchProperties.type) {\n              continue;\n            }\n\n            if (fetchProperties.windowId !== null && view.windowId != fetchProperties.windowId) {\n              continue;\n            }\n\n            if (fetchProperties.tabId !== null && view.tabId != fetchProperties.tabId) {\n              continue;\n            }\n          }\n\n          result.push(view.contentWindow);\n        }\n\n        return result;\n      };\n    }\n\n    return {\n      extension: api\n    };\n  }\n\n}"}],"observersMap":[{"filepath":"toolkit/components/extensions/parent/ext-idle.js","kind":"let","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"let observersMap = new WeakMap();"}],"getIdleObserverInfo":[{"filepath":"toolkit/components/extensions/parent/ext-idle.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const getIdleObserverInfo = (extension, context) => {\n  let observerInfo = observersMap.get(extension);\n\n  if (!observerInfo) {\n    observerInfo = {\n      observer: null,\n      detectionInterval: 60\n    };\n    observersMap.set(extension, observerInfo);\n    context.callOnClose({\n      close: () => {\n        let {\n          observer,\n          detectionInterval\n        } = observersMap.get(extension);\n\n        if (observer) {\n          idleService.removeIdleObserver(observer, detectionInterval);\n        }\n\n        observersMap.delete(extension);\n      }\n    });\n  }\n\n  return observerInfo;\n};"}],"getIdleObserver":[{"filepath":"toolkit/components/extensions/parent/ext-idle.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const getIdleObserver = (extension, context) => {\n  let observerInfo = getIdleObserverInfo(extension, context);\n  let {\n    observer,\n    detectionInterval\n  } = observerInfo;\n\n  if (!observer) {\n    observer = new class extends ExtensionCommon.EventEmitter {\n      observe(subject, topic, data) {\n        if (topic == \"idle\" || topic == \"active\") {\n          this.emit(\"stateChanged\", topic);\n        }\n      }\n\n    }();\n    idleService.addIdleObserver(observer, detectionInterval);\n    observerInfo.observer = observer;\n    observerInfo.detectionInterval = detectionInterval;\n  }\n\n  return observer;\n};"}],"setDetectionInterval":[{"filepath":"toolkit/components/extensions/parent/ext-idle.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const setDetectionInterval = (extension, context, newInterval) => {\n  let observerInfo = getIdleObserverInfo(extension, context);\n  let {\n    observer,\n    detectionInterval\n  } = observerInfo;\n\n  if (observer) {\n    idleService.removeIdleObserver(observer, detectionInterval);\n    idleService.addIdleObserver(observer, newInterval);\n  }\n\n  observerInfo.detectionInterval = newInterval;\n};"}],"idle":[{"filepath":"toolkit/components/extensions/parent/ext-idle.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.idle = class extends ExtensionAPI {\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    return {\n      idle: {\n        queryState: function (detectionIntervalInSeconds) {\n          if (idleService.idleTime < detectionIntervalInSeconds * 1000) {\n            return Promise.resolve(\"active\");\n          }\n\n          return Promise.resolve(\"idle\");\n        },\n        setDetectionInterval: function (detectionIntervalInSeconds) {\n          setDetectionInterval(extension, context, detectionIntervalInSeconds);\n        },\n        onStateChanged: new EventManager({\n          context,\n          name: \"idle.onStateChanged\",\n          register: fire => {\n            let listener = (event, data) => {\n              fire.sync(data);\n            };\n\n            getIdleObserver(extension, context).on(\"stateChanged\", listener);\n            return () => {\n              getIdleObserver(extension, context).off(\"stateChanged\", listener);\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"promiseDocumentLoaded":[{"filepath":"toolkit/components/extensions/parent/ext-identity.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  promiseDocumentLoaded\n} = ExtensionUtils;"},{"filepath":"browser/components/extensions/child/ext-devtools-panels.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":false,"child":true},"jscode":"var {\n  promiseDocumentLoaded\n} = ExtensionUtils;"},{"filepath":"browser/components/extensions/parent/ext-devtools-panels.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  promiseDocumentLoaded\n} = ExtensionUtils;"}],"checkRedirected":[{"filepath":"toolkit/components/extensions/parent/ext-identity.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const checkRedirected = (url, redirectURI) => {\n  return new Promise((resolve, reject) => {\n    let xhr = new XMLHttpRequest();\n    xhr.open(\"GET\", url);\n\n    xhr.onload = () => {\n      reject(0);\n    };\n\n    xhr.onerror = () => {\n      reject(xhr.status);\n    };\n\n    xhr.channel.notificationCallbacks = {\n      QueryInterface: ChromeUtils.generateQI([Ci.nsIInterfaceRequestor, Ci.nsIChannelEventSync]),\n      getInterface: ChromeUtils.generateQI([Ci.nsIChannelEventSink]),\n\n      asyncOnChannelRedirect(oldChannel, newChannel, flags, callback) {\n        let responseURL = newChannel.URI.spec;\n\n        if (responseURL.startsWith(redirectURI)) {\n          resolve(responseURL);\n          callback.onRedirectVerifyCallback(Cr.NS_BINDING_ABORTED);\n          return;\n        }\n\n        callback.onRedirectVerifyCallback(Cr.NS_OK);\n      }\n\n    };\n    xhr.send();\n  });\n};"}],"openOAuthWindow":[{"filepath":"toolkit/components/extensions/parent/ext-identity.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const openOAuthWindow = (details, redirectURI) => {\n  let args = Cc[\"@mozilla.org/array;1\"].createInstance(Ci.nsIMutableArray);\n  let supportsStringPrefURL = Cc[\"@mozilla.org/supports-string;1\"].createInstance(Ci.nsISupportsString);\n  supportsStringPrefURL.data = details.url;\n  args.appendElement(supportsStringPrefURL);\n  let window = Services.ww.openWindow(null, AppConstants.BROWSER_CHROME_URL, \"launchWebAuthFlow_dialog\", \"chrome,location=yes,centerscreen,dialog=no,resizable=yes,scrollbars=yes\", args);\n  return new Promise((resolve, reject) => {\n    let wpl;\n\n    function unloadlistener() {\n      window.removeEventListener(\"unload\", unloadlistener);\n      window.gBrowser.removeProgressListener(wpl);\n      reject({\n        message: \"User cancelled or denied access.\"\n      });\n    }\n\n    wpl = {\n      onStateChange(progress, request, flags, status) {\n        if (request && request.URI && request.URI.spec.startsWith(redirectURI)) {\n          window.gBrowser.webNavigation.stop(Ci.nsIWebNavigation.STOP_ALL);\n          window.removeEventListener(\"unload\", unloadlistener);\n          window.gBrowser.removeProgressListener(wpl);\n          window.close();\n          resolve(request.URI.spec);\n        }\n      }\n\n    };\n    promiseDocumentLoaded(window.document).then(() => {\n      window.gBrowser.addProgressListener(wpl);\n      window.addEventListener(\"unload\", unloadlistener);\n    });\n  });\n};"}],"identity":[{"filepath":"toolkit/components/extensions/parent/ext-identity.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.identity = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      identity: {\n        launchWebAuthFlowInParent: function (details, redirectURI) {\n          return checkRedirected(details.url, redirectURI).catch(requestError => {\n            if (requestError !== 0) {\n              Cu.reportError(`browser.identity auth check failed with ${requestError}`);\n              return Promise.reject({\n                message: \"Invalid request\"\n              });\n            }\n\n            if (!details.interactive) {\n              return Promise.reject({\n                message: `Requires user interaction`\n              });\n            }\n\n            return openOAuthWindow(details, redirectURI);\n          });\n        }\n      }\n    };\n  }\n\n}"},{"filepath":"toolkit/components/extensions/child/ext-identity.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"this.identity = class extends ExtensionAPI {\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    return {\n      identity: {\n        getRedirectURL: function (path = \"\") {\n          let hash = computeHash(extension.id);\n          let url = new URL(`https://${hash}.${redirectDomain}/`);\n          url.pathname = path;\n          return url.href;\n        },\n        launchWebAuthFlow: function (details) {\n          let url, redirectURI;\n\n          try {\n            url = new URL(details.url);\n          } catch (e) {\n            return Promise.reject({\n              message: \"details.url is invalid\"\n            });\n          }\n\n          try {\n            redirectURI = new URL(url.searchParams.get(\"redirect_uri\") || this.getRedirectURL());\n          } catch (e) {\n            return Promise.reject({\n              message: \"redirect_uri is invalid\"\n            });\n          }\n\n          return context.childManager.callParentAsyncFunction(\"identity.launchWebAuthFlowInParent\", [details, redirectURI.href]);\n        }\n      }\n    };\n  }\n\n}"}],"memory":[{"filepath":"toolkit/components/extensions/parent/ext-memory.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.memory = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      memory: {\n        async getInfo() {\n          return Memory.summary();\n        },\n\n        async minimizeMemoryUsage() {\n          await new Promise(resolve => {\n            const mgr = Cc[\"@mozilla.org/memory-reporter-manager;1\"].getService(Ci.nsIMemoryReporterManager);\n            mgr.minimizeMemoryUsage(resolve);\n          });\n        },\n\n        onLowMemory: new ExtensionCommon.EventManager({\n          context,\n          name: \"memory.onLowMemory\",\n          register: fire => {\n            lowMemListeners.add(fire.async);\n            return () => {\n              lowMemListeners.remove(fire.async);\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"getLinkType":[{"filepath":"toolkit/components/extensions/parent/ext-networkStatus.js","kind":"function","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"function getLinkType() {\n  switch (gNetworkLinkService.linkType) {\n    case gNetworkLinkService.LINK_TYPE_UNKNOWN:\n      return \"unknown\";\n\n    case gNetworkLinkService.LINK_TYPE_ETHERNET:\n      return \"ethernet\";\n\n    case gNetworkLinkService.LINK_TYPE_USB:\n      return \"usb\";\n\n    case gNetworkLinkService.LINK_TYPE_WIFI:\n      return \"wifi\";\n\n    case gNetworkLinkService.LINK_TYPE_WIMAX:\n      return \"wimax\";\n\n    case gNetworkLinkService.LINK_TYPE_2G:\n      return \"2g\";\n\n    case gNetworkLinkService.LINK_TYPE_3G:\n      return \"3g\";\n\n    case gNetworkLinkService.LINK_TYPE_4G:\n      return \"4g\";\n\n    default:\n      return \"unknown\";\n  }\n}"}],"getLinkStatus":[{"filepath":"toolkit/components/extensions/parent/ext-networkStatus.js","kind":"function","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"function getLinkStatus() {\n  if (!gNetworkLinkService.linkStatusKnown) {\n    return \"unknown\";\n  }\n\n  return gNetworkLinkService.isLinkUp ? \"up\" : \"down\";\n}"}],"getLinkInfo":[{"filepath":"toolkit/components/extensions/parent/ext-networkStatus.js","kind":"function","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"function getLinkInfo() {\n  return {\n    id: gNetworkLinkService.networkID || undefined,\n    status: getLinkStatus(),\n    type: getLinkType()\n  };\n}"}],"networkStatus":[{"filepath":"toolkit/components/extensions/parent/ext-networkStatus.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.networkStatus = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      networkStatus: {\n        getLinkInfo,\n        onConnectionChanged: new EventManager({\n          context,\n          name: \"networkStatus.onConnectionChanged\",\n          register: fire => {\n            let observerStatus = (subject, topic, data) => {\n              fire.async(getLinkInfo());\n            };\n\n            Services.obs.addObserver(observerStatus, \"network:link-status-changed\");\n            Services.obs.addObserver(observerStatus, \"network:link-type-changed\");\n            return () => {\n              Services.obs.removeObserver(observerStatus, \"network:link-status-changed\");\n              Services.obs.removeObserver(observerStatus, \"network:link-type-changed\");\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"permissions":[{"filepath":"toolkit/components/extensions/parent/ext-permissions.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.permissions = class extends ExtensionAPI {\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    return {\n      permissions: {\n        async request(perms) {\n          let {\n            permissions,\n            origins\n          } = perms;\n          let manifestPermissions = context.extension.manifest.optional_permissions;\n\n          for (let perm of permissions) {\n            if (!manifestPermissions.includes(perm)) {\n              throw new ExtensionError(`Cannot request permission ${perm} since it was not declared in optional_permissions`);\n            }\n          }\n\n          let optionalOrigins = context.extension.optionalOrigins;\n\n          for (let origin of origins) {\n            if (!optionalOrigins.subsumes(new MatchPattern(origin))) {\n              throw new ExtensionError(`Cannot request origin permission for ${origin} since it was not declared in optional_permissions`);\n            }\n          }\n\n          if (promptsEnabled) {\n            permissions = permissions.filter(perm => !context.extension.hasPermission(perm));\n            origins = origins.filter(origin => !context.extension.whiteListedHosts.subsumes(new MatchPattern(origin)));\n\n            if (!permissions.length && !origins.length) {\n              return true;\n            }\n\n            let browser = context.pendingEventBrowser || context.xulBrowser;\n            let allow = await new Promise(resolve => {\n              let subject = {\n                wrappedJSObject: {\n                  browser,\n                  name: context.extension.name,\n                  icon: context.extension.iconURL,\n                  permissions: {\n                    permissions,\n                    origins\n                  },\n                  resolve\n                }\n              };\n              Services.obs.notifyObservers(subject, \"webextension-optional-permission-prompt\");\n            });\n\n            if (!allow) {\n              return false;\n            }\n          }\n\n          if (origins.includes(\"<all_urls>\")) {\n            perms.permissions.push(\"<all_urls>\");\n          }\n\n          await ExtensionPermissions.add(extension.id, perms, extension);\n          return true;\n        },\n\n        async getAll() {\n          let perms = { ...context.extension.activePermissions\n          };\n          delete perms.apis;\n          perms.permissions = perms.permissions.filter(perm => !perm.startsWith(\"internal:\"));\n          return perms;\n        },\n\n        async contains(permissions) {\n          for (let perm of permissions.permissions) {\n            if (!context.extension.hasPermission(perm)) {\n              return false;\n            }\n          }\n\n          for (let origin of permissions.origins) {\n            if (!context.extension.whiteListedHosts.subsumes(new MatchPattern(origin))) {\n              return false;\n            }\n          }\n\n          return true;\n        },\n\n        async remove(permissions) {\n          await ExtensionPermissions.remove(extension.id, permissions, extension);\n          return true;\n        }\n\n      }\n    };\n  }\n\n}"}],"hasHandlerApp":[{"filepath":"toolkit/components/extensions/parent/ext-protocolHandlers.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const hasHandlerApp = handlerConfig => {\n  let protoInfo = protocolService.getProtocolHandlerInfo(handlerConfig.protocol);\n  let appHandlers = protoInfo.possibleApplicationHandlers;\n\n  for (let i = 0; i < appHandlers.length; i++) {\n    let handler = appHandlers.queryElementAt(i, Ci.nsISupports);\n\n    if (handler instanceof Ci.nsIWebHandlerApp && handler.uriTemplate === handlerConfig.uriTemplate) {\n      return true;\n    }\n  }\n\n  return false;\n};"}],"protocolHandlers":[{"filepath":"toolkit/components/extensions/parent/ext-protocolHandlers.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.protocolHandlers = class extends ExtensionAPI {\n  onManifestEntry(entryName) {\n    let {\n      extension\n    } = this;\n    let {\n      manifest\n    } = extension;\n\n    for (let handlerConfig of manifest.protocol_handlers) {\n      if (hasHandlerApp(handlerConfig)) {\n        continue;\n      }\n\n      let handler = Cc[\"@mozilla.org/uriloader/web-handler-app;1\"].createInstance(Ci.nsIWebHandlerApp);\n      handler.name = handlerConfig.name;\n      handler.uriTemplate = handlerConfig.uriTemplate;\n      let protoInfo = protocolService.getProtocolHandlerInfo(handlerConfig.protocol);\n      let handlers = protoInfo.possibleApplicationHandlers;\n\n      if (protoInfo.preferredApplicationHandler || handlers.length) {\n        protoInfo.alwaysAskBeforeHandling = true;\n      } else {\n        protoInfo.preferredApplicationHandler = handler;\n        protoInfo.alwaysAskBeforeHandling = false;\n      }\n\n      handlers.appendElement(handler);\n      handlerService.store(protoInfo);\n    }\n  }\n\n  onShutdown(isAppShutdown) {\n    let {\n      extension\n    } = this;\n    let {\n      manifest\n    } = extension;\n\n    if (isAppShutdown) {\n      return;\n    }\n\n    for (let handlerConfig of manifest.protocol_handlers) {\n      let protoInfo = protocolService.getProtocolHandlerInfo(handlerConfig.protocol);\n      let appHandlers = protoInfo.possibleApplicationHandlers;\n\n      for (let i = 0; i < appHandlers.length; i++) {\n        let handler = appHandlers.queryElementAt(i, Ci.nsISupports);\n\n        if (handler instanceof Ci.nsIWebHandlerApp && handler.uriTemplate === handlerConfig.uriTemplate) {\n          appHandlers.removeElementAt(i);\n\n          if (protoInfo.preferredApplicationHandler === handler) {\n            protoInfo.preferredApplicationHandler = null;\n            protoInfo.alwaysAskBeforeHandling = true;\n          }\n\n          handlerService.store(protoInfo);\n          break;\n        }\n      }\n    }\n  }\n\n}"}],"ToolkitModules":[{"filepath":"toolkit/components/extensions/parent/ext-notifications.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const ToolkitModules = {};"}],"ignoreEvent":[{"filepath":"toolkit/components/extensions/parent/ext-notifications.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ignoreEvent\n} = ExtensionCommon;"},{"filepath":"toolkit/components/extensions/parent/ext-downloads.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  EventEmitter,\n  ignoreEvent\n} = ExtensionCommon;"}],"Notification":[{"filepath":"toolkit/components/extensions/parent/ext-notifications.js","kind":"function","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"function Notification(context, notificationsMap, id, options) {\n  this.notificationsMap = notificationsMap;\n  this.id = id;\n  this.options = options;\n  let imageURL;\n\n  if (options.iconUrl) {\n    imageURL = context.extension.baseURI.resolve(options.iconUrl);\n  }\n\n  notificationsMap.set(id, this);\n\n  try {\n    let svc = Cc[\"@mozilla.org/alerts-service;1\"].getService(Ci.nsIAlertsService);\n    svc.showAlertNotification(imageURL, options.title, options.message, true, this.id, this, this.id, undefined, undefined, undefined, context.principal, context.incognito);\n  } catch (e) {\n    this.observe(null, \"alertfinished\", id);\n  }\n}"}],"notifications":[{"filepath":"toolkit/components/extensions/parent/ext-notifications.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.notifications = class extends ExtensionAPI {\n  constructor(extension) {\n    super(extension);\n    this.nextId = 0;\n    this.notificationsMap = new Map();\n    ToolkitModules.EventEmitter.decorate(this.notificationsMap);\n  }\n\n  onShutdown() {\n    for (let notification of this.notificationsMap.values()) {\n      notification.clear();\n    }\n  }\n\n  getAPI(context) {\n    let notificationsMap = this.notificationsMap;\n    return {\n      notifications: {\n        create: (notificationId, options) => {\n          if (!notificationId) {\n            notificationId = String(this.nextId++);\n          }\n\n          if (notificationsMap.has(notificationId)) {\n            notificationsMap.get(notificationId).clear();\n          }\n\n          new Notification(context, notificationsMap, notificationId, options);\n          return Promise.resolve(notificationId);\n        },\n        clear: function (notificationId) {\n          if (notificationsMap.has(notificationId)) {\n            notificationsMap.get(notificationId).clear();\n            return Promise.resolve(true);\n          }\n\n          return Promise.resolve(false);\n        },\n        getAll: function () {\n          let result = {};\n          notificationsMap.forEach((value, key) => {\n            result[key] = value.options;\n          });\n          return Promise.resolve(result);\n        },\n        onClosed: new EventManager({\n          context,\n          name: \"notifications.onClosed\",\n          register: fire => {\n            let listener = (event, notificationId) => {\n              fire.async(notificationId, true);\n            };\n\n            notificationsMap.on(\"closed\", listener);\n            return () => {\n              notificationsMap.off(\"closed\", listener);\n            };\n          }\n        }).api(),\n        onClicked: new EventManager({\n          context,\n          name: \"notifications.onClicked\",\n          register: fire => {\n            let listener = (event, notificationId) => {\n              fire.async(notificationId);\n            };\n\n            notificationsMap.on(\"clicked\", listener);\n            return () => {\n              notificationsMap.off(\"clicked\", listener);\n            };\n          }\n        }).api(),\n        onShown: new EventManager({\n          context,\n          name: \"notifications.onShown\",\n          register: fire => {\n            let listener = (event, notificationId) => {\n              fire.async(notificationId);\n            };\n\n            notificationsMap.on(\"shown\", listener);\n            return () => {\n              notificationsMap.off(\"shown\", listener);\n            };\n          }\n        }).api(),\n        onButtonClicked: ignoreEvent(context, \"notifications.onButtonClicked\")\n      }\n    };\n  }\n\n}"}],"runtime":[{"filepath":"toolkit/components/extensions/parent/ext-runtime.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.runtime = class extends ExtensionAPI {\n  constructor(...args) {\n    super(...args);\n    this.messagingListeners = new Map();\n  }\n\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    return {\n      runtime: {\n        onStartup: new EventManager({\n          context,\n          name: \"runtime.onStartup\",\n          register: fire => {\n            if (context.incognito) {\n              return () => {};\n            }\n\n            let listener = () => {\n              if (extension.startupReason === \"APP_STARTUP\") {\n                fire.sync();\n              }\n            };\n\n            extension.on(\"startup\", listener);\n            return () => {\n              extension.off(\"startup\", listener);\n            };\n          }\n        }).api(),\n        onInstalled: new EventManager({\n          context,\n          name: \"runtime.onInstalled\",\n          register: fire => {\n            let temporary = !!extension.addonData.temporarilyInstalled;\n\n            let listener = () => {\n              switch (extension.startupReason) {\n                case \"APP_STARTUP\":\n                  if (AddonManagerPrivate.browserUpdated) {\n                    fire.sync({\n                      reason: \"browser_update\",\n                      temporary\n                    });\n                  }\n\n                  break;\n\n                case \"ADDON_INSTALL\":\n                  fire.sync({\n                    reason: \"install\",\n                    temporary\n                  });\n                  break;\n\n                case \"ADDON_UPGRADE\":\n                  fire.sync({\n                    reason: \"update\",\n                    previousVersion: extension.addonData.oldVersion,\n                    temporary\n                  });\n                  break;\n              }\n            };\n\n            extension.on(\"startup\", listener);\n            return () => {\n              extension.off(\"startup\", listener);\n            };\n          }\n        }).api(),\n        onUpdateAvailable: new EventManager({\n          context,\n          name: \"runtime.onUpdateAvailable\",\n          register: fire => {\n            let instanceID = extension.addonData.instanceID;\n            AddonManager.addUpgradeListener(instanceID, upgrade => {\n              extension.upgrade = upgrade;\n              let details = {\n                version: upgrade.version\n              };\n              fire.sync(details);\n            });\n            return () => {\n              AddonManager.removeUpgradeListener(instanceID);\n            };\n          }\n        }).api(),\n        reload: async () => {\n          if (extension.upgrade) {\n            extension.upgrade.install();\n          } else {\n            let addon = await AddonManager.getAddonByID(extension.id);\n            addon.reload();\n          }\n        },\n\n        get lastError() {\n          return context.lastError;\n        },\n\n        getBrowserInfo: function () {\n          const {\n            name,\n            vendor,\n            version,\n            appBuildID\n          } = Services.appinfo;\n          const info = {\n            name,\n            vendor,\n            version,\n            buildID: appBuildID\n          };\n          return Promise.resolve(info);\n        },\n        getPlatformInfo: function () {\n          return Promise.resolve(ExtensionParent.PlatformInfo);\n        },\n        openOptionsPage: function () {\n          if (!extension.manifest.options_ui) {\n            return Promise.reject({\n              message: \"No `options_ui` declared\"\n            });\n          }\n\n          return openOptionsPage(extension).then(() => {});\n        },\n        setUninstallURL: function (url) {\n          if (url === null || url.length === 0) {\n            extension.uninstallURL = null;\n            return Promise.resolve();\n          }\n\n          let uri;\n\n          try {\n            uri = new URL(url);\n          } catch (e) {\n            return Promise.reject({\n              message: `Invalid URL: ${JSON.stringify(url)}`\n            });\n          }\n\n          if (uri.protocol != \"http:\" && uri.protocol != \"https:\") {\n            return Promise.reject({\n              message: \"url must have the scheme http or https\"\n            });\n          }\n\n          extension.uninstallURL = url;\n          return Promise.resolve();\n        },\n\n        openBrowserConsole() {\n          if (AppConstants.platform !== \"android\") {\n            DevToolsShim.openBrowserConsole();\n          }\n        },\n\n        addMessagingListener: event => {\n          let count = (this.messagingListeners.get(event) || 0) + 1;\n          this.messagingListeners.set(event, count);\n\n          if (count == 1) {\n            ExtensionCommon.EventManager.savePersistentListener(extension, \"runtime\", event);\n          }\n\n          ExtensionCommon.EventManager.clearOnePrimedListener(extension, \"runtime\", event);\n        },\n        removeMessagingListener: event => {\n          let count = this.messagingListeners.get(event);\n\n          if (!count) {\n            return;\n          }\n\n          this.messagingListeners.set(event, --count);\n\n          if (count == 0) {\n            ExtensionCommon.EventManager.clearPersistentListener(extension, \"runtime\", event);\n          }\n        }\n      }\n    };\n  }\n\n  primeListener(extension, event, fire, params) {\n    extension.wakeupBackground = () => {\n      let promise = fire.wakeup();\n      promise.then(() => {\n        extension.wakeupBackground = undefined;\n      });\n\n      extension.wakeupBackground = () => promise;\n\n      return promise;\n    };\n\n    return {\n      unregister() {\n        extension.wakeupBackground = undefined;\n      }\n\n    };\n  }\n\n}"},{"filepath":"toolkit/components/extensions/child/ext-runtime.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"this.runtime = class extends ExtensionAPI {\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    return {\n      runtime: {\n        onConnect: context.messenger.onConnect(\"runtime.onConnect\"),\n        onMessage: context.messenger.onMessage(\"runtime.onMessage\"),\n        onConnectExternal: context.messenger.onConnectExternal(\"runtime.onConnectExternal\"),\n        onMessageExternal: context.messenger.onMessageExternal(\"runtime.onMessageExternal\"),\n        connect: function (extensionId, connectInfo) {\n          let name = connectInfo !== null && connectInfo.name || \"\";\n          extensionId = extensionId || extension.id;\n          let recipient = {\n            extensionId\n          };\n          return context.messenger.connect(context.messageManager, name, recipient);\n        },\n\n        sendMessage(...args) {\n          let extensionId, message, options, responseCallback;\n\n          if (typeof args[args.length - 1] === \"function\") {\n            responseCallback = args.pop();\n          }\n\n          function checkOptions(options) {\n            if (typeof options !== \"object\") {\n              return [false, \"runtime.sendMessage's options argument is invalid\"];\n            }\n\n            for (let key of Object.keys(options)) {\n              return [false, `Unexpected property ${key}`];\n            }\n\n            return [true, {}];\n          }\n\n          if (!args.length) {\n            return Promise.reject({\n              message: \"runtime.sendMessage's message argument is missing\"\n            });\n          } else if (args.length === 1) {\n            message = args[0];\n          } else if (args.length === 2) {\n            let [validOpts] = checkOptions(args[1]);\n\n            if (validOpts || args[1] == null) {\n              [message, options] = args;\n            } else {\n              [extensionId, message] = args;\n            }\n          } else if (args.length === 3 || args.length === 4 && args[3] == null) {\n            [extensionId, message, options] = args;\n          } else if (args.length === 4 && !responseCallback) {\n            return Promise.reject({\n              message: \"runtime.sendMessage's last argument is not a function\"\n            });\n          } else {\n            return Promise.reject({\n              message: \"runtime.sendMessage received too many arguments\"\n            });\n          }\n\n          if (extensionId != null && typeof extensionId !== \"string\") {\n            return Promise.reject({\n              message: \"runtime.sendMessage's extensionId argument is invalid\"\n            });\n          }\n\n          extensionId = extensionId || extension.id;\n          let recipient = {\n            extensionId\n          };\n\n          if (options != null) {\n            let [valid, arg] = checkOptions(options);\n\n            if (!valid) {\n              return Promise.reject({\n                message: arg\n              });\n            }\n\n            Object.assign(recipient, arg);\n          }\n\n          return context.messenger.sendMessage(context.messageManager, message, recipient, responseCallback);\n        },\n\n        connectNative(application) {\n          let recipient = {\n            childId: context.childManager.id,\n            toNativeApp: application\n          };\n          return context.messenger.connectNative(context.messageManager, \"\", recipient);\n        },\n\n        sendNativeMessage(application, message) {\n          let recipient = {\n            childId: context.childManager.id,\n            toNativeApp: application\n          };\n          return context.messenger.sendNativeMessage(context.messageManager, message, recipient);\n        },\n\n        get lastError() {\n          return context.lastError;\n        },\n\n        getManifest() {\n          return Cu.cloneInto(extension.manifest, context.cloneScope);\n        },\n\n        id: extension.id,\n        getURL: function (url) {\n          return extension.baseURI.resolve(url);\n        }\n      }\n    };\n  }\n\n}"}],"enforceNoTemporaryAddon":[{"filepath":"toolkit/components/extensions/parent/ext-storage.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const enforceNoTemporaryAddon = extensionId => {\n  const EXCEPTION_MESSAGE = \"The storage API will not work with a temporary addon ID. \" + \"Please add an explicit addon ID to your manifest. \" + \"For more information see https://bugzil.la/1323228.\";\n\n  if (AddonManagerPrivate.isTemporaryInstallID(extensionId)) {\n    throw new ExtensionError(EXCEPTION_MESSAGE);\n  }\n};"}],"managedStorage":[{"filepath":"toolkit/components/extensions/parent/ext-storage.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const managedStorage = new WeakMap();"}],"lookupManagedStorage":[{"filepath":"toolkit/components/extensions/parent/ext-storage.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const lookupManagedStorage = async (extensionId, context) => {\n  let extensionPolicy = Services.policies.getExtensionPolicy(extensionId);\n\n  if (extensionPolicy) {\n    return ExtensionStorage._serializableMap(extensionPolicy);\n  }\n\n  let info = await NativeManifests.lookupManifest(\"storage\", extensionId, context);\n\n  if (info) {\n    return ExtensionStorage._serializableMap(info.manifest.data);\n  }\n\n  return null;\n};"}],"storage":[{"filepath":"toolkit/components/extensions/parent/ext-storage.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.storage = class extends ExtensionAPI {\n  constructor(extension) {\n    super(extension);\n    const messageName = `Extension:StorageLocalOnChanged:${extension.uuid}`;\n    Services.ppmm.addMessageListener(messageName, this);\n\n    this.clearStorageChangedListener = () => {\n      Services.ppmm.removeMessageListener(messageName, this);\n    };\n  }\n\n  onShutdown() {\n    const {\n      clearStorageChangedListener\n    } = this;\n    this.clearStorageChangedListener = null;\n\n    if (clearStorageChangedListener) {\n      clearStorageChangedListener();\n    }\n  }\n\n  receiveMessage({\n    name,\n    data\n  }) {\n    if (name !== `Extension:StorageLocalOnChanged:${this.extension.uuid}`) {\n      return;\n    }\n\n    ExtensionStorageIDB.notifyListeners(this.extension.id, data);\n  }\n\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    return {\n      storage: {\n        local: {\n          async callMethodInParentProcess(method, args) {\n            const res = await ExtensionStorageIDB.selectBackend({\n              extension\n            });\n\n            if (!res.backendEnabled) {\n              return ExtensionStorage[method](extension.id, ...args);\n            }\n\n            const persisted = extension.hasPermission(\"unlimitedStorage\");\n            const db = await ExtensionStorageIDB.open(res.storagePrincipal.deserialize(this, true), persisted);\n\n            try {\n              const changes = await db[method](...args);\n\n              if (changes) {\n                ExtensionStorageIDB.notifyListeners(extension.id, changes);\n              }\n\n              return changes;\n            } catch (err) {\n              const normalizedError = ExtensionStorageIDB.normalizeStorageError(err).message;\n              return Promise.reject({\n                message: String(normalizedError)\n              });\n            }\n          },\n\n          JSONFileBackend: {\n            get(spec) {\n              return ExtensionStorage.get(extension.id, spec);\n            },\n\n            set(items) {\n              return ExtensionStorage.set(extension.id, items);\n            },\n\n            remove(keys) {\n              return ExtensionStorage.remove(extension.id, keys);\n            },\n\n            clear() {\n              return ExtensionStorage.clear(extension.id);\n            }\n\n          },\n          IDBBackend: {\n            selectBackend() {\n              return ExtensionStorageIDB.selectBackend(context);\n            }\n\n          }\n        },\n        sync: {\n          get(spec) {\n            enforceNoTemporaryAddon(extension.id);\n            return extensionStorageSync.get(extension, spec, context);\n          },\n\n          set(items) {\n            enforceNoTemporaryAddon(extension.id);\n            return extensionStorageSync.set(extension, items, context);\n          },\n\n          remove(keys) {\n            enforceNoTemporaryAddon(extension.id);\n            return extensionStorageSync.remove(extension, keys, context);\n          },\n\n          clear() {\n            enforceNoTemporaryAddon(extension.id);\n            return extensionStorageSync.clear(extension, context);\n          }\n\n        },\n        managed: {\n          async get(keys) {\n            enforceNoTemporaryAddon(extension.id);\n            let lookup = managedStorage.get(extension);\n\n            if (!lookup) {\n              lookup = lookupManagedStorage(extension.id, context);\n              managedStorage.set(extension, lookup);\n            }\n\n            let data = await lookup;\n\n            if (!data) {\n              return Promise.reject({\n                message: \"Managed storage manifest not found\"\n              });\n            }\n\n            return ExtensionStorage._filterProperties(data, keys);\n          }\n\n        },\n        onChanged: new EventManager({\n          context,\n          name: \"storage.onChanged\",\n          register: fire => {\n            let listenerLocal = changes => {\n              fire.raw(changes, \"local\");\n            };\n\n            let listenerSync = changes => {\n              fire.async(changes, \"sync\");\n            };\n\n            ExtensionStorage.addOnChangedListener(extension.id, listenerLocal);\n            ExtensionStorageIDB.addOnChangedListener(extension.id, listenerLocal);\n            extensionStorageSync.addOnChangedListener(extension, listenerSync, context);\n            return () => {\n              ExtensionStorage.removeOnChangedListener(extension.id, listenerLocal);\n              ExtensionStorageIDB.removeOnChangedListener(extension.id, listenerLocal);\n              extensionStorageSync.removeOnChangedListener(extension, listenerSync);\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"},{"filepath":"toolkit/components/extensions/child/ext-storage.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"this.storage = class extends ExtensionAPI {\n  getLocalFileBackend(context, {\n    deserialize,\n    serialize\n  }) {\n    return {\n      get(keys) {\n        return measureOp(ExtensionTelemetry.storageLocalGetJSON, context.extension, () => {\n          return context.childManager.callParentAsyncFunction(\"storage.local.JSONFileBackend.get\", [serialize(keys)]).then(deserialize);\n        });\n      },\n\n      set(items) {\n        return measureOp(ExtensionTelemetry.storageLocalSetJSON, context.extension, () => {\n          return context.childManager.callParentAsyncFunction(\"storage.local.JSONFileBackend.set\", [serialize(items)]);\n        });\n      },\n\n      remove(keys) {\n        return context.childManager.callParentAsyncFunction(\"storage.local.JSONFileBackend.remove\", [serialize(keys)]);\n      },\n\n      clear() {\n        return context.childManager.callParentAsyncFunction(\"storage.local.JSONFileBackend.clear\", []);\n      }\n\n    };\n  }\n\n  getLocalIDBBackend(context, {\n    fireOnChanged,\n    serialize,\n    storagePrincipal\n  }) {\n    let dbPromise;\n\n    async function getDB() {\n      if (dbPromise) {\n        return dbPromise;\n      }\n\n      const persisted = context.extension.hasPermission(\"unlimitedStorage\");\n      dbPromise = ExtensionStorageIDB.open(storagePrincipal, persisted).catch(err => {\n        dbPromise = null;\n        throw err;\n      });\n      return dbPromise;\n    }\n\n    return {\n      get(keys) {\n        return measureOp(ExtensionTelemetry.storageLocalGetIDB, context.extension, async () => {\n          const db = await getDB();\n          return db.get(keys);\n        });\n      },\n\n      set(items) {\n        return measureOp(ExtensionTelemetry.storageLocalSetIDB, context.extension, async () => {\n          const db = await getDB();\n          const changes = await db.set(items, {\n            serialize: ExtensionStorage.serialize\n          });\n\n          if (changes) {\n            fireOnChanged(changes);\n          }\n        });\n      },\n\n      async remove(keys) {\n        const db = await getDB();\n        const changes = await db.remove(keys);\n\n        if (changes) {\n          fireOnChanged(changes);\n        }\n      },\n\n      async clear() {\n        const db = await getDB();\n        const changes = await db.clear(context.extension);\n\n        if (changes) {\n          fireOnChanged(changes);\n        }\n      }\n\n    };\n  }\n\n  getAPI(context) {\n    const {\n      extension\n    } = context;\n    const serialize = ExtensionStorage.serializeForContext.bind(null, context);\n    const deserialize = ExtensionStorage.deserializeForContext.bind(null, context);\n\n    function sanitize(items) {\n      if (typeof items != \"object\" || items === null || Array.isArray(items)) {\n        return items;\n      }\n\n      let sanitized = {};\n\n      for (let [key, value] of Object.entries(items)) {\n        sanitized[key] = ExtensionStorage.sanitize(value, context);\n      }\n\n      return sanitized;\n    }\n\n    function fireOnChanged(changes) {\n      Services.cpmm.sendAsyncMessage(`Extension:StorageLocalOnChanged:${extension.uuid}`, changes);\n    }\n\n    const getStorageLocalBackend = async () => {\n      const {\n        backendEnabled,\n        storagePrincipal\n      } = await ExtensionStorageIDB.selectBackend(context);\n\n      if (!backendEnabled) {\n        return this.getLocalFileBackend(context, {\n          deserialize,\n          serialize\n        });\n      }\n\n      return this.getLocalIDBBackend(context, {\n        storagePrincipal,\n        fireOnChanged,\n        serialize\n      });\n    };\n\n    let selectedBackend;\n    const useStorageIDBBackend = extension.getSharedData(\"storageIDBBackend\");\n\n    if (useStorageIDBBackend === false) {\n      selectedBackend = this.getLocalFileBackend(context, {\n        deserialize,\n        serialize\n      });\n    } else if (useStorageIDBBackend === true) {\n      selectedBackend = this.getLocalIDBBackend(context, {\n        storagePrincipal: extension.getSharedData(\"storageIDBPrincipal\"),\n        fireOnChanged,\n        serialize\n      });\n    }\n\n    let promiseStorageLocalBackend;\n    const local = {};\n\n    for (let method of [\"get\", \"set\", \"remove\", \"clear\"]) {\n      local[method] = async function (...args) {\n        try {\n          if (!selectedBackend) {\n            if (!promiseStorageLocalBackend) {\n              promiseStorageLocalBackend = getStorageLocalBackend().catch(err => {\n                promiseStorageLocalBackend = null;\n                throw err;\n              });\n            }\n\n            if (method !== \"get\") {\n              try {\n                const result = await context.childManager.callParentAsyncFunction(\"storage.local.callMethodInParentProcess\", [method, args]);\n                return result;\n              } catch (err) {\n                return Promise.reject(err);\n              }\n            }\n\n            selectedBackend = await promiseStorageLocalBackend;\n          }\n\n          const result = await selectedBackend[method](...args);\n          return result;\n        } catch (err) {\n          throw ExtensionStorageIDB.normalizeStorageError(err);\n        }\n      };\n    }\n\n    return {\n      storage: {\n        local,\n        sync: {\n          get(keys) {\n            keys = sanitize(keys);\n            return context.childManager.callParentAsyncFunction(\"storage.sync.get\", [keys]);\n          },\n\n          set(items) {\n            items = sanitize(items);\n            return context.childManager.callParentAsyncFunction(\"storage.sync.set\", [items]);\n          }\n\n        },\n        managed: {\n          get(keys) {\n            return context.childManager.callParentAsyncFunction(\"storage.managed.get\", [serialize(keys)]).then(deserialize);\n          },\n\n          set(items) {\n            return Promise.reject({\n              message: \"storage.managed is read-only\"\n            });\n          },\n\n          remove(keys) {\n            return Promise.reject({\n              message: \"storage.managed is read-only\"\n            });\n          },\n\n          clear() {\n            return Promise.reject({\n              message: \"storage.managed is read-only\"\n            });\n          }\n\n        },\n        onChanged: new EventManager({\n          context,\n          name: \"storage.onChanged\",\n          register: fire => {\n            let onChanged = (data, area) => {\n              let changes = new context.cloneScope.Object();\n\n              for (let [key, value] of Object.entries(data)) {\n                changes[key] = deserialize(value);\n              }\n\n              fire.raw(changes, area);\n            };\n\n            let parent = context.childManager.getParentEvent(\"storage.onChanged\");\n            parent.addListener(onChanged);\n            return () => {\n              parent.removeListener(onChanged);\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"SCALAR_TYPES":[{"filepath":"toolkit/components/extensions/parent/ext-telemetry.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const SCALAR_TYPES = {\n  count: Ci.nsITelemetry.SCALAR_TYPE_COUNT,\n  string: Ci.nsITelemetry.SCALAR_TYPE_STRING,\n  boolean: Ci.nsITelemetry.SCALAR_TYPE_BOOLEAN\n};"}],"desktopCheck":[{"filepath":"toolkit/components/extensions/parent/ext-telemetry.js","kind":"function","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"function desktopCheck() {\n  if (AppConstants.MOZ_BUILD_APP !== \"browser\") {\n    throw new ExtensionUtils.ExtensionError(\"This API is only supported on desktop\");\n  }\n}"}],"telemetry":[{"filepath":"toolkit/components/extensions/parent/ext-telemetry.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.telemetry = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      telemetry: {\n        submitPing(type, payload, options) {\n          desktopCheck();\n\n          try {\n            TelemetryController.submitExternalPing(type, payload, options);\n          } catch (ex) {\n            throw new ExtensionUtils.ExtensionError(ex);\n          }\n        },\n\n        canUpload() {\n          desktopCheck();\n\n          try {\n            const result = \"canUpload\" in TelemetryController ? TelemetryController.canUpload() : Services.prefs.getBoolPref(TelemetryUtils.Preferences.FhrUploadEnabled, false);\n            return result;\n          } catch (ex) {\n            throw new ExtensionUtils.ExtensionError(ex);\n          }\n        },\n\n        scalarAdd(name, value) {\n          desktopCheck();\n\n          try {\n            Services.telemetry.scalarAdd(name, value);\n          } catch (ex) {\n            throw new ExtensionUtils.ExtensionError(ex);\n          }\n        },\n\n        scalarSet(name, value) {\n          desktopCheck();\n\n          try {\n            Services.telemetry.scalarSet(name, value);\n          } catch (ex) {\n            throw new ExtensionUtils.ExtensionError(ex);\n          }\n        },\n\n        scalarSetMaximum(name, value) {\n          desktopCheck();\n\n          try {\n            Services.telemetry.scalarSetMaximum(name, value);\n          } catch (ex) {\n            throw new ExtensionUtils.ExtensionError(ex);\n          }\n        },\n\n        recordEvent(category, method, object, value, extra) {\n          desktopCheck();\n\n          try {\n            Services.telemetry.recordEvent(category, method, object, value, extra);\n          } catch (ex) {\n            throw new ExtensionUtils.ExtensionError(ex);\n          }\n        },\n\n        registerScalars(category, data) {\n          desktopCheck();\n\n          try {\n            Object.keys(data).forEach(scalar => {\n              data[scalar].kind = SCALAR_TYPES[data[scalar].kind];\n            });\n            Services.telemetry.registerScalars(category, data);\n          } catch (ex) {\n            throw new ExtensionUtils.ExtensionError(ex);\n          }\n        },\n\n        setEventRecordingEnabled(category, enabled) {\n          desktopCheck();\n\n          try {\n            Services.telemetry.setEventRecordingEnabled(category, enabled);\n          } catch (ex) {\n            throw new ExtensionUtils.ExtensionError(ex);\n          }\n        },\n\n        registerEvents(category, data) {\n          desktopCheck();\n\n          try {\n            Services.telemetry.registerEvents(category, data);\n          } catch (ex) {\n            throw new ExtensionUtils.ExtensionError(ex);\n          }\n        }\n\n      }\n    };\n  }\n\n}"}],"ExtensionCommon":[{"filepath":"toolkit/components/extensions/parent/ext-toolkit.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionCommon\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionCommon.jsm\");"},{"filepath":"toolkit/components/extensions/child/ext-toolkit.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"var {\n  ExtensionCommon\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionCommon.jsm\");"},{"filepath":"mobile/android/components/extensions/ext-utils.js","kind":"var","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"var {\n  ExtensionCommon\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionCommon.jsm\");"}],"userScripts":[{"filepath":"toolkit/components/extensions/parent/ext-userScripts.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.userScripts = class extends ExtensionAPI {\n  constructor(...args) {\n    super(...args);\n    this.userScriptsMap = new Map();\n  }\n\n  getAPI(context) {\n    const {\n      extension\n    } = context;\n    const registeredScriptIds = new Set();\n\n    const unregisterContentScripts = scriptIds => {\n      if (scriptIds.length === 0) {\n        return Promise.resolve();\n      }\n\n      for (let scriptId of scriptIds) {\n        registeredScriptIds.delete(scriptId);\n        extension.registeredContentScripts.delete(scriptId);\n        this.userScriptsMap.delete(scriptId);\n      }\n\n      extension.updateContentScripts();\n      return context.extension.broadcast(\"Extension:UnregisterContentScripts\", {\n        id: context.extension.id,\n        scriptIds\n      });\n    };\n\n    context.callOnClose({\n      close() {\n        unregisterContentScripts(Array.from(registeredScriptIds));\n      }\n\n    });\n    return {\n      userScripts: {\n        register: async details => {\n          for (let origin of details.matches) {\n            if (!extension.whiteListedHosts.subsumes(new MatchPattern(origin))) {\n              throw new ExtensionError(`Permission denied to register a user script for ${origin}`);\n            }\n          }\n\n          const userScript = new UserScriptParent(details);\n          const {\n            scriptId\n          } = userScript;\n          this.userScriptsMap.set(scriptId, userScript);\n          const scriptOptions = userScript.serialize();\n          await extension.broadcast(\"Extension:RegisterContentScript\", {\n            id: extension.id,\n            options: scriptOptions,\n            scriptId\n          });\n          extension.registeredContentScripts.set(scriptId, scriptOptions);\n          extension.updateContentScripts();\n          return scriptId;\n        },\n        unregister: async scriptId => {\n          const userScript = this.userScriptsMap.get(scriptId);\n\n          if (!userScript) {\n            throw new Error(`No such user script ID: ${scriptId}`);\n          }\n\n          userScript.destroy();\n          await unregisterContentScripts([scriptId]);\n        }\n      }\n    };\n  }\n\n}"},{"filepath":"toolkit/components/extensions/child/ext-userScripts.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"this.userScripts = class extends ExtensionAPI {\n  getAPI(context) {\n    const blobURLsByHash = new Map();\n    const userScriptsByBlobURL = new DefaultMap(() => new Set());\n\n    function revokeBlobURLs(scriptId, options) {\n      let revokedUrls = new Set();\n\n      for (let url of options.js) {\n        if (userScriptsByBlobURL.has(url)) {\n          let scriptIds = userScriptsByBlobURL.get(url);\n          scriptIds.delete(scriptId);\n\n          if (scriptIds.size === 0) {\n            revokedUrls.add(url);\n            userScriptsByBlobURL.delete(url);\n            context.cloneScope.URL.revokeObjectURL(url);\n          }\n        }\n      }\n\n      for (let [hash, url] of blobURLsByHash) {\n        if (revokedUrls.has(url)) {\n          blobURLsByHash.delete(hash);\n        }\n      }\n    }\n\n    const getBlobURL = async (text, scriptId) => {\n      const buffer = await crypto.subtle.digest(\"SHA-1\", new TextEncoder().encode(text));\n      const hash = String.fromCharCode(...new Uint16Array(buffer));\n      let blobURL = blobURLsByHash.get(hash);\n\n      if (blobURL) {\n        userScriptsByBlobURL.get(blobURL).add(scriptId);\n        return blobURL;\n      }\n\n      const blob = new context.cloneScope.Blob([text], {\n        type: \"text/javascript\"\n      });\n      blobURL = context.cloneScope.URL.createObjectURL(blob);\n      userScriptsByBlobURL.get(blobURL).add(scriptId);\n      blobURLsByHash.set(hash, blobURL);\n      return blobURL;\n    };\n\n    function convertToAPIObject(scriptId, options) {\n      const registeredScript = new UserScriptChild({\n        context,\n        scriptId,\n        onScriptUnregister: () => revokeBlobURLs(scriptId, options)\n      });\n      const scriptAPI = Cu.cloneInto(registeredScript.api(), context.cloneScope, {\n        cloneFunctions: true\n      });\n      return scriptAPI;\n    }\n\n    context.callOnClose({\n      close() {\n        if (!context.cloneScope) {\n          return;\n        }\n\n        for (let blobURL of blobURLsByHash.values()) {\n          context.cloneScope.URL.revokeObjectURL(blobURL);\n        }\n      }\n\n    });\n    return {\n      userScripts: {\n        register(options) {\n          if (!userScriptsEnabled) {\n            throw new ExtensionError(USERSCRIPT_DISABLED_ERRORMSG);\n          }\n\n          let scriptId = getUniqueId();\n          return context.cloneScope.Promise.resolve().then(async () => {\n            options.scriptId = scriptId;\n            options.js = await Promise.all(options.js.map(js => {\n              return js.file || getBlobURL(js.code, scriptId);\n            }));\n            await context.childManager.callParentAsyncFunction(\"userScripts.register\", [options]);\n            return convertToAPIObject(scriptId, options);\n          });\n        }\n\n      }\n    };\n  }\n\n}"}],"defaultTransitionTypes":[{"filepath":"toolkit/components/extensions/parent/ext-webNavigation.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const defaultTransitionTypes = {\n  topFrame: \"link\",\n  subFrame: \"auto_subframe\"\n};"}],"frameTransitions":[{"filepath":"toolkit/components/extensions/parent/ext-webNavigation.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const frameTransitions = {\n  anyFrame: {\n    qualifiers: [\"server_redirect\", \"client_redirect\", \"forward_back\"]\n  },\n  topFrame: {\n    types: [\"reload\", \"form_submit\"]\n  }\n};"}],"tabTransitions":[{"filepath":"toolkit/components/extensions/parent/ext-webNavigation.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const tabTransitions = {\n  topFrame: {\n    qualifiers: [\"from_address_bar\"],\n    types: [\"auto_bookmark\", \"typed\", \"keyword\", \"generated\", \"link\"]\n  },\n  subFrame: {\n    types: [\"manual_subframe\"]\n  }\n};"}],"isTopLevelFrame":[{"filepath":"toolkit/components/extensions/parent/ext-webNavigation.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const isTopLevelFrame = ({\n  frameId,\n  parentFrameId\n}) => {\n  return frameId == 0 && parentFrameId == -1;\n};"}],"fillTransitionProperties":[{"filepath":"toolkit/components/extensions/parent/ext-webNavigation.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const fillTransitionProperties = (eventName, src, dst) => {\n  if (eventName == \"onCommitted\" || eventName == \"onHistoryStateUpdated\" || eventName == \"onReferenceFragmentUpdated\") {\n    let frameTransitionData = src.frameTransitionData || {};\n    let tabTransitionData = src.tabTransitionData || {};\n    let transitionType,\n        transitionQualifiers = [];\n\n    for (let qualifier of frameTransitions.anyFrame.qualifiers) {\n      if (frameTransitionData[qualifier]) {\n        transitionQualifiers.push(qualifier);\n      }\n    }\n\n    if (isTopLevelFrame(dst)) {\n      for (let type of frameTransitions.topFrame.types) {\n        if (frameTransitionData[type]) {\n          transitionType = type;\n        }\n      }\n\n      for (let qualifier of tabTransitions.topFrame.qualifiers) {\n        if (tabTransitionData[qualifier]) {\n          transitionQualifiers.push(qualifier);\n        }\n      }\n\n      for (let type of tabTransitions.topFrame.types) {\n        if (tabTransitionData[type]) {\n          transitionType = type;\n        }\n      }\n\n      if (!transitionType) {\n        transitionType = defaultTransitionTypes.topFrame;\n      }\n    } else {\n      transitionType = tabTransitionData.link ? \"manual_subframe\" : defaultTransitionTypes.subFrame;\n    }\n\n    dst.transitionType = transitionType;\n    dst.transitionQualifiers = transitionQualifiers;\n  }\n};"}],"convertGetFrameResult":[{"filepath":"toolkit/components/extensions/parent/ext-webNavigation.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const convertGetFrameResult = (tabId, data) => {\n  return {\n    errorOccurred: data.errorOccurred,\n    url: data.url,\n    tabId,\n    frameId: data.frameId,\n    parentFrameId: data.parentFrameId\n  };\n};"}],"webNavigation":[{"filepath":"toolkit/components/extensions/parent/ext-webNavigation.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.webNavigation = class extends ExtensionAPI {\n  getAPI(context) {\n    let {\n      tabManager\n    } = context.extension;\n    return {\n      webNavigation: {\n        onTabReplaced: new EventManager({\n          context,\n          name: \"webNavigation.onTabReplaced\",\n          register: fire => {\n            return () => {};\n          }\n        }).api(),\n        onBeforeNavigate: new WebNavigationEventManager(context, \"onBeforeNavigate\").api(),\n        onCommitted: new WebNavigationEventManager(context, \"onCommitted\").api(),\n        onDOMContentLoaded: new WebNavigationEventManager(context, \"onDOMContentLoaded\").api(),\n        onCompleted: new WebNavigationEventManager(context, \"onCompleted\").api(),\n        onErrorOccurred: new WebNavigationEventManager(context, \"onErrorOccurred\").api(),\n        onReferenceFragmentUpdated: new WebNavigationEventManager(context, \"onReferenceFragmentUpdated\").api(),\n        onHistoryStateUpdated: new WebNavigationEventManager(context, \"onHistoryStateUpdated\").api(),\n        onCreatedNavigationTarget: new WebNavigationEventManager(context, \"onCreatedNavigationTarget\").api(),\n\n        getAllFrames(details) {\n          let tab = tabManager.get(details.tabId);\n          let {\n            innerWindowID,\n            messageManager\n          } = tab.browser;\n          let recipient = {\n            innerWindowID\n          };\n          return context.sendMessage(messageManager, \"WebNavigation:GetAllFrames\", {}, {\n            recipient\n          }).then(results => results.map(convertGetFrameResult.bind(null, details.tabId)));\n        },\n\n        getFrame(details) {\n          let tab = tabManager.get(details.tabId);\n          let recipient = {\n            innerWindowID: tab.browser.innerWindowID\n          };\n          let mm = tab.browser.messageManager;\n          return context.sendMessage(mm, \"WebNavigation:GetFrame\", {\n            options: details\n          }, {\n            recipient\n          }).then(result => {\n            return result ? convertGetFrameResult(details.tabId, result) : Promise.reject({\n              message: `No frame found with frameId: ${details.frameId}`\n            });\n          });\n        }\n\n      }\n    };\n  }\n\n}"}],"registerEvent":[{"filepath":"toolkit/components/extensions/parent/ext-webRequest.js","kind":"function","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"function registerEvent(extension, eventName, fire, filter, info, remoteTab = null) {\n  let listener = async data => {\n    let browserData = {\n      tabId: -1,\n      windowId: -1\n    };\n\n    if (data.browser) {\n      browserData = tabTracker.getBrowserData(data.browser);\n    }\n\n    if (filter.tabId != null && browserData.tabId != filter.tabId) {\n      return;\n    }\n\n    if (filter.windowId != null && browserData.windowId != filter.windowId) {\n      return;\n    }\n\n    let event = data.serialize(eventName);\n    event.tabId = browserData.tabId;\n\n    if (data.originAttributes) {\n      event.incognito = data.originAttributes.privateBrowsingId > 0;\n\n      if (extension.hasPermission(\"cookies\")) {\n        event.cookieStoreId = getCookieStoreIdForOriginAttributes(data.originAttributes);\n      }\n    }\n\n    if (data.registerTraceableChannel) {\n      if (fire.wakeup) {\n        await fire.wakeup();\n      }\n\n      data.registerTraceableChannel(extension.policy, remoteTab);\n    }\n\n    return fire.sync(event);\n  };\n\n  let filter2 = {};\n\n  if (filter.urls) {\n    let perms = new MatchPatternSet([...extension.whiteListedHosts.patterns, ...extension.optionalOrigins.patterns]);\n    filter2.urls = new MatchPatternSet(filter.urls);\n\n    if (!perms.overlapsAll(filter2.urls)) {\n      Cu.reportError(\"The webRequest.addListener filter doesn't overlap with host permissions.\");\n    }\n  }\n\n  if (filter.types) {\n    filter2.types = filter.types;\n  }\n\n  if (filter.tabId) {\n    filter2.tabId = filter.tabId;\n  }\n\n  if (filter.windowId) {\n    filter2.windowId = filter.windowId;\n  }\n\n  if (filter.incognito !== undefined) {\n    filter2.incognito = filter.incognito;\n  }\n\n  let blockingAllowed = extension.hasPermission(\"webRequestBlocking\");\n  let info2 = [];\n\n  if (info) {\n    for (let desc of info) {\n      if (desc == \"blocking\" && !blockingAllowed) {\n        Cu.reportError(\"Using webRequest.addListener with the blocking option \" + \"requires the 'webRequestBlocking' permission.\");\n      } else {\n        info2.push(desc);\n      }\n    }\n  }\n\n  let listenerDetails = {\n    addonId: extension.id,\n    policy: extension.policy,\n    blockingAllowed\n  };\n  WebRequest[eventName].addListener(listener, filter2, info2, listenerDetails);\n  return {\n    unregister: () => {\n      WebRequest[eventName].removeListener(listener);\n    },\n\n    convert(_fire, context) {\n      fire = _fire;\n      remoteTab = context.xulBrowser.frameLoader.remoteTab;\n    }\n\n  };\n}"}],"makeWebRequestEvent":[{"filepath":"toolkit/components/extensions/parent/ext-webRequest.js","kind":"function","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"function makeWebRequestEvent(context, name) {\n  return new EventManager({\n    context,\n    name: `webRequest.${name}`,\n    persistent: {\n      module: \"webRequest\",\n      event: name\n    },\n    register: (fire, filter, info) => {\n      return registerEvent(context.extension, name, fire, filter, info, context.xulBrowser.frameLoader.remoteTab).unregister;\n    }\n  }).api();\n}"}],"webRequest":[{"filepath":"toolkit/components/extensions/parent/ext-webRequest.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.webRequest = class extends ExtensionAPI {\n  primeListener(extension, event, fire, params) {\n    return registerEvent(extension, event, fire, ...params);\n  }\n\n  getAPI(context) {\n    return {\n      webRequest: {\n        onBeforeRequest: makeWebRequestEvent(context, \"onBeforeRequest\"),\n        onBeforeSendHeaders: makeWebRequestEvent(context, \"onBeforeSendHeaders\"),\n        onSendHeaders: makeWebRequestEvent(context, \"onSendHeaders\"),\n        onHeadersReceived: makeWebRequestEvent(context, \"onHeadersReceived\"),\n        onAuthRequired: makeWebRequestEvent(context, \"onAuthRequired\"),\n        onBeforeRedirect: makeWebRequestEvent(context, \"onBeforeRedirect\"),\n        onResponseStarted: makeWebRequestEvent(context, \"onResponseStarted\"),\n        onErrorOccurred: makeWebRequestEvent(context, \"onErrorOccurred\"),\n        onCompleted: makeWebRequestEvent(context, \"onCompleted\"),\n        getSecurityInfo: function (requestId, options = {}) {\n          return WebRequest.getSecurityInfo({\n            id: requestId,\n            policy: context.extension.policy,\n            remoteTab: context.xulBrowser.frameLoader.remoteTab,\n            options\n          });\n        },\n        handlerBehaviorChanged: function () {}\n      }\n    };\n  }\n\n}"},{"filepath":"toolkit/components/extensions/child/ext-webRequest.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"this.webRequest = class extends ExtensionAPI {\n  getAPI(context) {\n    let filters = new WeakSet();\n    context.callOnClose({\n      close() {\n        for (let filter of ChromeUtils.nondeterministicGetWeakSetKeys(filters)) {\n          try {\n            filter.disconnect();\n          } catch (e) {}\n        }\n      }\n\n    });\n    return {\n      webRequest: {\n        filterResponseData(requestId) {\n          requestId = parseInt(requestId, 10);\n          let streamFilter = context.cloneScope.StreamFilter.create(requestId, context.extension.id);\n          filters.add(streamFilter);\n          return streamFilter;\n        }\n\n      }\n    };\n  }\n\n}"}],"commands":[{"filepath":"browser/components/extensions/parent/ext-commands.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.commands = class extends ExtensionAPI {\n  static onUninstall(extensionId) {\n    return ExtensionShortcuts.removeCommandsFromStorage(extensionId);\n  }\n\n  async onManifestEntry(entryName) {\n    let shortcuts = new ExtensionShortcuts({\n      extension: this.extension,\n      onCommand: name => this.emit(\"command\", name)\n    });\n    this.extension.shortcuts = shortcuts;\n    await shortcuts.loadCommands();\n    await shortcuts.register();\n  }\n\n  onShutdown() {\n    this.extension.shortcuts.unregister();\n  }\n\n  getAPI(context) {\n    return {\n      commands: {\n        getAll: () => this.extension.shortcuts.allCommands(),\n        update: args => this.extension.shortcuts.updateCommand(args),\n        reset: name => this.extension.shortcuts.resetCommand(name),\n        onCommand: new EventManager({\n          context,\n          name: \"commands.onCommand\",\n          inputHandling: true,\n          register: fire => {\n            let listener = (eventName, commandName) => {\n              fire.async(commandName);\n            };\n\n            this.on(\"command\", listener);\n            return () => {\n              this.off(\"command\", listener);\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"SpreadArgs":[{"filepath":"browser/components/extensions/parent/ext-devtools-inspectedWindow.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  SpreadArgs\n} = ExtensionCommon;"},{"filepath":"browser/components/extensions/parent/ext-devtools-network.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  SpreadArgs\n} = ExtensionCommon;"}],"devtools_inspectedWindow":[{"filepath":"browser/components/extensions/parent/ext-devtools-inspectedWindow.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.devtools_inspectedWindow = class extends ExtensionAPI {\n  getAPI(context) {\n    let waitForInspectedWindowFront;\n    const callerInfo = {\n      addonId: context.extension.id,\n      url: context.extension.baseURI.spec\n    };\n    return {\n      devtools: {\n        inspectedWindow: {\n          async eval(expression, options) {\n            if (!waitForInspectedWindowFront) {\n              waitForInspectedWindowFront = getInspectedWindowFront(context);\n            }\n\n            const front = await waitForInspectedWindowFront;\n            const evalOptions = Object.assign({}, options, getToolboxEvalOptions(context));\n            const evalResult = await front.eval(callerInfo, expression, evalOptions);\n            return new SpreadArgs([evalResult.value, evalResult.exceptionInfo]);\n          },\n\n          async reload(options) {\n            const {\n              ignoreCache,\n              userAgent,\n              injectedScript\n            } = options || {};\n\n            if (!waitForInspectedWindowFront) {\n              waitForInspectedWindowFront = getInspectedWindowFront(context);\n            }\n\n            const front = await waitForInspectedWindowFront;\n            front.reload(callerInfo, {\n              ignoreCache,\n              userAgent,\n              injectedScript\n            });\n          }\n\n        }\n      }\n    };\n  }\n\n}"},{"filepath":"browser/components/extensions/child/ext-devtools-inspectedWindow.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":false,"child":true},"jscode":"this.devtools_inspectedWindow = class extends ExtensionAPI {\n  getAPI(context) {\n    let tabId = context.devtoolsToolboxInfo && context.devtoolsToolboxInfo.inspectedWindowTabId;\n    return {\n      devtools: {\n        inspectedWindow: {\n          get tabId() {\n            return tabId;\n          }\n\n        }\n      }\n    };\n  }\n\n}"}],"devtools_network":[{"filepath":"browser/components/extensions/parent/ext-devtools-network.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.devtools_network = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      devtools: {\n        network: {\n          onNavigated: new EventManager({\n            context,\n            name: \"devtools.onNavigated\",\n            register: fire => {\n              let listener = data => {\n                fire.async(data.url);\n              };\n\n              let targetPromise = getDevToolsTargetForContext(context);\n              targetPromise.then(target => {\n                target.on(\"navigate\", listener);\n              });\n              return () => {\n                targetPromise.then(target => {\n                  target.off(\"navigate\", listener);\n                });\n              };\n            }\n          }).api(),\n          getHAR: function () {\n            return context.devToolsToolbox.getHARFromNetMonitor();\n          },\n          onRequestFinished: new EventManager({\n            context,\n            name: \"devtools.network.onRequestFinished\",\n            register: fire => {\n              const listener = data => {\n                fire.async(data);\n              };\n\n              const toolbox = context.devToolsToolbox;\n              toolbox.addRequestFinishedListener(listener);\n              return () => {\n                toolbox.removeRequestFinishedListener(listener);\n              };\n            }\n          }).api(),\n          Request: {\n            async getContent(requestId) {\n              return context.devToolsToolbox.fetchResponseContent(requestId).then(({\n                content\n              }) => new SpreadArgs([content.text, content.mimeType])).catch(err => {\n                const debugName = context.extension.policy.debugName;\n                const errorMsg = \"Unexpected error while fetching response content\";\n                Cu.reportError(`${debugName}: ${errorMsg} for ${requestId}: ${err}`);\n                throw new ExtensionError(errorMsg);\n              });\n            }\n\n          }\n        }\n      }\n    };\n  }\n\n}"},{"filepath":"browser/components/extensions/child/ext-devtools-network.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":false,"child":true},"jscode":"this.devtools_network = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      devtools: {\n        network: {\n          onRequestFinished: new EventManager({\n            context,\n            name: \"devtools.network.onRequestFinished\",\n            register: fire => {\n              let onFinished = data => {\n                const loader = new ChildNetworkResponseLoader(context, data.requestId);\n                const harEntry = { ...data.harEntry,\n                  ...loader.api()\n                };\n                const result = Cu.cloneInto(harEntry, context.cloneScope, {\n                  cloneFunctions: true\n                });\n                fire.asyncWithoutClone(result);\n              };\n\n              let parent = context.childManager.getParentEvent(\"devtools.network.onRequestFinished\");\n              parent.addListener(onFinished);\n              return () => {\n                parent.removeListener(onFinished);\n              };\n            }\n          }).api()\n        }\n      }\n    };\n  }\n\n}"}],"AddonStudies":[{"filepath":"browser/components/extensions/parent/ext-normandyAddonStudy.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const {\n  AddonStudies\n} = ChromeUtils.import(\"resource://normandy/lib/AddonStudies.jsm\");"}],"ClientID":[{"filepath":"browser/components/extensions/parent/ext-normandyAddonStudy.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const {\n  ClientID\n} = ChromeUtils.import(\"resource://gre/modules/ClientID.jsm\");"}],"normandyAddonStudy":[{"filepath":"browser/components/extensions/parent/ext-normandyAddonStudy.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.normandyAddonStudy = class extends ExtensionAPI {\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    return {\n      normandyAddonStudy: {\n        async getStudy() {\n          const studies = await AddonStudies.getAll();\n          return studies.find(study => study.addonId === extension.id);\n        },\n\n        async endStudy(reason) {\n          const study = await this.getStudy();\n          await AddonStudies.markAsEnded(study, reason);\n          const addon = await AddonManager.getAddonByID(study.addonId);\n\n          if (addon) {\n            await addon.uninstall();\n          }\n        },\n\n        async getClientMetadata() {\n          return {\n            updateChannel: Services.appinfo.defaultUpdateChannel,\n            fxVersion: Services.appinfo.version,\n            clientID: await ClientID.getClientID()\n          };\n        },\n\n        onUnenroll: new EventManager({\n          context,\n          name: \"normandyAddonStudy.onUnenroll\",\n          register: fire => {\n            const listener = async reason => {\n              await fire.async(reason);\n            };\n\n            AddonStudies.addUnenrollListener(extension.id, listener);\n            return () => {\n              AddonStudies.removeUnenrollListener(extension.id, listener);\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"DefaultMap":[{"filepath":"browser/components/extensions/parent/ext-pkcs11.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  DefaultMap\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/child/ext-userScripts.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"var {\n  DefaultMap,\n  ExtensionError,\n  getUniqueId\n} = ExtensionUtils;"},{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  DefaultMap,\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/parent/ext-tabs-base.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  DefaultMap,\n  DefaultWeakMap,\n  ExtensionError,\n  getWinUtils\n} = ExtensionUtils;"}],"findModuleByPath":[{"filepath":"browser/components/extensions/parent/ext-pkcs11.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const findModuleByPath = function (path) {\n  for (let module of pkcs11db.listModules()) {\n    if (module && module.libName === path) {\n      return module;\n    }\n  }\n\n  return null;\n};"}],"pkcs11":[{"filepath":"browser/components/extensions/parent/ext-pkcs11.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.pkcs11 = class extends ExtensionAPI {\n  getAPI(context) {\n    let manifestCache = new DefaultMap(async name => {\n      let hostInfo = await NativeManifests.lookupManifest(\"pkcs11\", name, context);\n\n      if (hostInfo) {\n        if (AppConstants.platform === \"win\") {\n          hostInfo.manifest.path = OS.Path.join(OS.Path.dirname(hostInfo.path), hostInfo.manifest.path);\n        }\n\n        let manifestLib = OS.Path.basename(hostInfo.manifest.path);\n\n        if (AppConstants.platform !== \"linux\") {\n          manifestLib = manifestLib.toLowerCase(manifestLib);\n        }\n\n        if (manifestLib !== ctypes.libraryName(\"nssckbi\")) {\n          return hostInfo.manifest;\n        }\n      }\n\n      return Promise.reject({\n        message: `No such PKCS#11 module ${name}`\n      });\n    });\n    return {\n      pkcs11: {\n        async isModuleInstalled(name) {\n          let manifest = await manifestCache.get(name);\n          return findModuleByPath(manifest.path) !== null;\n        },\n\n        async installModule(name, flags = 0) {\n          let manifest = await manifestCache.get(name);\n\n          if (!manifest.description) {\n            return Promise.reject({\n              message: `The description field in the manifest for PKCS#11 module ${name} must have a value`\n            });\n          }\n\n          pkcs11db.addModule(manifest.description, manifest.path, flags, 0);\n        },\n\n        async uninstallModule(name) {\n          let manifest = await manifestCache.get(name);\n          let module = findModuleByPath(manifest.path);\n\n          if (!module) {\n            return Promise.reject({\n              message: `The PKCS#11 module ${name} is not loaded`\n            });\n          }\n\n          pkcs11db.deleteModule(module.name);\n        },\n\n        async getModuleSlots(name) {\n          let manifest = await manifestCache.get(name);\n          let module = findModuleByPath(manifest.path);\n\n          if (!module) {\n            return Promise.reject({\n              message: `The module ${name} is not installed`\n            });\n          }\n\n          let rv = [];\n\n          for (let slot of module.listSlots()) {\n            let token = slot.getToken();\n            let slotobj = {\n              name: slot.name,\n              token: null\n            };\n\n            if (slot.status != 1) {\n                slotobj.token = {\n                  name: token.tokenName,\n                  manufacturer: token.tokenManID,\n                  HWVersion: token.tokenHWVersion,\n                  FWVersion: token.tokenFWVersion,\n                  serial: token.tokenSerialNumber,\n                  isLoggedIn: token.isLoggedIn()\n                };\n              }\n\n            rv.push(slotobj);\n          }\n\n          return rv;\n        }\n\n      }\n    };\n  }\n\n}"}],"omnibox":[{"filepath":"browser/components/extensions/parent/ext-omnibox.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.omnibox = class extends ExtensionAPI {\n  onManifestEntry(entryName) {\n    let {\n      extension\n    } = this;\n    let {\n      manifest\n    } = extension;\n    let keyword = manifest.omnibox.keyword;\n\n    try {\n      ExtensionSearchHandler.registerKeyword(keyword, extension);\n      this.keyword = keyword;\n    } catch (e) {\n      extension.manifestError(e.message);\n    }\n  }\n\n  onShutdown() {\n    ExtensionSearchHandler.unregisterKeyword(this.keyword);\n  }\n\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    return {\n      omnibox: {\n        setDefaultSuggestion: suggestion => {\n          try {\n            ExtensionSearchHandler.setDefaultSuggestion(this.keyword, suggestion);\n          } catch (e) {\n            return Promise.reject(e.message);\n          }\n        },\n        onInputStarted: new EventManager({\n          context,\n          name: \"omnibox.onInputStarted\",\n          register: fire => {\n            let listener = eventName => {\n              fire.sync();\n            };\n\n            extension.on(ExtensionSearchHandler.MSG_INPUT_STARTED, listener);\n            return () => {\n              extension.off(ExtensionSearchHandler.MSG_INPUT_STARTED, listener);\n            };\n          }\n        }).api(),\n        onInputCancelled: new EventManager({\n          context,\n          name: \"omnibox.onInputCancelled\",\n          register: fire => {\n            let listener = eventName => {\n              fire.sync();\n            };\n\n            extension.on(ExtensionSearchHandler.MSG_INPUT_CANCELLED, listener);\n            return () => {\n              extension.off(ExtensionSearchHandler.MSG_INPUT_CANCELLED, listener);\n            };\n          }\n        }).api(),\n        onInputEntered: new EventManager({\n          context,\n          name: \"omnibox.onInputEntered\",\n          register: fire => {\n            let listener = (eventName, text, disposition) => {\n              fire.sync(text, disposition);\n            };\n\n            extension.on(ExtensionSearchHandler.MSG_INPUT_ENTERED, listener);\n            return () => {\n              extension.off(ExtensionSearchHandler.MSG_INPUT_ENTERED, listener);\n            };\n          }\n        }).api(),\n        addSuggestions: (id, suggestions) => {\n          try {\n            ExtensionSearchHandler.addSuggestions(this.keyword, id, suggestions);\n          } catch (e) {}\n        },\n        onInputChanged: new EventManager({\n          context,\n          name: \"omnibox.onInputChanged\",\n          register: fire => {\n            let listener = (eventName, text, id) => {\n              fire.sync(text, id);\n            };\n\n            extension.on(ExtensionSearchHandler.MSG_INPUT_CHANGED, listener);\n            return () => {\n              extension.off(ExtensionSearchHandler.MSG_INPUT_CHANGED, listener);\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"},{"filepath":"browser/components/extensions/child/ext-omnibox.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":false,"child":true},"jscode":"this.omnibox = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      omnibox: {\n        onInputChanged: new EventManager({\n          context,\n          name: \"omnibox.onInputChanged\",\n          register: fire => {\n            let listener = (text, id) => {\n              fire.asyncWithoutClone(text, suggestions => {\n                context.childManager.callParentFunctionNoReturn(\"omnibox.addSuggestions\", [id, suggestions]);\n              });\n            };\n\n            context.childManager.getParentEvent(\"omnibox.onInputChanged\").addListener(listener);\n            return () => {\n              context.childManager.getParentEvent(\"omnibox.onInputChanged\").removeListener(listener);\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"getDataURI":[{"filepath":"browser/components/extensions/parent/ext-search.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"async function getDataURI(localIconUrl) {\n  let response;\n\n  try {\n    response = await fetch(localIconUrl);\n  } catch (e) {\n    Cu.reportError(e);\n    return;\n  }\n\n  let buffer = await response.arrayBuffer();\n  let contentType = response.headers.get(\"content-type\");\n  let bytes = new Uint8Array(buffer);\n  let str = String.fromCharCode.apply(null, bytes);\n  return `data:${contentType};base64,${btoa(str)}`;\n}"}],"search":[{"filepath":"browser/components/extensions/parent/ext-search.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.search = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      search: {\n        async get() {\n          await searchInitialized;\n          let visibleEngines = await Services.search.getVisibleEngines();\n          let defaultEngine = await Services.search.getDefault();\n          return Promise.all(visibleEngines.map(async engine => {\n            let favIconUrl;\n\n            if (engine.iconURI) {\n              if (engine.iconURI.schemeIs(\"moz-extension\") && engine.iconURI.host !== context.extension.uuid) {\n                favIconUrl = await getDataURI(engine.iconURI.spec);\n              } else {\n                favIconUrl = engine.iconURI.spec;\n              }\n            }\n\n            return {\n              name: engine.name,\n              isDefault: engine.name === defaultEngine.name,\n              alias: engine.alias || undefined,\n              favIconUrl\n            };\n          }));\n        },\n\n        async search(searchProperties) {\n          await searchInitialized;\n          let engine;\n\n          if (searchProperties.engine) {\n            engine = Services.search.getEngineByName(searchProperties.engine);\n\n            if (!engine) {\n              throw new ExtensionError(`${searchProperties.engine} was not found`);\n            }\n          } else {\n            engine = await Services.search.getDefault();\n          }\n\n          let submission = engine.getSubmission(searchProperties.query, null, \"webextension\");\n          let options = {\n            postData: submission.postData,\n            triggeringPrincipal: context.principal\n          };\n          let tabbrowser;\n\n          if (searchProperties.tabId === null) {\n            let {\n              gBrowser\n            } = windowTracker.topWindow;\n            let nativeTab = gBrowser.addTab(submission.uri.spec, options);\n\n            if (!searchLoadInBackground) {\n              gBrowser.selectedTab = nativeTab;\n            }\n\n            tabbrowser = gBrowser;\n          } else {\n            let tab = tabTracker.getTab(searchProperties.tabId);\n            tab.linkedBrowser.loadURI(submission.uri.spec, options);\n            tabbrowser = tab.linkedBrowser.getTabBrowser();\n          }\n\n          BrowserUsageTelemetry.recordSearch(tabbrowser, engine, \"webextension\");\n        }\n\n      }\n    };\n  }\n\n}"}],"SHORTCUTS_PREF":[{"filepath":"browser/components/extensions/parent/ext-topSites.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const SHORTCUTS_PREF = \"browser.newtabpage.activity-stream.improvesearch.topSiteSearchShortcuts\";"}],"topSites":[{"filepath":"browser/components/extensions/parent/ext-topSites.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.topSites = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      topSites: {\n        get: async function (options) {\n          let links = options.newtab ? AboutNewTab.getTopSites() : await NewTabUtils.activityStreamLinks.getTopSites({\n            ignoreBlocked: options.includeBlocked,\n            onePerDomain: options.onePerDomain,\n            numItems: options.limit,\n            includeFavicon: options.includeFavicon\n          });\n\n          if (options.includePinned && !options.newtab) {\n            let pinnedLinks = NewTabUtils.pinnedLinks.links;\n\n            if (options.includeFavicon) {\n              pinnedLinks = NewTabUtils.activityStreamProvider._faviconBytesToDataURI((await NewTabUtils.activityStreamProvider._addFavicons(pinnedLinks)));\n            }\n\n            pinnedLinks.forEach((pinnedLink, index) => {\n              if (pinnedLink && (!pinnedLink.searchTopSite || options.includeSearchShortcuts)) {\n                links = links.filter(link => link.url != pinnedLink.url && (!options.onePerDomain || NewTabUtils.extractSite(link.url) != pinnedLink.baseDomain));\n                links.splice(index, 0, pinnedLink);\n              }\n            });\n          }\n\n          if (options.includeSearchShortcuts && Services.prefs.getBoolPref(SHORTCUTS_PREF, false) && !options.newtab) {\n            links = links.map(link => {\n              let searchProvider = getSearchProvider(shortURL(link));\n\n              if (searchProvider) {\n                link.searchTopSite = true;\n                link.label = searchProvider.keyword;\n                link.url = searchProvider.url;\n              }\n\n              return link;\n            });\n          }\n\n          if (typeof options.limit == \"number\") {\n            links = links.slice(0, options.limit);\n          }\n\n          return links.map(link => ({\n            type: link.searchTopSite ? \"search\" : \"url\",\n            url: link.url,\n            title: link.label || link.title || link.hostname || \"\",\n            favicon: options.includeFavicon ? link.favicon || link.tippyTopIcon || null : null\n          }));\n        }\n      }\n    };\n  }\n\n}"}],"STORE_TYPE":[{"filepath":"browser/components/extensions/parent/ext-url-overrides.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const STORE_TYPE = \"url_overrides\";"}],"NEW_TAB_SETTING_NAME":[{"filepath":"browser/components/extensions/parent/ext-url-overrides.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const NEW_TAB_SETTING_NAME = \"newTabURL\";"}],"NEW_TAB_CONFIRMED_TYPE":[{"filepath":"browser/components/extensions/parent/ext-url-overrides.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const NEW_TAB_CONFIRMED_TYPE = \"newTabNotification\";"}],"NEW_TAB_PRIVATE_ALLOWED":[{"filepath":"browser/components/extensions/parent/ext-url-overrides.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const NEW_TAB_PRIVATE_ALLOWED = \"browser.newtab.privateAllowed\";"}],"NEW_TAB_EXTENSION_CONTROLLED":[{"filepath":"browser/components/extensions/parent/ext-url-overrides.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const NEW_TAB_EXTENSION_CONTROLLED = \"browser.newtab.extensionControlled\";"}],"setNewTabURL":[{"filepath":"browser/components/extensions/parent/ext-url-overrides.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function setNewTabURL(extensionId, url) {\n  if (extensionId) {\n    newTabPopup.addObserver(extensionId);\n    let policy = ExtensionParent.WebExtensionPolicy.getByID(extensionId);\n    Services.prefs.setBoolPref(NEW_TAB_PRIVATE_ALLOWED, policy && policy.privateBrowsingAllowed);\n    Services.prefs.setBoolPref(NEW_TAB_EXTENSION_CONTROLLED, true);\n  } else {\n    newTabPopup.removeObserver();\n    Services.prefs.clearUserPref(NEW_TAB_PRIVATE_ALLOWED);\n    Services.prefs.clearUserPref(NEW_TAB_EXTENSION_CONTROLLED);\n  }\n\n  if (url) {\n    aboutNewTabService.newTabURL = url;\n  }\n}"}],"urlOverrides":[{"filepath":"browser/components/extensions/parent/ext-url-overrides.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.urlOverrides = class extends ExtensionAPI {\n  static async onDisable(id) {\n    newTabPopup.clearConfirmation(id);\n    await ExtensionSettingsStore.initialize();\n\n    if (ExtensionSettingsStore.hasSetting(id, STORE_TYPE, NEW_TAB_SETTING_NAME)) {\n      ExtensionSettingsStore.disable(id, STORE_TYPE, NEW_TAB_SETTING_NAME);\n    }\n  }\n\n  static async onUninstall(id) {\n    newTabPopup.clearConfirmation(id);\n    await ExtensionSettingsStore.initialize();\n\n    if (ExtensionSettingsStore.hasSetting(id, STORE_TYPE, NEW_TAB_SETTING_NAME)) {\n      ExtensionSettingsStore.removeSetting(id, STORE_TYPE, NEW_TAB_SETTING_NAME);\n    }\n  }\n\n  static async onUpdate(id, manifest) {\n    if (!manifest.chrome_url_overrides || !manifest.chrome_url_overrides.newtab) {\n      await ExtensionSettingsStore.initialize();\n\n      if (ExtensionSettingsStore.hasSetting(id, STORE_TYPE, NEW_TAB_SETTING_NAME)) {\n        ExtensionSettingsStore.removeSetting(id, STORE_TYPE, NEW_TAB_SETTING_NAME);\n      }\n    }\n  }\n\n  async onManifestEntry(entryName) {\n    let {\n      extension\n    } = this;\n    let {\n      manifest\n    } = extension;\n    await ExtensionSettingsStore.initialize();\n\n    if (manifest.chrome_url_overrides.newtab) {\n      let url = extension.baseURI.resolve(manifest.chrome_url_overrides.newtab);\n      let item = await ExtensionSettingsStore.addSetting(extension.id, STORE_TYPE, NEW_TAB_SETTING_NAME, url, () => aboutNewTabService.newTabURL);\n\n      if (item) {\n        setNewTabURL(item.id, item.value || item.initialValue);\n      }\n\n      extension.on(\"add-permissions\", async (ignoreEvent, permissions) => {\n        if (permissions.permissions.includes(\"internal:privateBrowsingAllowed\")) {\n          let item = await ExtensionSettingsStore.getSetting(STORE_TYPE, NEW_TAB_SETTING_NAME);\n\n          if (item && item.id == extension.id) {\n            Services.prefs.setBoolPref(NEW_TAB_PRIVATE_ALLOWED, true);\n          }\n        }\n      });\n      extension.on(\"remove-permissions\", async (ignoreEvent, permissions) => {\n        if (permissions.permissions.includes(\"internal:privateBrowsingAllowed\")) {\n          let item = await ExtensionSettingsStore.getSetting(STORE_TYPE, NEW_TAB_SETTING_NAME);\n\n          if (item && item.id == extension.id) {\n            Services.prefs.setBoolPref(NEW_TAB_PRIVATE_ALLOWED, false);\n          }\n        }\n      });\n    }\n  }\n\n}"}],"CC":[{"filepath":"toolkit/components/extensions/child/ext-identity.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"var {\n  Constructor: CC\n} = Components;"}],"CryptoHash":[{"filepath":"toolkit/components/extensions/child/ext-identity.js","kind":"let","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"let CryptoHash = CC(\"@mozilla.org/security/hash;1\", \"nsICryptoHash\", \"initWithString\");"}],"computeHash":[{"filepath":"toolkit/components/extensions/child/ext-identity.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"const computeHash = str => {\n  let byteArr = new TextEncoder().encode(str);\n  let hash = new CryptoHash(\"sha1\");\n  hash.update(byteArr, byteArr.length);\n  return CommonUtils.bytesAsHex(hash.finish(false));\n};"}],"errorMatches":[{"filepath":"toolkit/components/extensions/child/ext-test.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"const errorMatches = (error, expectedError, context) => {\n  if (typeof error === \"object\" && error !== null && !context.principal.subsumes(Cu.getObjectPrincipal(error))) {\n    Cu.reportError(\"Error object belongs to the wrong scope.\");\n    return false;\n  }\n\n  if (expectedError === null) {\n    return true;\n  }\n\n  if (typeof expectedError === \"function\") {\n    return context.runSafeWithoutClone(expectedError, error);\n  }\n\n  if (typeof error !== \"object\" || error == null || typeof error.message !== \"string\") {\n    return false;\n  }\n\n  if (typeof expectedError === \"string\") {\n    return error.message === expectedError;\n  }\n\n  try {\n    return expectedError.test(error.message);\n  } catch (e) {\n    Cu.reportError(e);\n  }\n\n  return false;\n};"}],"toSource":[{"filepath":"toolkit/components/extensions/child/ext-test.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"const toSource = value => {\n  if (value === null) {\n    return \"null\";\n  }\n\n  if (value === undefined) {\n    return \"undefined\";\n  }\n\n  if (typeof value === \"string\") {\n    return JSON.stringify(value);\n  }\n\n  try {\n    return String(value.toSource());\n  } catch (e) {\n    return \"<unknown>\";\n  }\n};"}],"test":[{"filepath":"toolkit/components/extensions/child/ext-test.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"this.test = class extends ExtensionAPI {\n  getAPI(context) {\n    const {\n      extension\n    } = context;\n\n    function getStack() {\n      return new context.Error().stack.replace(/^/gm, \"    \");\n    }\n\n    function assertTrue(value, msg) {\n      extension.emit(\"test-result\", Boolean(value), String(msg), getStack());\n    }\n\n    class TestEventManager extends EventManager {\n      addListener(callback, ...args) {\n        super.addListener(function (...args) {\n          try {\n            callback.call(this, ...args);\n          } catch (e) {\n            assertTrue(false, `${e}\\n${e.stack}`);\n          }\n        }, ...args);\n      }\n\n    }\n\n    return {\n      test: {\n        sendMessage(...args) {\n          extension.emit(\"test-message\", ...args);\n        },\n\n        notifyPass(msg) {\n          extension.emit(\"test-done\", true, msg, getStack());\n        },\n\n        notifyFail(msg) {\n          extension.emit(\"test-done\", false, msg, getStack());\n        },\n\n        log(msg) {\n          extension.emit(\"test-log\", true, msg, getStack());\n        },\n\n        fail(msg) {\n          assertTrue(false, msg);\n        },\n\n        succeed(msg) {\n          assertTrue(true, msg);\n        },\n\n        assertTrue(value, msg) {\n          assertTrue(value, msg);\n        },\n\n        assertFalse(value, msg) {\n          assertTrue(!value, msg);\n        },\n\n        assertEq(expected, actual, msg) {\n          let equal = expected === actual;\n          expected = String(expected);\n          actual = String(actual);\n\n          if (!equal && expected === actual) {\n            actual += \" (different)\";\n          }\n\n          extension.emit(\"test-eq\", equal, String(msg), expected, actual, getStack());\n        },\n\n        assertRejects(promise, expectedError, msg) {\n          promise = Promise.resolve(promise);\n\n          if (msg) {\n            msg = `: ${msg}`;\n          }\n\n          return promise.then(result => {\n            assertTrue(false, `Promise resolved, expected rejection${msg}`);\n          }, error => {\n            let errorMessage = toSource(error && error.message);\n            assertTrue(errorMatches(error, expectedError, context), `Promise rejected, expecting rejection to match ${toSource(expectedError)}, got ${errorMessage}${msg}`);\n          });\n        },\n\n        assertThrows(func, expectedError, msg) {\n          if (msg) {\n            msg = `: ${msg}`;\n          }\n\n          try {\n            func();\n            assertTrue(false, `Function did not throw, expected error${msg}`);\n          } catch (error) {\n            let errorMessage = toSource(error && error.message);\n            assertTrue(errorMatches(error, expectedError, context), `Function threw, expecting error to match ${toSource(expectedError)}got ${errorMessage}${msg}`);\n          }\n        },\n\n        onMessage: new TestEventManager({\n          context,\n          name: \"test.onMessage\",\n          register: fire => {\n            let handler = (event, ...args) => {\n              fire.async(...args);\n            };\n\n            extension.on(\"test-harness-message\", handler);\n            return () => {\n              extension.off(\"test-harness-message\", handler);\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"USERSCRIPT_PREFNAME":[{"filepath":"toolkit/components/extensions/child/ext-userScripts.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"var USERSCRIPT_PREFNAME = \"extensions.webextensions.userScripts.enabled\";"},{"filepath":"toolkit/components/extensions/child/ext-userScripts-content.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"var USERSCRIPT_PREFNAME = \"extensions.webextensions.userScripts.enabled\";"}],"USERSCRIPT_DISABLED_ERRORMSG":[{"filepath":"toolkit/components/extensions/child/ext-userScripts.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"var USERSCRIPT_DISABLED_ERRORMSG = `userScripts APIs are currently experimental and must be enabled with the ${USERSCRIPT_PREFNAME} preference.`;"},{"filepath":"toolkit/components/extensions/child/ext-userScripts-content.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"var USERSCRIPT_DISABLED_ERRORMSG = `userScripts APIs are currently experimental and must be enabled with the ${USERSCRIPT_PREFNAME} preference.`;"}],"menusChild":[{"filepath":"browser/components/extensions/child/ext-menus-child.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":false,"child":true},"jscode":"this.menusChild = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      menus: {\n        getTargetElement(targetElementId) {\n          let element;\n          let lastMenuTarget = ContextMenuChild.getLastTarget(context.contentWindow.docShell.browsingContext);\n\n          if (lastMenuTarget && Math.floor(lastMenuTarget.timeStamp) === targetElementId) {\n            element = lastMenuTarget.targetRef.get();\n          }\n\n          if (element && element.getRootNode({\n            composed: true\n          }) === context.contentWindow.document) {\n            return element;\n          }\n\n          return null;\n        }\n\n      }\n    };\n  }\n\n}"}],"devtools":[{"filepath":"browser/components/extensions/child/ext-devtools.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":false,"child":true},"jscode":"this.devtools = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      devtools: {}\n    };\n  }\n\n}"},{"filepath":"browser/components/extensions/parent/ext-devtools.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.devtools = class extends ExtensionAPI {\n  constructor(extension) {\n    super(extension);\n    this.pageDefinition = null;\n    this.onToolboxCreated = this.onToolboxCreated.bind(this);\n    this.onToolboxDestroy = this.onToolboxDestroy.bind(this);\n  }\n\n  static onUninstall(extensionId) {\n    const prefBranch = Services.prefs.getBranch(`${getDevToolsPrefBranchName(extensionId)}.`);\n    prefBranch.deleteBranch(\"\");\n  }\n\n  onManifestEntry(entryName) {\n    const {\n      extension\n    } = this;\n    this.initDevToolsPref();\n    this.pageDefinition = new DevToolsPageDefinition(extension, extension.manifest.devtools_page);\n\n    if (!this.isDevToolsPageDisabled()) {\n      this.pageDefinition.build();\n    }\n\n    DevToolsShim.on(\"toolbox-created\", this.onToolboxCreated);\n    DevToolsShim.on(\"toolbox-destroy\", this.onToolboxDestroy);\n  }\n\n  onShutdown() {\n    DevToolsShim.off(\"toolbox-created\", this.onToolboxCreated);\n    DevToolsShim.off(\"toolbox-destroy\", this.onToolboxDestroy);\n    this.pageDefinition.shutdown();\n    this.pageDefinition = null;\n\n    for (let toolbox of DevToolsShim.getToolboxes()) {\n      toolbox.unregisterWebExtension(this.extension.uuid);\n    }\n\n    this.uninitDevToolsPref();\n  }\n\n  getAPI(context) {\n    return {\n      devtools: {}\n    };\n  }\n\n  onToolboxCreated(toolbox) {\n    if (!toolbox.target.isLocalTab || !this.extension.canAccessWindow(toolbox.target.tab.ownerGlobal)) {\n      return;\n    }\n\n    toolbox.registerWebExtension(this.extension.uuid, {\n      name: this.extension.name,\n      pref: `${getDevToolsPrefBranchName(this.extension.id)}.enabled`\n    });\n\n    if (toolbox.isWebExtensionEnabled(this.extension.uuid)) {\n      this.pageDefinition.buildForToolbox(toolbox);\n    }\n  }\n\n  onToolboxDestroy(target) {\n    if (!target.isLocalTab) {\n      return;\n    }\n\n    this.pageDefinition.shutdownForTarget(target);\n  }\n\n  initDevToolsPref() {\n    const prefBranch = Services.prefs.getBranch(`${getDevToolsPrefBranchName(this.extension.id)}.`);\n\n    if (prefBranch.getPrefType(\"enabled\") === prefBranch.PREF_INVALID) {\n      prefBranch.setBoolPref(\"enabled\", true);\n    }\n\n    this.devtoolsPrefBranch = prefBranch;\n    this.devtoolsPrefBranch.addObserver(\"enabled\", this);\n  }\n\n  uninitDevToolsPref() {\n    this.devtoolsPrefBranch.removeObserver(\"enabled\", this);\n    this.devtoolsPrefBranch = null;\n  }\n\n  isDevToolsPageDisabled() {\n    return !this.devtoolsPrefBranch.getBoolPref(\"enabled\", false);\n  }\n\n  observe(subject, topic, prefName) {\n    if (subject !== this.devtoolsPrefBranch || prefName !== \"enabled\") {\n      return;\n    }\n\n    if (this.isDevToolsPageDisabled()) {\n      this.pageDefinition.shutdown();\n    } else {\n      this.pageDefinition.build();\n    }\n  }\n\n}"}],"tabs":[{"filepath":"browser/components/extensions/child/ext-tabs.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":false,"child":true},"jscode":"this.tabs = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      tabs: {\n        connect: function (tabId, connectInfo) {\n          let name = \"\";\n\n          if (connectInfo && connectInfo.name !== null) {\n            name = connectInfo.name;\n          }\n\n          let recipient = {\n            extensionId: context.extension.id,\n            tabId\n          };\n\n          if (connectInfo && connectInfo.frameId !== null) {\n            recipient.frameId = connectInfo.frameId;\n          }\n\n          return context.messenger.connect(context.messageManager, name, recipient);\n        },\n        sendMessage: function (tabId, message, options, responseCallback) {\n          let recipient = {\n            extensionId: context.extension.id,\n            tabId: tabId\n          };\n\n          if (options && options.frameId !== null) {\n            recipient.frameId = options.frameId;\n          }\n\n          return context.messenger.sendMessage(context.messageManager, message, recipient, responseCallback);\n        }\n      }\n    };\n  }\n\n}"},{"filepath":"mobile/android/components/extensions/ext-c-tabs.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"this.tabs = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      tabs: {\n        connect: function (tabId, connectInfo) {\n          let name = \"\";\n\n          if (connectInfo && connectInfo.name !== null) {\n            name = connectInfo.name;\n          }\n\n          let recipient = {\n            extensionId: context.extension.id,\n            tabId\n          };\n\n          if (connectInfo && connectInfo.frameId !== null) {\n            recipient.frameId = connectInfo.frameId;\n          }\n\n          return context.messenger.connect(context.messageManager, name, recipient);\n        },\n        sendMessage: function (tabId, message, options, responseCallback) {\n          let recipient = {\n            extensionId: context.extension.id,\n            tabId: tabId\n          };\n\n          if (options && options.frameId !== null) {\n            recipient.frameId = options.frameId;\n          }\n\n          return context.messenger.sendMessage(context.messageManager, message, recipient, responseCallback);\n        }\n      }\n    };\n  }\n\n}"},{"filepath":"mobile/android/components/extensions/ext-tabs.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"this.tabs = class extends ExtensionAPI {\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    let {\n      tabManager\n    } = extension;\n\n    function getTabOrActive(tabId) {\n      if (tabId !== null) {\n        return tabTracker.getTab(tabId);\n      }\n\n      return tabTracker.activeTab;\n    }\n\n    async function promiseTabWhenReady(tabId) {\n      let tab;\n\n      if (tabId !== null) {\n        tab = tabManager.get(tabId);\n      } else {\n        tab = tabManager.getWrapper(tabTracker.activeTab);\n      }\n\n      if (!tab) {\n        throw new ExtensionError(tabId == null ? \"Cannot access activeTab\" : `Invalid tab ID: ${tabId}`);\n      }\n\n      await tabListener.awaitTabReady(tab.nativeTab);\n      return tab;\n    }\n\n    let self = {\n      tabs: {\n        onActivated: makeGlobalEvent(context, \"tabs.onActivated\", \"Tab:Selected\", (fire, data) => {\n          let tab = tabManager.get(data.id);\n          fire.async({\n            tabId: tab.id,\n            previousTabId: data.previousTabId,\n            windowId: tab.windowId\n          });\n        }),\n        onCreated: new EventManager({\n          context,\n          name: \"tabs.onCreated\",\n          register: fire => {\n            let listener = (eventName, event) => {\n              fire.async(tabManager.convert(event.nativeTab));\n            };\n\n            tabTracker.on(\"tab-created\", listener);\n            return () => {\n              tabTracker.off(\"tab-created\", listener);\n            };\n          }\n        }).api(),\n        onHighlighted: makeGlobalEvent(context, \"tabs.onHighlighted\", \"Tab:Selected\", (fire, data) => {\n          let tab = tabManager.get(data.id);\n          fire.async({\n            tabIds: [tab.id],\n            windowId: tab.windowId\n          });\n        }),\n        onAttached: new EventManager({\n          context,\n          name: \"tabs.onAttached\",\n          register: fire => {\n            return () => {};\n          }\n        }).api(),\n        onDetached: new EventManager({\n          context,\n          name: \"tabs.onDetached\",\n          register: fire => {\n            return () => {};\n          }\n        }).api(),\n        onRemoved: new EventManager({\n          context,\n          name: \"tabs.onRemoved\",\n          register: fire => {\n            let listener = (eventName, event) => {\n              fire.async(event.tabId, {\n                windowId: event.windowId,\n                isWindowClosing: event.isWindowClosing\n              });\n            };\n\n            tabTracker.on(\"tab-removed\", listener);\n            return () => {\n              tabTracker.off(\"tab-removed\", listener);\n            };\n          }\n        }).api(),\n        onReplaced: new EventManager({\n          context,\n          name: \"tabs.onReplaced\",\n          register: fire => {\n            return () => {};\n          }\n        }).api(),\n        onMoved: new EventManager({\n          context,\n          name: \"tabs.onMoved\",\n          register: fire => {\n            return () => {};\n          }\n        }).api(),\n        onUpdated: new EventManager({\n          context,\n          name: \"tabs.onUpdated\",\n          register: fire => {\n            const restricted = [\"url\", \"favIconUrl\", \"title\"];\n\n            function sanitize(extension, changeInfo) {\n              let result = {};\n              let nonempty = false;\n\n              for (let prop in changeInfo) {\n                if (extension.hasPermission(\"tabs\") || !restricted.includes(prop)) {\n                  nonempty = true;\n                  result[prop] = changeInfo[prop];\n                }\n              }\n\n              return [nonempty, result];\n            }\n\n            let fireForTab = (tab, changed) => {\n              let [needed, changeInfo] = sanitize(extension, changed);\n\n              if (needed) {\n                fire.async(tab.id, changeInfo, tab.convert());\n              }\n            };\n\n            let listener = event => {\n              let needed = [];\n              let nativeTab;\n\n              switch (event.type) {\n                case \"DOMTitleChanged\":\n                  {\n                    let {\n                      BrowserApp\n                    } = getBrowserWindow(event.target.ownerGlobal);\n                    nativeTab = BrowserApp.getTabForWindow(event.target.ownerGlobal);\n                    needed.push(\"title\");\n                    break;\n                  }\n\n                case \"DOMAudioPlaybackStarted\":\n                case \"DOMAudioPlaybackStopped\":\n                  {\n                    let {\n                      BrowserApp\n                    } = event.target.ownerGlobal;\n                    nativeTab = BrowserApp.getTabForBrowser(event.originalTarget);\n                    needed.push(\"audible\");\n                    break;\n                  }\n              }\n\n              if (!nativeTab) {\n                return;\n              }\n\n              let tab = tabManager.getWrapper(nativeTab);\n              let changeInfo = {};\n\n              for (let prop of needed) {\n                changeInfo[prop] = tab[prop];\n              }\n\n              fireForTab(tab, changeInfo);\n            };\n\n            let statusListener = ({\n              browser,\n              status,\n              url\n            }) => {\n              let {\n                BrowserApp\n              } = browser.ownerGlobal;\n              let nativeTab = BrowserApp.getTabForBrowser(browser);\n\n              if (nativeTab) {\n                let changed = {\n                  status\n                };\n\n                if (url) {\n                  changed.url = url;\n                }\n\n                fireForTab(tabManager.wrapTab(nativeTab), changed);\n              }\n            };\n\n            windowTracker.addListener(\"status\", statusListener);\n            windowTracker.addListener(\"DOMTitleChanged\", listener);\n            return () => {\n              windowTracker.removeListener(\"status\", statusListener);\n              windowTracker.removeListener(\"DOMTitleChanged\", listener);\n            };\n          }\n        }).api(),\n\n        async create(createProperties) {\n          let principal = context.principal;\n          let window = createProperties.windowId !== null ? windowTracker.getWindow(createProperties.windowId, context) : windowTracker.topWindow;\n          let {\n            BrowserApp\n          } = window;\n          let url;\n\n          if (createProperties.url !== null) {\n            url = context.uri.resolve(createProperties.url);\n\n            if (!context.checkLoadURL(url, {\n              dontReportErrors: true\n            })) {\n              return Promise.reject({\n                message: `Illegal URL: ${url}`\n              });\n            }\n          } else {\n            principal = Services.scriptSecurityManager.getSystemPrincipal();\n          }\n\n          let options = {};\n          let active = true;\n\n          if (createProperties.active !== null) {\n            active = createProperties.active;\n          }\n\n          options.selected = active;\n\n          if (createProperties.index !== null) {\n            options.tabIndex = createProperties.index;\n          }\n\n          if (url && url.startsWith(\"about:\")) {\n            options.disallowInheritPrincipal = true;\n          } else {\n            options.triggeringPrincipal = context.principal;\n          }\n\n          options.parentId = BrowserApp.selectedTab.id;\n          tabListener.initTabReady();\n          options.triggeringPrincipal = principal;\n          let nativeTab;\n\n          if (Services.androidBridge.isFennec) {\n            nativeTab = BrowserApp.addTab(url, options);\n          } else {\n            options.extensionId = context.extension.id;\n            options.url = url;\n            nativeTab = await GeckoViewTabBridge.createNewTab(options);\n          }\n\n          if (createProperties.url) {\n            tabListener.initializingTabs.add(nativeTab);\n          }\n\n          return tabManager.convert(nativeTab);\n        },\n\n        async remove(tabs) {\n          if (!Array.isArray(tabs)) {\n            tabs = [tabs];\n          }\n\n          if (!Services.androidBridge.isFennec) {\n            await Promise.all(tabs.map(async tabId => {\n              const windowId = GeckoViewTabBridge.tabIdToWindowId(tabId);\n              const window = windowTracker.getWindow(windowId, context, false);\n\n              if (!window) {\n                throw new ExtensionError(`Invalid tab ID ${tabId}`);\n              }\n\n              await GeckoViewTabBridge.closeTab({\n                window,\n                extensionId: context.extension.id\n              });\n            }));\n            return;\n          }\n\n          for (let tabId of tabs) {\n            let nativeTab = tabTracker.getTab(tabId);\n            nativeTab.browser.ownerGlobal.BrowserApp.closeTab(nativeTab);\n          }\n        },\n\n        async update(tabId, updateProperties) {\n          let nativeTab = getTabOrActive(tabId);\n          let {\n            BrowserApp\n          } = nativeTab.browser.ownerGlobal;\n\n          if (updateProperties.url !== null) {\n            let url = context.uri.resolve(updateProperties.url);\n\n            if (!context.checkLoadURL(url, {\n              dontReportErrors: true\n            })) {\n              return Promise.reject({\n                message: `Illegal URL: ${url}`\n              });\n            }\n\n            let options = {\n              triggeringPrincipal: context.principal\n            };\n            nativeTab.browser.loadURI(url, options);\n          }\n\n          if (updateProperties.active !== null) {\n            if (updateProperties.active) {\n              BrowserApp.selectTab(nativeTab);\n            } else {}\n          }\n\n          return tabManager.convert(nativeTab);\n        },\n\n        async reload(tabId, reloadProperties) {\n          let nativeTab = getTabOrActive(tabId);\n          let flags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;\n\n          if (reloadProperties && reloadProperties.bypassCache) {\n            flags |= Ci.nsIWebNavigation.LOAD_FLAGS_BYPASS_CACHE;\n          }\n\n          nativeTab.browser.reloadWithFlags(flags);\n        },\n\n        async get(tabId) {\n          return tabManager.get(tabId).convert();\n        },\n\n        async getCurrent() {\n          if (context.tabId) {\n            return tabManager.get(context.tabId).convert();\n          }\n        },\n\n        async query(queryInfo) {\n          if (!extension.hasPermission(\"tabs\")) {\n            if (queryInfo.url !== null || queryInfo.title !== null) {\n              return Promise.reject({\n                message: 'The \"tabs\" permission is required to use the query API with the \"url\" or \"title\" parameters'\n              });\n            }\n          }\n\n          queryInfo = Object.assign({}, queryInfo);\n\n          if (queryInfo.url !== null) {\n            queryInfo.url = new MatchPatternSet([].concat(queryInfo.url), {\n              restrictSchemes: false\n            });\n          }\n\n          if (queryInfo.title !== null) {\n            queryInfo.title = new MatchGlob(queryInfo.title);\n          }\n\n          return Array.from(tabManager.query(queryInfo, context), tab => tab.convert());\n        },\n\n        async captureVisibleTab(windowId, options) {\n          let window = windowId == null ? windowTracker.topWindow : windowTracker.getWindow(windowId, context);\n          let tab = tabManager.wrapTab(window.BrowserApp.selectedTab);\n          await tabListener.awaitTabReady(tab.nativeTab);\n          return tab.capture(context, options);\n        },\n\n        async executeScript(tabId, details) {\n          let tab = await promiseTabWhenReady(tabId);\n          return tab.executeScript(context, details);\n        },\n\n        async insertCSS(tabId, details) {\n          let tab = await promiseTabWhenReady(tabId);\n          return tab.insertCSS(context, details);\n        },\n\n        async removeCSS(tabId, details) {\n          let tab = await promiseTabWhenReady(tabId);\n          return tab.removeCSS(context, details);\n        }\n\n      }\n    };\n    return self;\n  }\n\n}"},{"filepath":"browser/components/extensions/parent/ext-tabs.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.tabs = class extends ExtensionAPI {\n  static onUpdate(id, manifest) {\n    if (!manifest.permissions || !manifest.permissions.includes(\"tabHide\")) {\n      showHiddenTabs(id);\n    }\n  }\n\n  static onDisable(id) {\n    showHiddenTabs(id);\n    tabHidePopup.clearConfirmation(id);\n  }\n\n  static onUninstall(id) {\n    tabHidePopup.clearConfirmation(id);\n  }\n\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    let {\n      tabManager,\n      windowManager\n    } = extension;\n\n    function getTabOrActive(tabId) {\n      let tab = tabId !== null ? tabTracker.getTab(tabId) : tabTracker.activeTab;\n\n      if (!context.canAccessWindow(tab.ownerGlobal)) {\n        throw new ExtensionError(tabId === null ? \"Cannot access activeTab\" : `Invalid tab ID: ${tabId}`);\n      }\n\n      return tab;\n    }\n\n    function getNativeTabsFromIDArray(tabIds) {\n      if (!Array.isArray(tabIds)) {\n        tabIds = [tabIds];\n      }\n\n      return tabIds.map(tabId => {\n        let tab = tabTracker.getTab(tabId);\n\n        if (!context.canAccessWindow(tab.ownerGlobal)) {\n          throw new ExtensionError(`Invalid tab ID: ${tabId}`);\n        }\n\n        return tab;\n      });\n    }\n\n    async function promiseTabWhenReady(tabId) {\n      let tab;\n\n      if (tabId !== null) {\n        tab = tabManager.get(tabId);\n      } else {\n        tab = tabManager.getWrapper(tabTracker.activeTab);\n      }\n\n      if (!tab) {\n        throw new ExtensionError(tabId == null ? \"Cannot access activeTab\" : `Invalid tab ID: ${tabId}`);\n      }\n\n      await tabListener.awaitTabReady(tab.nativeTab);\n      return tab;\n    }\n\n    let self = {\n      tabs: {\n        onActivated: TabEventManager({\n          context,\n          name: \"tabs.onActivated\",\n          event: \"tab-activated\",\n          listener: (fire, event) => {\n            let {\n              tabId,\n              windowId,\n              previousTabId,\n              previousTabIsPrivate\n            } = event;\n\n            if (previousTabIsPrivate && !context.privateBrowsingAllowed) {\n              previousTabId = undefined;\n            }\n\n            fire.async({\n              tabId,\n              previousTabId,\n              windowId\n            });\n          }\n        }),\n        onCreated: TabEventManager({\n          context,\n          name: \"tabs.onCreated\",\n          event: \"tab-created\",\n          listener: (fire, event) => {\n            fire.async(tabManager.convert(event.nativeTab, event.currentTabSize));\n          }\n        }),\n        onHighlighted: TabEventManager({\n          context,\n          name: \"tabs.onHighlighted\",\n          event: \"tabs-highlighted\",\n          listener: (fire, event) => {\n            fire.async({\n              tabIds: event.tabIds,\n              windowId: event.windowId\n            });\n          }\n        }),\n        onAttached: TabEventManager({\n          context,\n          name: \"tabs.onAttached\",\n          event: \"tab-attached\",\n          listener: (fire, event) => {\n            fire.async(event.tabId, {\n              newWindowId: event.newWindowId,\n              newPosition: event.newPosition\n            });\n          }\n        }),\n        onDetached: TabEventManager({\n          context,\n          name: \"tabs.onDetached\",\n          event: \"tab-detached\",\n          listener: (fire, event) => {\n            fire.async(event.tabId, {\n              oldWindowId: event.oldWindowId,\n              oldPosition: event.oldPosition\n            });\n          }\n        }),\n        onRemoved: TabEventManager({\n          context,\n          name: \"tabs.onRemoved\",\n          event: \"tab-removed\",\n          listener: (fire, event) => {\n            fire.async(event.tabId, {\n              windowId: event.windowId,\n              isWindowClosing: event.isWindowClosing\n            });\n          }\n        }),\n        onReplaced: new EventManager({\n          context,\n          name: \"tabs.onReplaced\",\n          register: fire => {\n            return () => {};\n          }\n        }).api(),\n        onMoved: new EventManager({\n          context,\n          name: \"tabs.onMoved\",\n          register: fire => {\n            let moveListener = event => {\n              let nativeTab = event.originalTarget;\n\n              if (context.canAccessWindow(nativeTab.ownerGlobal)) {\n                fire.async(tabTracker.getId(nativeTab), {\n                  windowId: windowTracker.getId(nativeTab.ownerGlobal),\n                  fromIndex: event.detail,\n                  toIndex: nativeTab._tPos\n                });\n              }\n            };\n\n            windowTracker.addListener(\"TabMove\", moveListener);\n            return () => {\n              windowTracker.removeListener(\"TabMove\", moveListener);\n            };\n          }\n        }).api(),\n        onUpdated: new TabsUpdateFilterEventManager(context).api(),\n\n        create(createProperties) {\n          return new Promise((resolve, reject) => {\n            let window = createProperties.windowId !== null ? windowTracker.getWindow(createProperties.windowId, context) : windowTracker.getTopNormalWindow(context);\n\n            if (!window || !context.canAccessWindow(window)) {\n              throw new Error(\"Not allowed to create tabs on the target window\");\n            }\n\n            let {\n              gBrowserInit\n            } = window;\n\n            if (!gBrowserInit || !gBrowserInit.delayedStartupFinished) {\n              let obs = (finishedWindow, topic, data) => {\n                if (finishedWindow != window) {\n                  return;\n                }\n\n                Services.obs.removeObserver(obs, \"browser-delayed-startup-finished\");\n                resolve(window);\n              };\n\n              Services.obs.addObserver(obs, \"browser-delayed-startup-finished\");\n            } else {\n              resolve(window);\n            }\n          }).then(window => {\n            let url;\n            let principal = context.principal;\n            let options = {};\n\n            if (createProperties.cookieStoreId) {\n              options.userContextId = getUserContextIdForCookieStoreId(extension, createProperties.cookieStoreId, PrivateBrowsingUtils.isBrowserPrivate(window.gBrowser));\n            }\n\n            if (createProperties.url !== null) {\n              url = context.uri.resolve(createProperties.url);\n\n              if (!context.checkLoadURL(url, {\n                dontReportErrors: true\n              })) {\n                return Promise.reject({\n                  message: `Illegal URL: ${url}`\n                });\n              }\n\n              if (createProperties.openInReaderMode) {\n                url = `about:reader?url=${encodeURIComponent(url)}`;\n              }\n            } else {\n              url = window.BROWSER_NEW_TAB_URL;\n            }\n\n            let discardable = url && !url.startsWith(\"about:\");\n\n            if (!discardable) {\n              options.allowInheritPrincipal = false;\n              principal = Services.scriptSecurityManager.createContentPrincipal(Services.io.newURI(url), {\n                userContextId: options.userContextId,\n                privateBrowsingId: PrivateBrowsingUtils.isBrowserPrivate(window.gBrowser) ? 1 : 0\n              });\n            } else {\n              options.allowInheritPrincipal = true;\n              options.triggeringPrincipal = context.principal;\n            }\n\n            tabListener.initTabReady();\n            const currentTab = window.gBrowser.selectedTab;\n            const {\n              frameLoader\n            } = currentTab.linkedBrowser;\n            const currentTabSize = {\n              width: frameLoader.lazyWidth,\n              height: frameLoader.lazyHeight\n            };\n\n            if (createProperties.openerTabId !== null) {\n              options.ownerTab = tabTracker.getTab(createProperties.openerTabId);\n              options.openerBrowser = options.ownerTab.linkedBrowser;\n\n              if (options.ownerTab.ownerGlobal !== window) {\n                return Promise.reject({\n                  message: \"Opener tab must be in the same window as the tab being created\"\n                });\n              }\n            }\n\n            const properties = [\"index\", \"pinned\"];\n\n            for (let prop of properties) {\n              if (createProperties[prop] != null) {\n                options[prop] = createProperties[prop];\n              }\n            }\n\n            let active = createProperties.active !== null ? createProperties.active : !createProperties.discarded;\n\n            if (createProperties.discarded) {\n              if (active) {\n                return Promise.reject({\n                  message: `Active tabs cannot be created and discarded.`\n                });\n              }\n\n              if (createProperties.pinned) {\n                return Promise.reject({\n                  message: `Pinned tabs cannot be created and discarded.`\n                });\n              }\n\n              if (!discardable) {\n                return Promise.reject({\n                  message: `Cannot create a discarded new tab or \"about\" urls.`\n                });\n              }\n\n              options.createLazyBrowser = true;\n              options.lazyTabTitle = createProperties.title;\n            } else if (createProperties.title) {\n              return Promise.reject({\n                message: `Title may only be set for discarded tabs.`\n              });\n            }\n\n            options.triggeringPrincipal = principal;\n            let nativeTab = window.gBrowser.addTab(url, options);\n\n            if (active) {\n              window.gBrowser.selectedTab = nativeTab;\n\n              if (!createProperties.url) {\n                window.focusAndSelectUrlBar();\n              }\n            }\n\n            if (createProperties.url && createProperties.url !== window.BROWSER_NEW_TAB_URL) {\n              tabListener.initializingTabs.add(nativeTab);\n            }\n\n            return tabManager.convert(nativeTab, currentTabSize);\n          });\n        },\n\n        async remove(tabIds) {\n          for (let nativeTab of getNativeTabsFromIDArray(tabIds)) {\n            nativeTab.ownerGlobal.gBrowser.removeTab(nativeTab);\n          }\n        },\n\n        async discard(tabIds) {\n          for (let nativeTab of getNativeTabsFromIDArray(tabIds)) {\n            nativeTab.ownerGlobal.gBrowser.discardBrowser(nativeTab);\n          }\n        },\n\n        async update(tabId, updateProperties) {\n          let nativeTab = getTabOrActive(tabId);\n          let tabbrowser = nativeTab.ownerGlobal.gBrowser;\n\n          if (updateProperties.url !== null) {\n            let url = context.uri.resolve(updateProperties.url);\n\n            if (!context.checkLoadURL(url, {\n              dontReportErrors: true\n            })) {\n              return Promise.reject({\n                message: `Illegal URL: ${url}`\n              });\n            }\n\n            let options = {\n              flags: updateProperties.loadReplace ? Ci.nsIWebNavigation.LOAD_FLAGS_REPLACE_HISTORY : Ci.nsIWebNavigation.LOAD_FLAGS_NONE,\n              triggeringPrincipal: context.principal\n            };\n            nativeTab.linkedBrowser.loadURI(url, options);\n          }\n\n          if (updateProperties.active !== null) {\n            if (updateProperties.active) {\n              tabbrowser.selectedTab = nativeTab;\n            } else {}\n          }\n\n          if (updateProperties.highlighted !== null) {\n            if (!gMultiSelectEnabled) {\n              throw new ExtensionError(`updateProperties.highlight is currently experimental and must be enabled with the ${MULTISELECT_PREFNAME} preference.`);\n            }\n\n            if (updateProperties.highlighted) {\n              if (!nativeTab.selected && !nativeTab.multiselected) {\n                tabbrowser.addToMultiSelectedTabs(nativeTab, {\n                  isLastMultiSelectChange: true\n                });\n\n                if (updateProperties.active !== false) {\n                  tabbrowser.lockClearMultiSelectionOnce();\n                  tabbrowser.selectedTab = nativeTab;\n                }\n              }\n            } else {\n              tabbrowser.removeFromMultiSelectedTabs(nativeTab, {\n                isLastMultiSelectChange: true\n              });\n            }\n          }\n\n          if (updateProperties.muted !== null) {\n            if (nativeTab.muted != updateProperties.muted) {\n              nativeTab.toggleMuteAudio(extension.id);\n            }\n          }\n\n          if (updateProperties.pinned !== null) {\n            if (updateProperties.pinned) {\n              tabbrowser.pinTab(nativeTab);\n            } else {\n              tabbrowser.unpinTab(nativeTab);\n            }\n          }\n\n          if (updateProperties.openerTabId !== null) {\n            let opener = tabTracker.getTab(updateProperties.openerTabId);\n\n            if (opener.ownerDocument !== nativeTab.ownerDocument) {\n              return Promise.reject({\n                message: \"Opener tab must be in the same window as the tab being updated\"\n              });\n            }\n\n            tabTracker.setOpener(nativeTab, opener);\n          }\n\n          if (updateProperties.successorTabId !== null) {\n            let successor = null;\n\n            if (updateProperties.successorTabId !== TAB_ID_NONE) {\n              successor = tabTracker.getTab(updateProperties.successorTabId, null);\n\n              if (!successor) {\n                throw new ExtensionError(\"Invalid successorTabId\");\n              }\n\n              if (successor.ownerDocument !== nativeTab.ownerDocument) {\n                throw new ExtensionError(\"Successor tab must be in the same window as the tab being updated\");\n              }\n            }\n\n            tabbrowser.setSuccessor(nativeTab, successor);\n          }\n\n          return tabManager.convert(nativeTab);\n        },\n\n        async reload(tabId, reloadProperties) {\n          let nativeTab = getTabOrActive(tabId);\n          let flags = Ci.nsIWebNavigation.LOAD_FLAGS_NONE;\n\n          if (reloadProperties && reloadProperties.bypassCache) {\n            flags |= Ci.nsIWebNavigation.LOAD_FLAGS_BYPASS_CACHE;\n          }\n\n          nativeTab.linkedBrowser.reloadWithFlags(flags);\n        },\n\n        async get(tabId) {\n          return tabManager.get(tabId).convert();\n        },\n\n        getCurrent() {\n          let tabData;\n\n          if (context.tabId) {\n            tabData = tabManager.get(context.tabId).convert();\n          }\n\n          return Promise.resolve(tabData);\n        },\n\n        async query(queryInfo) {\n          if (!extension.hasPermission(\"tabs\")) {\n            if (queryInfo.url !== null || queryInfo.title !== null) {\n              return Promise.reject({\n                message: 'The \"tabs\" permission is required to use the query API with the \"url\" or \"title\" parameters'\n              });\n            }\n          }\n\n          queryInfo = Object.assign({}, queryInfo);\n\n          if (queryInfo.url !== null) {\n            queryInfo.url = new MatchPatternSet([].concat(queryInfo.url), {\n              restrictSchemes: false\n            });\n          }\n\n          if (queryInfo.title !== null) {\n            queryInfo.title = new MatchGlob(queryInfo.title);\n          }\n\n          return Array.from(tabManager.query(queryInfo, context), tab => tab.convert());\n        },\n\n        async captureTab(tabId, options) {\n          let nativeTab = getTabOrActive(tabId);\n          await tabListener.awaitTabReady(nativeTab);\n          let tab = tabManager.wrapTab(nativeTab);\n          return tab.capture(context, options);\n        },\n\n        async captureVisibleTab(windowId, options) {\n          let window = windowId == null ? windowTracker.getTopWindow(context) : windowTracker.getWindow(windowId, context);\n          let tab = tabManager.wrapTab(window.gBrowser.selectedTab);\n          await tabListener.awaitTabReady(tab.nativeTab);\n          return tab.capture(context, options);\n        },\n\n        async detectLanguage(tabId) {\n          let tab = await promiseTabWhenReady(tabId);\n          return tab.sendMessage(context, \"Extension:DetectLanguage\");\n        },\n\n        async executeScript(tabId, details) {\n          let tab = await promiseTabWhenReady(tabId);\n          return tab.executeScript(context, details);\n        },\n\n        async insertCSS(tabId, details) {\n          let tab = await promiseTabWhenReady(tabId);\n          return tab.insertCSS(context, details);\n        },\n\n        async removeCSS(tabId, details) {\n          let tab = await promiseTabWhenReady(tabId);\n          return tab.removeCSS(context, details);\n        },\n\n        async move(tabIds, moveProperties) {\n          let tabsMoved = [];\n\n          if (!Array.isArray(tabIds)) {\n            tabIds = [tabIds];\n          }\n\n          let destinationWindow = null;\n\n          if (moveProperties.windowId !== null) {\n            destinationWindow = windowTracker.getWindow(moveProperties.windowId, context);\n\n            if (!destinationWindow) {\n              return Promise.reject({\n                message: `Invalid window ID: ${moveProperties.windowId}`\n              });\n            }\n          }\n\n          let indexMap = new Map();\n          let lastInsertion = new Map();\n\n          for (let nativeTab of getNativeTabsFromIDArray(tabIds)) {\n            let window = destinationWindow || nativeTab.ownerGlobal;\n            let gBrowser = window.gBrowser;\n\n            if (nativeTab.ownerGlobal == window && gBrowser.tabs.length === 1) {\n              continue;\n            }\n\n            if (nativeTab.ownerGlobal != window && PrivateBrowsingUtils.isBrowserPrivate(window.gBrowser) != PrivateBrowsingUtils.isBrowserPrivate(nativeTab.ownerGlobal.gBrowser)) {\n              continue;\n            }\n\n            let insertionPoint = indexMap.get(window) || moveProperties.index;\n\n            if (insertionPoint == -1) {\n              insertionPoint = gBrowser.tabs.length;\n            }\n\n            let numPinned = gBrowser._numPinnedTabs;\n            let ok = nativeTab.pinned ? insertionPoint <= numPinned : insertionPoint >= numPinned;\n\n            if (!ok) {\n              continue;\n            }\n\n            if (lastInsertion.has(window) && lastInsertion.get(window) === insertionPoint && nativeTab._tPos > insertionPoint) {\n              insertionPoint++;\n              indexMap.set(window, insertionPoint);\n            }\n\n            if (nativeTab.ownerGlobal != window) {\n              nativeTab = gBrowser.adoptTab(nativeTab, insertionPoint, false);\n            } else {\n              gBrowser.moveTabTo(nativeTab, insertionPoint);\n            }\n\n            lastInsertion.set(window, nativeTab._tPos);\n            tabsMoved.push(nativeTab);\n          }\n\n          return tabsMoved.map(nativeTab => tabManager.convert(nativeTab));\n        },\n\n        duplicate(tabId) {\n          let nativeTab = getTabOrActive(tabId);\n          let gBrowser = nativeTab.ownerGlobal.gBrowser;\n          let newTab = gBrowser.duplicateTab(nativeTab);\n          tabListener.blockTabUntilRestored(newTab);\n          return new Promise(resolve => {\n            newTab.addEventListener(\"SSTabRestoring\", function () {\n              if (nativeTab.pinned) {\n                gBrowser.pinTab(newTab);\n              }\n\n              gBrowser.moveTabTo(newTab, nativeTab._tPos + 1);\n              gBrowser.selectedTab = newTab;\n              resolve(tabManager.convert(newTab));\n            }, {\n              once: true\n            });\n          });\n        },\n\n        getZoom(tabId) {\n          let nativeTab = getTabOrActive(tabId);\n          let {\n            ZoomManager\n          } = nativeTab.ownerGlobal;\n          let zoom = ZoomManager.getZoomForBrowser(nativeTab.linkedBrowser);\n          return Promise.resolve(zoom);\n        },\n\n        setZoom(tabId, zoom) {\n          let nativeTab = getTabOrActive(tabId);\n          let {\n            FullZoom,\n            ZoomManager\n          } = nativeTab.ownerGlobal;\n\n          if (zoom === 0) {\n            return FullZoom.reset(nativeTab.linkedBrowser);\n          } else if (zoom >= ZoomManager.MIN && zoom <= ZoomManager.MAX) {\n            FullZoom.setZoom(zoom, nativeTab.linkedBrowser);\n          } else {\n            return Promise.reject({\n              message: `Zoom value ${zoom} out of range (must be between ${ZoomManager.MIN} and ${ZoomManager.MAX})`\n            });\n          }\n\n          return Promise.resolve();\n        },\n\n        _getZoomSettings(tabId) {\n          let nativeTab = getTabOrActive(tabId);\n          let {\n            FullZoom\n          } = nativeTab.ownerGlobal;\n          return {\n            mode: \"automatic\",\n            scope: FullZoom.siteSpecific ? \"per-origin\" : \"per-tab\",\n            defaultZoomFactor: 1\n          };\n        },\n\n        getZoomSettings(tabId) {\n          return Promise.resolve(this._getZoomSettings(tabId));\n        },\n\n        setZoomSettings(tabId, settings) {\n          let nativeTab = getTabOrActive(tabId);\n\n          let currentSettings = this._getZoomSettings(tabTracker.getId(nativeTab));\n\n          if (!Object.keys(settings).every(key => settings[key] === currentSettings[key])) {\n            return Promise.reject(`Unsupported zoom settings: ${JSON.stringify(settings)}`);\n          }\n\n          return Promise.resolve();\n        },\n\n        onZoomChange: new EventManager({\n          context,\n          name: \"tabs.onZoomChange\",\n          register: fire => {\n            let getZoomLevel = browser => {\n              let {\n                ZoomManager\n              } = browser.ownerGlobal;\n              return ZoomManager.getZoomForBrowser(browser);\n            };\n\n            let zoomLevels = new WeakMap();\n\n            for (let window of windowTracker.browserWindows()) {\n              if (!context.canAccessWindow(window)) {\n                continue;\n              }\n\n              for (let nativeTab of window.gBrowser.tabs) {\n                let browser = nativeTab.linkedBrowser;\n                zoomLevels.set(browser, getZoomLevel(browser));\n              }\n            }\n\n            let tabCreated = (eventName, event) => {\n              let browser = event.nativeTab.linkedBrowser;\n\n              if (!event.isPrivate || context.privateBrowsingAllowed) {\n                zoomLevels.set(browser, getZoomLevel(browser));\n              }\n            };\n\n            let zoomListener = event => {\n              let browser = event.originalTarget;\n\n              if (browser.nodeType == browser.DOCUMENT_NODE) {\n                browser = browser.docShell.chromeEventHandler;\n              }\n\n              if (!context.canAccessWindow(browser.ownerGlobal)) {\n                return;\n              }\n\n              let {\n                gBrowser\n              } = browser.ownerGlobal;\n              let nativeTab = gBrowser.getTabForBrowser(browser);\n\n              if (!nativeTab) {\n                return;\n              }\n\n              let oldZoomFactor = zoomLevels.get(browser);\n              let newZoomFactor = getZoomLevel(browser);\n\n              if (oldZoomFactor != newZoomFactor) {\n                zoomLevels.set(browser, newZoomFactor);\n                let tabId = tabTracker.getId(nativeTab);\n                fire.async({\n                  tabId,\n                  oldZoomFactor,\n                  newZoomFactor,\n                  zoomSettings: self.tabs._getZoomSettings(tabId)\n                });\n              }\n            };\n\n            tabTracker.on(\"tab-attached\", tabCreated);\n            tabTracker.on(\"tab-created\", tabCreated);\n            windowTracker.addListener(\"FullZoomChange\", zoomListener);\n            windowTracker.addListener(\"TextZoomChange\", zoomListener);\n            return () => {\n              tabTracker.off(\"tab-attached\", tabCreated);\n              tabTracker.off(\"tab-created\", tabCreated);\n              windowTracker.removeListener(\"FullZoomChange\", zoomListener);\n              windowTracker.removeListener(\"TextZoomChange\", zoomListener);\n            };\n          }\n        }).api(),\n\n        print() {\n          let activeTab = getTabOrActive(null);\n          let {\n            PrintUtils\n          } = activeTab.ownerGlobal;\n          PrintUtils.printWindow(activeTab.linkedBrowser.outerWindowID, activeTab.linkedBrowser);\n        },\n\n        printPreview() {\n          let activeTab = getTabOrActive(null);\n          let {\n            PrintUtils,\n            PrintPreviewListener\n          } = activeTab.ownerGlobal;\n          return new Promise((resolve, reject) => {\n            let ppBrowser = PrintUtils.shouldSimplify ? PrintPreviewListener.getSimplifiedPrintPreviewBrowser() : PrintPreviewListener.getPrintPreviewBrowser();\n            let mm = ppBrowser.messageManager;\n\n            let onEntered = message => {\n              mm.removeMessageListener(\"Printing:Preview:Entered\", onEntered);\n\n              if (message.data.failed) {\n                reject({\n                  message: \"Print preview failed\"\n                });\n              }\n\n              resolve();\n            };\n\n            mm.addMessageListener(\"Printing:Preview:Entered\", onEntered);\n            PrintUtils.printPreview(PrintPreviewListener);\n          });\n        },\n\n        saveAsPDF(pageSettings) {\n          let activeTab = getTabOrActive(null);\n          let picker = Cc[\"@mozilla.org/filepicker;1\"].createInstance(Ci.nsIFilePicker);\n          let title = strBundle.GetStringFromName(\"saveaspdf.saveasdialog.title\");\n\n          if (AppConstants.platform === \"macosx\") {\n            return Promise.reject({\n              message: \"Not supported on Mac OS X\"\n            });\n          }\n\n          picker.init(activeTab.ownerGlobal, title, Ci.nsIFilePicker.modeSave);\n          picker.appendFilter(\"PDF\", \"*.pdf\");\n          picker.defaultExtension = \"pdf\";\n          picker.defaultString = activeTab.linkedBrowser.contentTitle + \".pdf\";\n          return new Promise(resolve => {\n            picker.open(function (retval) {\n              if (retval == 0 || retval == 2) {\n                try {\n                  let fstream = Cc[\"@mozilla.org/network/file-output-stream;1\"].createInstance(Ci.nsIFileOutputStream);\n                  fstream.init(picker.file, 0x2a, 0o666, 0);\n                  fstream.close();\n                } catch (e) {\n                  resolve(retval == 0 ? \"not_saved\" : \"not_replaced\");\n                  return;\n                }\n\n                let psService = Cc[\"@mozilla.org/gfx/printsettings-service;1\"].getService(Ci.nsIPrintSettingsService);\n                let printSettings = psService.newPrintSettings;\n                printSettings.printerName = \"\";\n                printSettings.isInitializedFromPrinter = true;\n                printSettings.isInitializedFromPrefs = true;\n                printSettings.printToFile = true;\n                printSettings.toFileName = picker.file.path;\n                printSettings.printSilent = true;\n                printSettings.showPrintProgress = false;\n                printSettings.outputFormat = Ci.nsIPrintSettings.kOutputFormatPDF;\n\n                if (pageSettings.paperSizeUnit !== null) {\n                  printSettings.paperSizeUnit = pageSettings.paperSizeUnit;\n                }\n\n                if (pageSettings.paperWidth !== null) {\n                  printSettings.paperWidth = pageSettings.paperWidth;\n                }\n\n                if (pageSettings.paperHeight !== null) {\n                  printSettings.paperHeight = pageSettings.paperHeight;\n                }\n\n                if (pageSettings.orientation !== null) {\n                  printSettings.orientation = pageSettings.orientation;\n                }\n\n                if (pageSettings.scaling !== null) {\n                  printSettings.scaling = pageSettings.scaling;\n                }\n\n                if (pageSettings.shrinkToFit !== null) {\n                  printSettings.shrinkToFit = pageSettings.shrinkToFit;\n                }\n\n                if (pageSettings.showBackgroundColors !== null) {\n                  printSettings.printBGColors = pageSettings.showBackgroundColors;\n                }\n\n                if (pageSettings.showBackgroundImages !== null) {\n                  printSettings.printBGImages = pageSettings.showBackgroundImages;\n                }\n\n                if (pageSettings.edgeLeft !== null) {\n                  printSettings.edgeLeft = pageSettings.edgeLeft;\n                }\n\n                if (pageSettings.edgeRight !== null) {\n                  printSettings.edgeRight = pageSettings.edgeRight;\n                }\n\n                if (pageSettings.edgeTop !== null) {\n                  printSettings.edgeTop = pageSettings.edgeTop;\n                }\n\n                if (pageSettings.edgeBottom !== null) {\n                  printSettings.edgeBottom = pageSettings.edgeBottom;\n                }\n\n                if (pageSettings.marginLeft !== null) {\n                  printSettings.marginLeft = pageSettings.marginLeft;\n                }\n\n                if (pageSettings.marginRight !== null) {\n                  printSettings.marginRight = pageSettings.marginRight;\n                }\n\n                if (pageSettings.marginTop !== null) {\n                  printSettings.marginTop = pageSettings.marginTop;\n                }\n\n                if (pageSettings.marginBottom !== null) {\n                  printSettings.marginBottom = pageSettings.marginBottom;\n                }\n\n                if (pageSettings.headerLeft !== null) {\n                  printSettings.headerStrLeft = pageSettings.headerLeft;\n                }\n\n                if (pageSettings.headerCenter !== null) {\n                  printSettings.headerStrCenter = pageSettings.headerCenter;\n                }\n\n                if (pageSettings.headerRight !== null) {\n                  printSettings.headerStrRight = pageSettings.headerRight;\n                }\n\n                if (pageSettings.footerLeft !== null) {\n                  printSettings.footerStrLeft = pageSettings.footerLeft;\n                }\n\n                if (pageSettings.footerCenter !== null) {\n                  printSettings.footerStrCenter = pageSettings.footerCenter;\n                }\n\n                if (pageSettings.footerRight !== null) {\n                  printSettings.footerStrRight = pageSettings.footerRight;\n                }\n\n                let printProgressListener = {\n                  onLocationChange(webProgress, request, location, flags) {},\n\n                  onProgressChange(webProgress, request, curSelfProgress, maxSelfProgress, curTotalProgress, maxTotalProgress) {},\n\n                  onSecurityChange(webProgress, request, state) {},\n\n                  onContentBlockingEvent(webProgress, request, event) {},\n\n                  onStateChange(webProgress, request, flags, status) {\n                    if (flags & Ci.nsIWebProgressListener.STATE_STOP && flags & Ci.nsIWebProgressListener.STATE_IS_DOCUMENT) {\n                      resolve(retval == 0 ? \"saved\" : \"replaced\");\n                    }\n                  },\n\n                  onStatusChange: function (webProgress, request, status, message) {\n                    if (status != 0) {\n                      resolve(retval == 0 ? \"not_saved\" : \"not_replaced\");\n                    }\n                  },\n                  QueryInterface: ChromeUtils.generateQI([Ci.nsIWebProgressListener])\n                };\n                activeTab.linkedBrowser.print(activeTab.linkedBrowser.outerWindowID, printSettings, printProgressListener);\n              } else {\n                resolve(\"canceled\");\n              }\n            });\n          });\n        },\n\n        async toggleReaderMode(tabId) {\n          let tab = await promiseTabWhenReady(tabId);\n\n          if (!tab.isInReaderMode && !tab.isArticle) {\n            throw new ExtensionError(\"The specified tab cannot be placed into reader mode.\");\n          }\n\n          let nativeTab = getTabOrActive(tabId);\n          nativeTab.linkedBrowser.messageManager.sendAsyncMessage(\"Reader:ToggleReaderMode\");\n        },\n\n        moveInSuccession(tabIds, tabId, options) {\n          const {\n            insert,\n            append\n          } = options || {};\n          const tabIdSet = new Set(tabIds);\n\n          if (tabIdSet.size !== tabIds.length) {\n            throw new ExtensionError(\"IDs must not occur more than once in tabIds\");\n          }\n\n          if ((append || insert) && tabIdSet.has(tabId)) {\n            throw new ExtensionError(\"Value of tabId must not occur in tabIds if append or insert is true\");\n          }\n\n          const referenceTab = tabTracker.getTab(tabId, null);\n          let referenceWindow = referenceTab && referenceTab.ownerGlobal;\n\n          if (referenceWindow && !context.canAccessWindow(referenceWindow)) {\n            throw new ExtensionError(`Invalid tab ID: ${tabId}`);\n          }\n\n          let previousTab, lastSuccessor;\n\n          if (append) {\n            previousTab = referenceTab;\n            lastSuccessor = insert && referenceTab && referenceTab.successor || null;\n          } else {\n            lastSuccessor = referenceTab;\n          }\n\n          let firstTab;\n\n          for (const tabId of tabIds) {\n            const tab = tabTracker.getTab(tabId, null);\n\n            if (tab === null) {\n              continue;\n            }\n\n            if (!context.canAccessWindow(tab.ownerGlobal)) {\n              throw new ExtensionError(`Invalid tab ID: ${tabId}`);\n            }\n\n            if (referenceWindow === null) {\n              referenceWindow = tab.ownerGlobal;\n            } else if (tab.ownerGlobal !== referenceWindow) {\n              continue;\n            }\n\n            referenceWindow.gBrowser.replaceInSuccession(tab, tab.successor);\n\n            if (append && tab === lastSuccessor) {\n              lastSuccessor = tab.successor;\n            }\n\n            if (previousTab) {\n              referenceWindow.gBrowser.setSuccessor(previousTab, tab);\n            } else {\n              firstTab = tab;\n            }\n\n            previousTab = tab;\n          }\n\n          if (previousTab) {\n            if (!append && insert && lastSuccessor !== null) {\n              referenceWindow.gBrowser.replaceInSuccession(lastSuccessor, firstTab);\n            }\n\n            referenceWindow.gBrowser.setSuccessor(previousTab, lastSuccessor);\n          }\n        },\n\n        show(tabIds) {\n          if (!Services.prefs.getBoolPref(TABHIDE_PREFNAME, false)) {\n            throw new ExtensionError(`tabs.show is currently experimental and must be enabled with the ${TABHIDE_PREFNAME} preference.`);\n          }\n\n          for (let tab of getNativeTabsFromIDArray(tabIds)) {\n            if (tab.ownerGlobal) {\n              tab.ownerGlobal.gBrowser.showTab(tab);\n            }\n          }\n        },\n\n        hide(tabIds) {\n          if (!Services.prefs.getBoolPref(TABHIDE_PREFNAME, false)) {\n            throw new ExtensionError(`tabs.hide is currently experimental and must be enabled with the ${TABHIDE_PREFNAME} preference.`);\n          }\n\n          let hidden = [];\n\n          for (let tab of getNativeTabsFromIDArray(tabIds)) {\n            if (tab.ownerGlobal && !tab.hidden) {\n              tab.ownerGlobal.gBrowser.hideTab(tab, extension.id);\n\n              if (tab.hidden) {\n                hidden.push(tabTracker.getId(tab));\n              }\n            }\n          }\n\n          if (hidden.length) {\n            let win = Services.wm.getMostRecentWindow(\"navigator:browser\");\n            tabHidePopup.open(win, extension.id);\n          }\n\n          return hidden;\n        },\n\n        highlight(highlightInfo) {\n          if (!gMultiSelectEnabled) {\n            throw new ExtensionError(`tabs.highlight is currently experimental and must be enabled with the ${MULTISELECT_PREFNAME} preference.`);\n          }\n\n          let {\n            windowId,\n            tabs,\n            populate\n          } = highlightInfo;\n\n          if (windowId == null) {\n            windowId = Window.WINDOW_ID_CURRENT;\n          }\n\n          let window = windowTracker.getWindow(windowId, context);\n\n          if (!context.canAccessWindow(window)) {\n            throw new ExtensionError(`Invalid window ID: ${windowId}`);\n          }\n\n          if (!Array.isArray(tabs)) {\n            tabs = [tabs];\n          } else if (!tabs.length) {\n            throw new ExtensionError(\"No highlighted tab.\");\n          }\n\n          window.gBrowser.selectedTabs = tabs.map(tabIndex => {\n            let tab = window.gBrowser.tabs[tabIndex];\n\n            if (!tab) {\n              throw new ExtensionError(\"No tab at index: \" + tabIndex);\n            }\n\n            return tab;\n          });\n          return windowManager.convert(window, {\n            populate\n          });\n        }\n\n      }\n    };\n    return self;\n  }\n\n}"}],"getSender":[{"filepath":"mobile/android/components/extensions/ext-android.js","kind":"const","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"const getSender = (extension, target, sender) => {\n  let tabId = -1;\n\n  if (\"tabId\" in sender) {\n    tabId = sender.tabId;\n    delete sender.tabId;\n  } else if (ChromeUtils.getClassName(target) == \"XULFrameElement\") {\n    tabId = tabTracker.getBrowserData(target).tabId;\n  }\n\n  if (tabId != null && tabId >= 0) {\n    let tab = extension.tabManager.get(tabId, null);\n\n    if (tab) {\n      sender.tab = tab.convert();\n    }\n  }\n};"},{"filepath":"browser/components/extensions/parent/ext-browser.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const getSender = (extension, target, sender) => {\n  let tabId;\n\n  if (\"tabId\" in sender) {\n    tabId = sender.tabId;\n    delete sender.tabId;\n  } else if (ExtensionCommon.instanceOf(target, \"XULFrameElement\") || ExtensionCommon.instanceOf(target, \"HTMLIFrameElement\")) {\n    tabId = tabTracker.getBrowserData(target).tabId;\n  }\n\n  if (tabId) {\n    let tab = extension.tabManager.get(tabId, null);\n\n    if (tab) {\n      sender.tab = tab.convert();\n    }\n  }\n};"}],"clearCache":[{"filepath":"mobile/android/components/extensions/ext-browsingData.js","kind":"const","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"const clearCache = () => {\n  return Sanitizer.clearItem(\"cache\");\n};"},{"filepath":"browser/components/extensions/parent/ext-browsingData.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const clearCache = () => {\n  return Sanitizer.items.cache.clear();\n};"}],"clearCookies":[{"filepath":"mobile/android/components/extensions/ext-browsingData.js","kind":"const","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"const clearCookies = async function (options) {\n  let cookieMgr = Services.cookies;\n  let yieldCounter = 0;\n  const YIELD_PERIOD = 10;\n\n  if (options.since) {\n    let since = options.since * 1000;\n\n    for (let cookie of cookieMgr.enumerator) {\n      if (cookie.creationTime >= since) {\n        cookieMgr.remove(cookie.host, cookie.name, cookie.path, cookie.originAttributes);\n\n        if (++yieldCounter % YIELD_PERIOD == 0) {\n          await new Promise(resolve => setTimeout(resolve, 0));\n        }\n      }\n    }\n  } else {\n    cookieMgr.removeAll();\n  }\n};"},{"filepath":"browser/components/extensions/parent/ext-browsingData.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const clearCookies = async function (options) {\n  let cookieMgr = Services.cookies;\n  let yieldCounter = 0;\n\n  if (options.since || options.hostnames) {\n    for (const cookie of cookieMgr.enumerator) {\n      if ((!options.since || cookie.creationTime >= PlacesUtils.toPRTime(options.since)) && (!options.hostnames || options.hostnames.includes(cookie.host.replace(/^\\./, \"\")))) {\n        cookieMgr.remove(cookie.host, cookie.name, cookie.path, cookie.originAttributes);\n\n        if (++yieldCounter % YIELD_PERIOD == 0) {\n          await new Promise(resolve => setTimeout(resolve, 0));\n        }\n      }\n    }\n  } else {\n    cookieMgr.removeAll();\n  }\n};"}],"clearDownloads":[{"filepath":"mobile/android/components/extensions/ext-browsingData.js","kind":"const","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"const clearDownloads = options => {\n  return Sanitizer.clearItem(\"downloadHistory\", options.since);\n};"},{"filepath":"browser/components/extensions/parent/ext-browsingData.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const clearDownloads = options => {\n  return Sanitizer.items.downloads.clear(makeRange(options));\n};"}],"clearFormData":[{"filepath":"mobile/android/components/extensions/ext-browsingData.js","kind":"const","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"const clearFormData = options => {\n  return Sanitizer.clearItem(\"formdata\", options.since);\n};"},{"filepath":"browser/components/extensions/parent/ext-browsingData.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const clearFormData = options => {\n  return Sanitizer.items.formdata.clear(makeRange(options));\n};"}],"doRemoval":[{"filepath":"mobile/android/components/extensions/ext-browsingData.js","kind":"const","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"const doRemoval = (options, dataToRemove, extension) => {\n  if (options.originTypes && (options.originTypes.protectedWeb || options.originTypes.extension)) {\n    return Promise.reject({\n      message: \"Firefox does not support protectedWeb or extension as originTypes.\"\n    });\n  }\n\n  let removalPromises = [];\n  let invalidDataTypes = [];\n\n  for (let dataType in dataToRemove) {\n    if (dataToRemove[dataType]) {\n      switch (dataType) {\n        case \"cache\":\n          removalPromises.push(clearCache());\n          break;\n\n        case \"cookies\":\n          removalPromises.push(clearCookies(options));\n          break;\n\n        case \"downloads\":\n          removalPromises.push(clearDownloads(options));\n          break;\n\n        case \"formData\":\n          removalPromises.push(clearFormData(options));\n          break;\n\n        default:\n          invalidDataTypes.push(dataType);\n      }\n    }\n  }\n\n  if (extension && invalidDataTypes.length) {\n    extension.logger.warn(`Firefox does not support dataTypes: ${invalidDataTypes.toString()}.`);\n  }\n\n  return Promise.all(removalPromises);\n};"},{"filepath":"browser/components/extensions/parent/ext-browsingData.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const doRemoval = (options, dataToRemove, extension) => {\n  if (options.originTypes && (options.originTypes.protectedWeb || options.originTypes.extension)) {\n    return Promise.reject({\n      message: \"Firefox does not support protectedWeb or extension as originTypes.\"\n    });\n  }\n\n  let removalPromises = [];\n  let invalidDataTypes = [];\n\n  for (let dataType in dataToRemove) {\n    if (dataToRemove[dataType]) {\n      switch (dataType) {\n        case \"cache\":\n          removalPromises.push(clearCache());\n          break;\n\n        case \"cookies\":\n          removalPromises.push(clearCookies(options));\n          break;\n\n        case \"downloads\":\n          removalPromises.push(clearDownloads(options));\n          break;\n\n        case \"formData\":\n          removalPromises.push(clearFormData(options));\n          break;\n\n        case \"history\":\n          removalPromises.push(clearHistory(options));\n          break;\n\n        case \"indexedDB\":\n          removalPromises.push(clearIndexedDB(options));\n          break;\n\n        case \"localStorage\":\n          removalPromises.push(clearLocalStorage(options));\n          break;\n\n        case \"passwords\":\n          removalPromises.push(clearPasswords(options));\n          break;\n\n        case \"pluginData\":\n          removalPromises.push(clearPluginData(options));\n          break;\n\n        case \"serviceWorkers\":\n          removalPromises.push(ServiceWorkerCleanUp.removeAll());\n          break;\n\n        default:\n          invalidDataTypes.push(dataType);\n      }\n    }\n  }\n\n  if (extension && invalidDataTypes.length) {\n    extension.logger.warn(`Firefox does not support dataTypes: ${invalidDataTypes.toString()}.`);\n  }\n\n  return Promise.all(removalPromises);\n};"}],"browsingData":[{"filepath":"mobile/android/components/extensions/ext-browsingData.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"this.browsingData = class extends ExtensionAPI {\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    return {\n      browsingData: {\n        settings() {\n          const PREF_DOMAIN = \"android.not_a_preference.privacy.clear\";\n          const PREF_KEY_PREFIX = \"private.data.\";\n          const PREF_LIST = [\"cache\", \"history\", \"formdata\", \"cookies_sessions\", \"downloadFiles\"];\n          let dataTrue = SharedPreferences.forProfile().getSetPref(PREF_DOMAIN);\n          let name;\n          let dataToRemove = {};\n          let dataRemovalPermitted = {};\n\n          for (let item of PREF_LIST) {\n            switch (item) {\n              case \"formdata\":\n                name = \"formData\";\n                break;\n\n              case \"cookies_sessions\":\n                name = \"cookies\";\n                break;\n\n              case \"downloadFiles\":\n                name = \"downloads\";\n                break;\n\n              default:\n                name = item;\n            }\n\n            dataToRemove[name] = dataTrue.includes(`${PREF_KEY_PREFIX}${item}`);\n            dataRemovalPermitted[name] = true;\n          }\n\n          return Promise.resolve({\n            options: {\n              since: 0\n            },\n            dataToRemove,\n            dataRemovalPermitted\n          });\n        },\n\n        remove(options, dataToRemove) {\n          return doRemoval(options, dataToRemove, extension);\n        },\n\n        removeCache(options) {\n          return doRemoval(options, {\n            cache: true\n          });\n        },\n\n        removeCookies(options) {\n          return doRemoval(options, {\n            cookies: true\n          });\n        },\n\n        removeDownloads(options) {\n          return doRemoval(options, {\n            downloads: true\n          });\n        },\n\n        removeFormData(options) {\n          return doRemoval(options, {\n            formData: true\n          });\n        }\n\n      }\n    };\n  }\n\n}"},{"filepath":"browser/components/extensions/parent/ext-browsingData.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.browsingData = class extends ExtensionAPI {\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    return {\n      browsingData: {\n        settings() {\n          const PREF_DOMAIN = \"privacy.cpd.\";\n          const PREF_LIST = [\"cache\", \"cookies\", \"history\", \"formdata\", \"downloads\"];\n          let clearRange = Sanitizer.getClearRange();\n          let since = clearRange ? clearRange[0] / 1000 : 0;\n          let options = {\n            since\n          };\n          let dataToRemove = {};\n          let dataRemovalPermitted = {};\n\n          for (let item of PREF_LIST) {\n            const name = item === \"formdata\" ? \"formData\" : item;\n            dataToRemove[name] = Preferences.get(`${PREF_DOMAIN}${item}`);\n            dataRemovalPermitted[name] = true;\n          }\n\n          return Promise.resolve({\n            options,\n            dataToRemove,\n            dataRemovalPermitted\n          });\n        },\n\n        remove(options, dataToRemove) {\n          return doRemoval(options, dataToRemove, extension);\n        },\n\n        removeCache(options) {\n          return doRemoval(options, {\n            cache: true\n          });\n        },\n\n        removeCookies(options) {\n          return doRemoval(options, {\n            cookies: true\n          });\n        },\n\n        removeDownloads(options) {\n          return doRemoval(options, {\n            downloads: true\n          });\n        },\n\n        removeFormData(options) {\n          return doRemoval(options, {\n            formData: true\n          });\n        },\n\n        removeHistory(options) {\n          return doRemoval(options, {\n            history: true\n          });\n        },\n\n        removeIndexedDB(options) {\n          return doRemoval(options, {\n            indexedDB: true\n          });\n        },\n\n        removeLocalStorage(options) {\n          return doRemoval(options, {\n            localStorage: true\n          });\n        },\n\n        removePasswords(options) {\n          return doRemoval(options, {\n            passwords: true\n          });\n        },\n\n        removePluginData(options) {\n          return doRemoval(options, {\n            pluginData: true\n          });\n        }\n\n      }\n    };\n  }\n\n}"}],"browserActionMap":[{"filepath":"mobile/android/components/extensions/ext-browserAction.js","kind":"let","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"let browserActionMap = new WeakMap();"},{"filepath":"browser/components/extensions/parent/ext-browserAction.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const browserActionMap = new WeakMap();"}],"browserAction":[{"filepath":"mobile/android/components/extensions/ext-browserAction.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"this.browserAction = class extends ExtensionAPI {\n  onManifestEntry(entryName) {\n    let {\n      extension\n    } = this;\n    let {\n      manifest\n    } = extension;\n    let browserAction = new BrowserAction(manifest.browser_action, extension);\n    browserActionMap.set(extension, browserAction);\n  }\n\n  onShutdown() {\n    let {\n      extension\n    } = this;\n\n    if (browserActionMap.has(extension)) {\n      browserActionMap.get(extension).shutdown();\n      browserActionMap.delete(extension);\n    }\n  }\n\n  getAPI(context) {\n    const {\n      extension\n    } = context;\n    const {\n      tabManager\n    } = extension;\n\n    function getTab(tabId) {\n      if (tabId !== null) {\n        return tabTracker.getTab(tabId);\n      }\n\n      return null;\n    }\n\n    return {\n      browserAction: {\n        onClicked: new EventManager({\n          context,\n          name: \"browserAction.onClicked\",\n          register: fire => {\n            let listener = (event, tab) => {\n              fire.async(tabManager.convert(tab));\n            };\n\n            browserActionMap.get(extension).on(\"click\", listener);\n            return () => {\n              browserActionMap.get(extension).off(\"click\", listener);\n            };\n          }\n        }).api(),\n        setTitle: function (details) {\n          let {\n            tabId,\n            title\n          } = details;\n          let tab = getTab(tabId);\n          browserActionMap.get(extension).setProperty(tab, \"name\", title);\n        },\n        getTitle: function (details) {\n          let {\n            tabId\n          } = details;\n          let tab = getTab(tabId);\n          let title = browserActionMap.get(extension).getProperty(tab, \"name\");\n          return Promise.resolve(title);\n        },\n\n        setPopup(details) {\n          let tab = getTab(details.tabId);\n          let url = details.popup && context.uri.resolve(details.popup);\n          browserActionMap.get(extension).setProperty(tab, \"popup\", url);\n        },\n\n        getPopup(details) {\n          let tab = getTab(details.tabId);\n          let popup = browserActionMap.get(extension).getProperty(tab, \"popup\");\n          return Promise.resolve(popup);\n        }\n\n      }\n    };\n  }\n\n}"},{"filepath":"browser/components/extensions/parent/ext-browserAction.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.browserAction = class extends ExtensionAPI {\n  static for(extension) {\n    return browserActionMap.get(extension);\n  }\n\n  async onManifestEntry(entryName) {\n    let {\n      extension\n    } = this;\n    let options = extension.manifest.browser_action;\n    this.iconData = new DefaultWeakMap(icons => this.getIconData(icons));\n    let widgetId = makeWidgetId(extension.id);\n    this.id = `${widgetId}-browser-action`;\n    this.viewId = `PanelUI-webext-${widgetId}-browser-action-view`;\n    this.widget = null;\n    this.pendingPopup = null;\n    this.pendingPopupTimeout = null;\n    this.eventQueue = [];\n    this.tabManager = extension.tabManager;\n    this.defaults = {\n      enabled: true,\n      title: options.default_title || extension.name,\n      badgeText: \"\",\n      badgeBackgroundColor: [0xd9, 0, 0, 255],\n      badgeDefaultColor: [255, 255, 255, 255],\n      badgeTextColor: null,\n      popup: options.default_popup || \"\",\n      area: browserAreas[options.default_area || \"navbar\"]\n    };\n    this.globals = Object.create(this.defaults);\n    this.browserStyle = options.browser_style;\n    browserActionMap.set(extension, this);\n    this.defaults.icon = await StartupCache.get(extension, [\"browserAction\", \"default_icon\"], () => IconDetails.normalize({\n      path: options.default_icon || extension.manifest.icons,\n      iconType: \"browserAction\",\n      themeIcons: options.theme_icons\n    }, extension));\n    this.iconData.set(this.defaults.icon, (await StartupCache.get(extension, [\"browserAction\", \"default_icon_data\"], () => this.getIconData(this.defaults.icon))));\n    this.tabContext = new TabContext(target => {\n      let window = target.ownerGlobal;\n\n      if (target === window) {\n        return this.globals;\n      }\n\n      return this.tabContext.get(window);\n    });\n    this.tabContext.on(\"location-change\", this.handleLocationChange.bind(this));\n    this.build();\n  }\n\n  handleLocationChange(eventType, tab, fromBrowse) {\n    if (fromBrowse) {\n      this.tabContext.clear(tab);\n      this.updateOnChange(tab);\n    }\n  }\n\n  onShutdown() {\n    browserActionMap.delete(this.extension);\n    this.tabContext.shutdown();\n    CustomizableUI.destroyWidget(this.id);\n    this.clearPopup();\n  }\n\n  build() {\n    let widget = CustomizableUI.createWidget({\n      id: this.id,\n      viewId: this.viewId,\n      type: \"view\",\n      removable: true,\n      label: this.defaults.title || this.extension.name,\n      tooltiptext: this.defaults.title || \"\",\n      defaultArea: this.defaults.area,\n      showInPrivateBrowsing: this.extension.privateBrowsingAllowed,\n      localized: false,\n      onBeforeCreated: document => {\n        let view = document.createXULElement(\"panelview\");\n        view.id = this.viewId;\n        view.setAttribute(\"flex\", \"1\");\n        view.setAttribute(\"extension\", true);\n        document.getElementById(\"appMenu-viewCache\").appendChild(view);\n\n        if (this.extension.hasPermission(\"menus\") || this.extension.hasPermission(\"contextMenus\")) {\n          document.addEventListener(\"popupshowing\", this);\n        }\n      },\n      onDestroyed: document => {\n        document.removeEventListener(\"popupshowing\", this);\n        let view = document.getElementById(this.viewId);\n\n        if (view) {\n          this.clearPopup();\n          CustomizableUI.hidePanelForNode(view);\n          view.remove();\n        }\n      },\n      onCreated: node => {\n        node.classList.add(\"panel-no-padding\");\n        node.classList.add(\"webextension-browser-action\");\n        node.setAttribute(\"badged\", \"true\");\n        node.setAttribute(\"constrain-size\", \"true\");\n        node.setAttribute(\"data-extensionid\", this.extension.id);\n\n        node.onmousedown = event => this.handleEvent(event);\n\n        node.onmouseover = event => this.handleEvent(event);\n\n        node.onmouseout = event => this.handleEvent(event);\n\n        this.updateButton(node, this.globals, true);\n      },\n      onViewShowing: async event => {\n        const {\n          extension\n        } = this;\n        ExtensionTelemetry.browserActionPopupOpen.stopwatchStart(extension, this);\n        let document = event.target.ownerDocument;\n        let tabbrowser = document.defaultView.gBrowser;\n        let tab = tabbrowser.selectedTab;\n        let popupURL = this.getProperty(tab, \"popup\");\n        this.tabManager.addActiveTabPermission(tab);\n\n        if (popupURL) {\n          try {\n            let popup = this.getPopup(document.defaultView, popupURL);\n            let attachPromise = popup.attach(event.target);\n            event.detail.addBlocker(attachPromise);\n            await attachPromise;\n            ExtensionTelemetry.browserActionPopupOpen.stopwatchFinish(extension, this);\n\n            if (this.eventQueue.length) {\n              ExtensionTelemetry.browserActionPreloadResult.histogramAdd({\n                category: \"popupShown\",\n                extension\n              });\n              this.eventQueue = [];\n            }\n          } catch (e) {\n            ExtensionTelemetry.browserActionPopupOpen.stopwatchCancel(extension, this);\n            Cu.reportError(e);\n            event.preventDefault();\n          }\n        } else {\n          ExtensionTelemetry.browserActionPopupOpen.stopwatchCancel(extension, this);\n          event.preventDefault();\n          this.emit(\"click\", tabbrowser.selectedBrowser);\n          CustomizableUI.hidePanelForNode(event.target);\n        }\n      }\n    });\n    this.tabContext.on(\"tab-select\", (evt, tab) => {\n      this.updateWindow(tab.ownerGlobal);\n    });\n    this.widget = widget;\n  }\n\n  async triggerAction(window) {\n    let popup = ViewPopup.for(this.extension, window);\n\n    if (popup) {\n      popup.closePopup();\n      return;\n    }\n\n    let widget = this.widget.forWindow(window);\n    let tab = window.gBrowser.selectedTab;\n\n    if (!widget.node || !this.getProperty(tab, \"enabled\")) {\n      return;\n    }\n\n    if (this.getProperty(tab, \"popup\")) {\n      if (this.widget.areaType == CustomizableUI.TYPE_MENU_PANEL) {\n        await window.document.getElementById(\"nav-bar\").overflowable.show();\n      }\n\n      let event = new window.CustomEvent(\"command\", {\n        bubbles: true,\n        cancelable: true\n      });\n      widget.node.dispatchEvent(event);\n    } else {\n      this.tabManager.addActiveTabPermission(tab);\n      this.emit(\"click\");\n    }\n  }\n\n  handleEvent(event) {\n    let button = event.target;\n    let window = button.ownerGlobal;\n\n    switch (event.type) {\n      case \"mousedown\":\n        if (event.button == 0) {\n          let tab = window.gBrowser.selectedTab;\n          let popupURL = this.getProperty(tab, \"popup\");\n          let enabled = this.getProperty(tab, \"enabled\");\n\n          if (popupURL && enabled && (this.pendingPopup || !ViewPopup.for(this.extension, window))) {\n            this.eventQueue.push(\"Mousedown\");\n\n            if (!this.tabManager.hasActiveTabPermission(tab)) {\n              this.tabManager.addActiveTabPermission(tab);\n              this.tabToRevokeDuringClearPopup = tab;\n            }\n\n            this.pendingPopup = this.getPopup(window, popupURL);\n            window.addEventListener(\"mouseup\", this, true);\n          } else {\n            this.clearPopup();\n          }\n        }\n\n        break;\n\n      case \"mouseup\":\n        if (event.button == 0) {\n          this.clearPopupTimeout();\n\n          if (this.pendingPopup) {\n            let node = window.gBrowser && this.widget.forWindow(window).node;\n\n            if (node && node.contains(event.originalTarget)) {\n              this.pendingPopupTimeout = setTimeout(() => this.clearPopup(), POPUP_PRELOAD_TIMEOUT_MS);\n            } else {\n              this.clearPopup();\n            }\n          }\n        }\n\n        break;\n\n      case \"mouseover\":\n        {\n          let tab = window.gBrowser.selectedTab;\n          let popupURL = this.getProperty(tab, \"popup\");\n          let enabled = this.getProperty(tab, \"enabled\");\n\n          if (popupURL && enabled && (this.pendingPopup || !ViewPopup.for(this.extension, window))) {\n            this.eventQueue.push(\"Hover\");\n            this.pendingPopup = this.getPopup(window, popupURL, true);\n          }\n\n          break;\n        }\n\n      case \"mouseout\":\n        if (this.pendingPopup) {\n          if (this.eventQueue.length) {\n            ExtensionTelemetry.browserActionPreloadResult.histogramAdd({\n              category: `clearAfter${this.eventQueue.pop()}`,\n              extension: this.extension\n            });\n            this.eventQueue = [];\n          }\n\n          this.clearPopup();\n        }\n\n        break;\n\n      case \"popupshowing\":\n        const menu = event.target;\n        const trigger = menu.triggerNode;\n        const node = window.document.getElementById(this.id);\n        const contexts = [\"toolbar-context-menu\", \"customizationPanelItemContextMenu\"];\n\n        if (contexts.includes(menu.id) && node && node.contains(trigger)) {\n          global.actionContextMenu({\n            extension: this.extension,\n            onBrowserAction: true,\n            menu: menu\n          });\n        }\n\n        break;\n    }\n  }\n\n  getPopup(window, popupURL, blockParser = false) {\n    this.clearPopupTimeout();\n    let {\n      pendingPopup\n    } = this;\n    this.pendingPopup = null;\n\n    if (pendingPopup) {\n      if (pendingPopup.window === window && pendingPopup.popupURL === popupURL) {\n        if (!blockParser) {\n          pendingPopup.unblockParser();\n        }\n\n        return pendingPopup;\n      }\n\n      pendingPopup.destroy();\n    }\n\n    let fixedWidth = this.widget.areaType == CustomizableUI.TYPE_MENU_PANEL || this.widget.forWindow(window).overflowed;\n    return new ViewPopup(this.extension, window, popupURL, this.browserStyle, fixedWidth, blockParser);\n  }\n\n  clearPopup() {\n    this.clearPopupTimeout();\n\n    if (this.pendingPopup) {\n      if (this.tabToRevokeDuringClearPopup) {\n        this.tabManager.revokeActiveTabPermission(this.tabToRevokeDuringClearPopup);\n      }\n\n      this.pendingPopup.destroy();\n      this.pendingPopup = null;\n    }\n\n    this.tabToRevokeDuringClearPopup = null;\n  }\n\n  clearPopupTimeout() {\n    if (this.pendingPopup) {\n      this.pendingPopup.window.removeEventListener(\"mouseup\", this, true);\n    }\n\n    if (this.pendingPopupTimeout) {\n      clearTimeout(this.pendingPopupTimeout);\n      this.pendingPopupTimeout = null;\n    }\n  }\n\n  updateButton(node, tabData, sync = false) {\n    let title = tabData.title || this.extension.name;\n\n    let callback = () => {\n      node.setAttribute(\"tooltiptext\", title);\n      node.setAttribute(\"label\", title);\n\n      if (tabData.badgeText) {\n        node.setAttribute(\"badge\", tabData.badgeText);\n      } else {\n        node.removeAttribute(\"badge\");\n      }\n\n      if (tabData.enabled) {\n        node.removeAttribute(\"disabled\");\n      } else {\n        node.setAttribute(\"disabled\", \"true\");\n      }\n\n      let serializeColor = ([r, g, b, a]) => `rgba(${r}, ${g}, ${b}, ${a / 255})`;\n\n      node.setAttribute(\"badgeStyle\", [`background-color: ${serializeColor(tabData.badgeBackgroundColor)}`, `color: ${serializeColor(this.getTextColor(tabData))}`].join(\"; \"));\n      let style = this.iconData.get(tabData.icon);\n      node.setAttribute(\"style\", style);\n    };\n\n    if (sync) {\n      callback();\n    } else {\n      node.ownerGlobal.requestAnimationFrame(callback);\n    }\n  }\n\n  getIconData(icons) {\n    let getIcon = (icon, theme) => {\n      if (typeof icon === \"object\") {\n        return IconDetails.escapeUrl(icon[theme]);\n      }\n\n      return IconDetails.escapeUrl(icon);\n    };\n\n    let getStyle = (name, icon) => {\n      return `\n        --webextension-${name}: url(\"${getIcon(icon, \"default\")}\");\n        --webextension-${name}-light: url(\"${getIcon(icon, \"light\")}\");\n        --webextension-${name}-dark: url(\"${getIcon(icon, \"dark\")}\");\n      `;\n    };\n\n    let icon16 = IconDetails.getPreferredIcon(icons, this.extension, 16).icon;\n    let icon32 = IconDetails.getPreferredIcon(icons, this.extension, 32).icon;\n    return `\n      ${getStyle(\"menupanel-image\", icon16)}\n      ${getStyle(\"menupanel-image-2x\", icon32)}\n      ${getStyle(\"toolbar-image\", icon16)}\n      ${getStyle(\"toolbar-image-2x\", icon32)}\n    `;\n  }\n\n  updateWindow(window) {\n    let node = this.widget.forWindow(window).node;\n\n    if (node) {\n      let tab = window.gBrowser.selectedTab;\n      this.updateButton(node, this.tabContext.get(tab));\n    }\n  }\n\n  updateOnChange(target) {\n    if (target) {\n      let window = target.ownerGlobal;\n\n      if (target === window || target.selected) {\n        this.updateWindow(window);\n      }\n    } else {\n      for (let window of windowTracker.browserWindows()) {\n        this.updateWindow(window);\n      }\n    }\n  }\n\n  getTargetFromDetails({\n    tabId,\n    windowId\n  }) {\n    if (tabId != null && windowId != null) {\n      throw new ExtensionError(\"Only one of tabId and windowId can be specified.\");\n    }\n\n    if (tabId != null) {\n      return tabTracker.getTab(tabId);\n    } else if (windowId != null) {\n      return windowTracker.getWindow(windowId);\n    }\n\n    return null;\n  }\n\n  getContextData(target) {\n    if (target) {\n      return this.tabContext.get(target);\n    }\n\n    return this.globals;\n  }\n\n  setProperty(target, prop, value) {\n    let values = this.getContextData(target);\n\n    if (value === null) {\n      delete values[prop];\n    } else {\n      values[prop] = value;\n    }\n\n    this.updateOnChange(target);\n    return values;\n  }\n\n  getProperty(target, prop) {\n    return this.getContextData(target)[prop];\n  }\n\n  setPropertyFromDetails(details, prop, value) {\n    return this.setProperty(this.getTargetFromDetails(details), prop, value);\n  }\n\n  getPropertyFromDetails(details, prop) {\n    return this.getProperty(this.getTargetFromDetails(details), prop);\n  }\n\n  getTextColor(values) {\n    let {\n      badgeTextColor\n    } = values;\n\n    if (badgeTextColor) {\n      return badgeTextColor;\n    }\n\n    let {\n      badgeDefaultColor\n    } = values;\n\n    if (badgeDefaultColor) {\n      return badgeDefaultColor;\n    }\n\n    let [r, g, b] = values.badgeBackgroundColor.slice(0, 3).map(function (channel) {\n      channel /= 255;\n\n      if (channel <= 0.03928) {\n        return channel / 12.92;\n      }\n\n      return ((channel + 0.055) / 1.055) ** 2.4;\n    });\n    let lum = 0.2126 * r + 0.7152 * g + 0.0722 * b;\n    let channel = 1.05 * 0.05 < (lum + 0.05) ** 2 ? 0 : 255;\n    let result = [channel, channel, channel, 255];\n\n    while (!Object.getOwnPropertyDescriptor(values, \"badgeDefaultColor\")) {\n      values = Object.getPrototypeOf(values);\n    }\n\n    values.badgeDefaultColor = result;\n    return result;\n  }\n\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    let {\n      tabManager\n    } = extension;\n    let browserAction = this;\n\n    function parseColor(color, kind) {\n      if (typeof color == \"string\") {\n        let rgba = InspectorUtils.colorToRGBA(color);\n\n        if (!rgba) {\n          throw new ExtensionError(`Invalid badge ${kind} color: \"${color}\"`);\n        }\n\n        color = [rgba.r, rgba.g, rgba.b, Math.round(rgba.a * 255)];\n      }\n\n      return color;\n    }\n\n    return {\n      browserAction: {\n        onClicked: new EventManager({\n          context,\n          name: \"browserAction.onClicked\",\n          inputHandling: true,\n          register: fire => {\n            let listener = (event, browser) => {\n              context.withPendingBrowser(browser, () => fire.sync(tabManager.convert(tabTracker.activeTab)));\n            };\n\n            browserAction.on(\"click\", listener);\n            return () => {\n              browserAction.off(\"click\", listener);\n            };\n          }\n        }).api(),\n        enable: function (tabId) {\n          browserAction.setPropertyFromDetails({\n            tabId\n          }, \"enabled\", true);\n        },\n        disable: function (tabId) {\n          browserAction.setPropertyFromDetails({\n            tabId\n          }, \"enabled\", false);\n        },\n        isEnabled: function (details) {\n          return browserAction.getPropertyFromDetails(details, \"enabled\");\n        },\n        setTitle: function (details) {\n          browserAction.setPropertyFromDetails(details, \"title\", details.title);\n        },\n        getTitle: function (details) {\n          return browserAction.getPropertyFromDetails(details, \"title\");\n        },\n        setIcon: function (details) {\n          details.iconType = \"browserAction\";\n          let icon = IconDetails.normalize(details, extension, context);\n\n          if (!Object.keys(icon).length) {\n            icon = null;\n          }\n\n          browserAction.setPropertyFromDetails(details, \"icon\", icon);\n        },\n        setBadgeText: function (details) {\n          browserAction.setPropertyFromDetails(details, \"badgeText\", details.text);\n        },\n        getBadgeText: function (details) {\n          return browserAction.getPropertyFromDetails(details, \"badgeText\");\n        },\n        setPopup: function (details) {\n          let url = details.popup && context.uri.resolve(details.popup);\n\n          if (url && !context.checkLoadURL(url)) {\n            return Promise.reject({\n              message: `Access denied for URL ${url}`\n            });\n          }\n\n          browserAction.setPropertyFromDetails(details, \"popup\", url);\n        },\n        getPopup: function (details) {\n          return browserAction.getPropertyFromDetails(details, \"popup\");\n        },\n        setBadgeBackgroundColor: function (details) {\n          let color = parseColor(details.color, \"background\");\n          let values = browserAction.setPropertyFromDetails(details, \"badgeBackgroundColor\", color);\n\n          if (color === null) {\n            delete values.badgeDefaultColor;\n          } else {\n            values.badgeDefaultColor = null;\n          }\n        },\n        getBadgeBackgroundColor: function (details, callback) {\n          return browserAction.getPropertyFromDetails(details, \"badgeBackgroundColor\");\n        },\n        setBadgeTextColor: function (details) {\n          let color = parseColor(details.color, \"text\");\n          browserAction.setPropertyFromDetails(details, \"badgeTextColor\", color);\n        },\n        getBadgeTextColor: function (details) {\n          let target = browserAction.getTargetFromDetails(details);\n          let values = browserAction.getContextData(target);\n          return browserAction.getTextColor(values);\n        },\n        openPopup: function () {\n          let window = windowTracker.topWindow;\n          browserAction.triggerAction(window);\n        }\n      }\n    };\n  }\n\n}"},{"filepath":"browser/components/extensions/parent/ext-browserAction.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"global.browserActionFor = this.browserAction.for"}],"IconDetails":[{"filepath":"mobile/android/components/extensions/ext-pageAction.js","kind":"var","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"var {\n  IconDetails\n} = ExtensionParent;"},{"filepath":"browser/components/extensions/parent/ext-pageAction.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  IconDetails,\n  StartupCache\n} = ExtensionParent;"},{"filepath":"browser/components/extensions/parent/ext-sidebarAction.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  IconDetails\n} = ExtensionParent;"},{"filepath":"browser/components/extensions/parent/ext-urlbar.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  IconDetails\n} = ExtensionParent;"},{"filepath":"browser/components/extensions/parent/ext-devtools-panels.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  IconDetails,\n  watchExtensionProxyContextLoad\n} = ExtensionParent;"},{"filepath":"browser/components/extensions/parent/ext-browserAction.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  IconDetails,\n  StartupCache\n} = ExtensionParent;"},{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  IconDetails\n} = ExtensionParent;"}],"pageActionMap":[{"filepath":"mobile/android/components/extensions/ext-pageAction.js","kind":"let","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"let pageActionMap = new WeakMap();"},{"filepath":"browser/components/extensions/parent/ext-pageAction.js","kind":"let","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"let pageActionMap = new WeakMap();"}],"pageAction":[{"filepath":"mobile/android/components/extensions/ext-pageAction.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"this.pageAction = class extends ExtensionAPI {\n  onManifestEntry(entryName) {\n    let {\n      extension\n    } = this;\n    let {\n      manifest\n    } = extension;\n    let pageAction = new PageAction(manifest.page_action, extension);\n    pageActionMap.set(extension, pageAction);\n  }\n\n  onShutdown() {\n    let {\n      extension\n    } = this;\n\n    if (pageActionMap.has(extension)) {\n      pageActionMap.get(extension).shutdown();\n      pageActionMap.delete(extension);\n    }\n  }\n\n  getAPI(context) {\n    const {\n      extension\n    } = context;\n    const {\n      tabManager\n    } = extension;\n    pageActionMap.get(extension).setContext(context);\n    return {\n      pageAction: {\n        onClicked: new EventManager({\n          context,\n          name: \"pageAction.onClicked\",\n          register: fire => {\n            let listener = (event, tab) => {\n              fire.async(tabManager.convert(tab));\n            };\n\n            pageActionMap.get(extension).on(\"click\", listener);\n            return () => {\n              pageActionMap.get(extension).off(\"click\", listener);\n            };\n          }\n        }).api(),\n\n        show(tabId) {\n          let tab = tabTracker.getTab(tabId);\n          return pageActionMap.get(extension).setProperty(tab, \"show\", true);\n        },\n\n        hide(tabId) {\n          let tab = tabTracker.getTab(tabId);\n          pageActionMap.get(extension).setProperty(tab, \"show\", false);\n        },\n\n        setPopup(details) {\n          let tab = tabTracker.getTab(details.tabId);\n          let url = details.popup && context.uri.resolve(details.popup);\n          pageActionMap.get(extension).setProperty(tab, \"popup\", url);\n        },\n\n        getPopup(details) {\n          let tab = tabTracker.getTab(details.tabId);\n          let popup = pageActionMap.get(extension).getProperty(tab, \"popup\");\n          return Promise.resolve(popup);\n        }\n\n      }\n    };\n  }\n\n}"},{"filepath":"browser/components/extensions/parent/ext-pageAction.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.pageAction = class extends ExtensionAPI {\n  static for(extension) {\n    return pageActionMap.get(extension);\n  }\n\n  async onManifestEntry(entryName) {\n    let {\n      extension\n    } = this;\n    let options = extension.manifest.page_action;\n    let widgetId = makeWidgetId(extension.id);\n    this.id = widgetId + \"-page-action\";\n    this.tabManager = extension.tabManager;\n    let show, showMatches, hideMatches;\n    let show_matches = options.show_matches || [];\n    let hide_matches = options.hide_matches || [];\n\n    if (!show_matches.length) {\n      show = false;\n    } else {\n      const {\n        restrictSchemes\n      } = extension;\n      showMatches = new MatchPatternSet(show_matches, {\n        restrictSchemes\n      });\n      hideMatches = new MatchPatternSet(hide_matches, {\n        restrictSchemes\n      });\n    }\n\n    this.defaults = {\n      show,\n      showMatches,\n      hideMatches,\n      title: options.default_title || extension.name,\n      popup: options.default_popup || \"\",\n      pinned: options.pinned\n    };\n    this.browserStyle = options.browser_style;\n    this.tabContext = new TabContext(tab => this.defaults);\n    this.tabContext.on(\"location-change\", this.handleLocationChange.bind(this));\n    pageActionMap.set(extension, this);\n    this.defaults.icon = await StartupCache.get(extension, [\"pageAction\", \"default_icon\"], () => this.normalize({\n      path: options.default_icon || \"\"\n    }));\n    this.lastValues = new DefaultWeakMap(() => ({}));\n\n    if (!this.browserPageAction) {\n      this.browserPageAction = PageActions.addAction(new PageActions.Action({\n        id: widgetId,\n        extensionID: extension.id,\n        title: this.defaults.title,\n        iconURL: this.defaults.icon,\n        pinnedToUrlbar: this.defaults.pinned,\n        disabled: !this.defaults.show,\n        onCommand: (event, buttonNode) => {\n          this.handleClick(event.target.ownerGlobal);\n        },\n        onBeforePlacedInWindow: browserWindow => {\n          if (this.extension.hasPermission(\"menus\") || this.extension.hasPermission(\"contextMenus\")) {\n            browserWindow.document.addEventListener(\"popupshowing\", this);\n          }\n        },\n        onRemovedFromWindow: browserWindow => {\n          browserWindow.document.removeEventListener(\"popupshowing\", this);\n        }\n      }));\n\n      if (show === undefined) {\n        for (let window of windowTracker.browserWindows()) {\n          let tab = window.gBrowser.selectedTab;\n\n          if (this.isShown(tab)) {\n            this.updateButton(window);\n          }\n        }\n      }\n    }\n  }\n\n  onShutdown(isAppShutdown) {\n    pageActionMap.delete(this.extension);\n    this.tabContext.shutdown();\n\n    if (!isAppShutdown && this.browserPageAction) {\n      this.browserPageAction.remove();\n      this.browserPageAction = null;\n    }\n  }\n\n  getProperty(tab, prop) {\n    return this.tabContext.get(tab)[prop];\n  }\n\n  setProperty(tab, prop, value) {\n    if (value != null) {\n      this.tabContext.get(tab)[prop] = value;\n    } else {\n      delete this.tabContext.get(tab)[prop];\n    }\n\n    if (tab.selected) {\n      this.updateButton(tab.ownerGlobal);\n    }\n  }\n\n  normalize(details, context = null) {\n    let icon = IconDetails.normalize(details, this.extension, context);\n\n    if (!Object.keys(icon).length) {\n      icon = null;\n    }\n\n    return icon;\n  }\n\n  updateButton(window) {\n    let tab = window.gBrowser.selectedTab;\n    let tabData = this.tabContext.get(tab);\n    let last = this.lastValues.get(window);\n    window.requestAnimationFrame(() => {\n      if (!this.browserPageAction) {\n        return;\n      }\n\n      let title = tabData.title || this.extension.name;\n\n      if (last.title !== title) {\n        this.browserPageAction.setTitle(title, window);\n        last.title = title;\n      }\n\n      let show = tabData.show != null ? tabData.show : tabData.patternMatching;\n\n      if (last.show !== show) {\n        this.browserPageAction.setDisabled(!show, window);\n        last.show = show;\n      }\n\n      let icon = tabData.icon;\n\n      if (last.icon !== icon) {\n        this.browserPageAction.setIconURL(icon, window);\n        last.icon = icon;\n      }\n    });\n  }\n\n  isShown(tab) {\n    let tabData = this.tabContext.get(tab);\n\n    if (tabData.show !== undefined) {\n      return tabData.show;\n    }\n\n    if (tabData.patternMatching === undefined) {\n      let uri = tab.linkedBrowser.currentURI;\n      tabData.patternMatching = tabData.showMatches.matches(uri) && !tabData.hideMatches.matches(uri);\n    }\n\n    return tabData.patternMatching;\n  }\n\n  triggerAction(window) {\n    if (this.isShown(window.gBrowser.selectedTab)) {\n      this.handleClick(window);\n    }\n  }\n\n  handleEvent(event) {\n    switch (event.type) {\n      case \"popupshowing\":\n        const menu = event.target;\n        const trigger = menu.triggerNode;\n\n        if (menu.id === \"pageActionContextMenu\" && trigger && trigger.getAttribute(\"actionid\") === this.browserPageAction.id && !this.browserPageAction.getDisabled(trigger.ownerGlobal)) {\n          global.actionContextMenu({\n            extension: this.extension,\n            onPageAction: true,\n            menu: menu\n          });\n        }\n\n        break;\n    }\n  }\n\n  async handleClick(window) {\n    const {\n      extension\n    } = this;\n    ExtensionTelemetry.pageActionPopupOpen.stopwatchStart(extension, this);\n    let tab = window.gBrowser.selectedTab;\n    let popupURL = this.tabContext.get(tab).popup;\n    this.tabManager.addActiveTabPermission(tab);\n\n    if (popupURL) {\n      if (this.popupNode && this.popupNode.panel.state !== \"closed\") {\n        ExtensionTelemetry.pageActionPopupOpen.stopwatchCancel(extension, this);\n        window.BrowserPageActions.togglePanelForAction(this.browserPageAction, this.popupNode.panel);\n        return;\n      }\n\n      this.popupNode = new PanelPopup(extension, window.document, popupURL, this.browserStyle);\n      this.popupNode.panel.addEventListener(\"popuphiding\", () => {\n        this.popupNode = undefined;\n      }, {\n        once: true\n      });\n      await this.popupNode.contentReady;\n      window.BrowserPageActions.togglePanelForAction(this.browserPageAction, this.popupNode.panel);\n      ExtensionTelemetry.pageActionPopupOpen.stopwatchFinish(extension, this);\n    } else {\n      ExtensionTelemetry.pageActionPopupOpen.stopwatchCancel(extension, this);\n      this.emit(\"click\", tab);\n    }\n  }\n\n  handleLocationChange(eventType, tab, fromBrowse) {\n    if (fromBrowse === true) {\n      this.tabContext.clear(tab);\n    } else if (fromBrowse === false) {\n      let tabData = this.tabContext.get(tab);\n\n      if (tabData.patternMatching !== undefined) {\n        tabData.patternMatching = undefined;\n      }\n    }\n\n    if (tab.selected) {\n      this.isShown(tab);\n      this.updateButton(tab.ownerGlobal);\n    }\n  }\n\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    const {\n      tabManager\n    } = extension;\n    const pageAction = this;\n    return {\n      pageAction: {\n        onClicked: new EventManager({\n          context,\n          name: \"pageAction.onClicked\",\n          inputHandling: true,\n          register: fire => {\n            let listener = (evt, tab) => {\n              context.withPendingBrowser(tab.linkedBrowser, () => fire.sync(tabManager.convert(tab)));\n            };\n\n            pageAction.on(\"click\", listener);\n            return () => {\n              pageAction.off(\"click\", listener);\n            };\n          }\n        }).api(),\n\n        show(tabId) {\n          let tab = tabTracker.getTab(tabId);\n          pageAction.setProperty(tab, \"show\", true);\n        },\n\n        hide(tabId) {\n          let tab = tabTracker.getTab(tabId);\n          pageAction.setProperty(tab, \"show\", false);\n        },\n\n        isShown(details) {\n          let tab = tabTracker.getTab(details.tabId);\n          return pageAction.isShown(tab);\n        },\n\n        setTitle(details) {\n          let tab = tabTracker.getTab(details.tabId);\n          pageAction.setProperty(tab, \"title\", details.title);\n        },\n\n        getTitle(details) {\n          let tab = tabTracker.getTab(details.tabId);\n          let title = pageAction.getProperty(tab, \"title\");\n          return Promise.resolve(title);\n        },\n\n        setIcon(details) {\n          let tab = tabTracker.getTab(details.tabId);\n          let icon = pageAction.normalize(details, context);\n          pageAction.setProperty(tab, \"icon\", icon);\n        },\n\n        setPopup(details) {\n          let tab = tabTracker.getTab(details.tabId);\n          let url = details.popup && context.uri.resolve(details.popup);\n\n          if (url && !context.checkLoadURL(url)) {\n            return Promise.reject({\n              message: `Access denied for URL ${url}`\n            });\n          }\n\n          pageAction.setProperty(tab, \"popup\", url);\n        },\n\n        getPopup(details) {\n          let tab = tabTracker.getTab(details.tabId);\n          let popup = pageAction.getProperty(tab, \"popup\");\n          return Promise.resolve(popup);\n        },\n\n        openPopup: function () {\n          let window = windowTracker.topWindow;\n          pageAction.triggerAction(window);\n        }\n      }\n    };\n  }\n\n}"},{"filepath":"browser/components/extensions/parent/ext-pageAction.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"global.pageActionFor = this.pageAction.for"}],"ExtensionPreferencesManager":[{"filepath":"toolkit/components/extensions/parent/ext-browserSettings.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionPreferencesManager\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionPreferencesManager.jsm\");"},{"filepath":"toolkit/components/extensions/parent/ext-contextualIdentities.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionPreferencesManager\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionPreferencesManager.jsm\");"},{"filepath":"toolkit/components/extensions/parent/ext-privacy.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionPreferencesManager\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionPreferencesManager.jsm\");"},{"filepath":"toolkit/components/extensions/parent/ext-proxy.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionPreferencesManager\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionPreferencesManager.jsm\");"},{"filepath":"browser/components/extensions/parent/ext-urlbar.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionPreferencesManager\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionPreferencesManager.jsm\");"},{"filepath":"browser/components/extensions/parent/ext-chrome-settings-overrides.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionPreferencesManager\n} = ChromeUtils.import(\"resource://gre/modules/ExtensionPreferencesManager.jsm\");"}],"getSettingsAPI":[{"filepath":"toolkit/components/extensions/parent/ext-browserSettings.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  getSettingsAPI\n} = ExtensionPreferencesManager;"},{"filepath":"toolkit/components/extensions/parent/ext-proxy.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  getSettingsAPI\n} = ExtensionPreferencesManager;"},{"filepath":"browser/components/extensions/parent/ext-urlbar.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  getSettingsAPI\n} = ExtensionPreferencesManager;"}],"HOMEPAGE_OVERRIDE_SETTING":[{"filepath":"toolkit/components/extensions/parent/ext-browserSettings.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const HOMEPAGE_OVERRIDE_SETTING = \"homepage_override\";"}],"HOMEPAGE_URL_PREF":[{"filepath":"toolkit/components/extensions/parent/ext-browserSettings.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const HOMEPAGE_URL_PREF = \"browser.startup.homepage\";"}],"URL_STORE_TYPE":[{"filepath":"toolkit/components/extensions/parent/ext-browserSettings.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const URL_STORE_TYPE = \"url_overrides\";"}],"NEW_TAB_OVERRIDE_SETTING":[{"filepath":"toolkit/components/extensions/parent/ext-browserSettings.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const NEW_TAB_OVERRIDE_SETTING = \"newTabURL\";"}],"PERM_DENY_ACTION":[{"filepath":"toolkit/components/extensions/parent/ext-browserSettings.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const PERM_DENY_ACTION = Services.perms.DENY_ACTION;"}],"browserSettings":[{"filepath":"toolkit/components/extensions/parent/ext-browserSettings.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.browserSettings = class extends ExtensionAPI {\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    return {\n      browserSettings: {\n        allowPopupsForUserEvents: getSettingsAPI(extension.id, \"allowPopupsForUserEvents\", () => {\n          return Services.prefs.getCharPref(\"dom.popup_allowed_events\") != \"\";\n        }),\n        cacheEnabled: getSettingsAPI(extension.id, \"cacheEnabled\", () => {\n          return Services.prefs.getBoolPref(\"browser.cache.disk.enable\") && Services.prefs.getBoolPref(\"browser.cache.memory.enable\");\n        }),\n        closeTabsByDoubleClick: getSettingsAPI(extension.id, \"closeTabsByDoubleClick\", () => {\n          return Services.prefs.getBoolPref(\"browser.tabs.closeTabByDblclick\");\n        }, undefined, false, () => {\n          if (AppConstants.platform == \"android\") {\n            throw new ExtensionError(`android is not a supported platform for the closeTabsByDoubleClick setting.`);\n          }\n        }),\n        contextMenuShowEvent: Object.assign(getSettingsAPI(extension.id, \"contextMenuShowEvent\", () => {\n          if (AppConstants.platform === \"win\") {\n            return \"mouseup\";\n          }\n\n          let prefValue = Services.prefs.getBoolPref(\"ui.context_menus.after_mouseup\", null);\n          return prefValue ? \"mouseup\" : \"mousedown\";\n        }), {\n          set: details => {\n            if (![\"mouseup\", \"mousedown\"].includes(details.value)) {\n              throw new ExtensionError(`${details.value} is not a valid value for contextMenuShowEvent.`);\n            }\n\n            if (AppConstants.platform === \"android\" || AppConstants.platform === \"win\" && details.value === \"mousedown\") {\n              return false;\n            }\n\n            return ExtensionPreferencesManager.setSetting(extension.id, \"contextMenuShowEvent\", details.value);\n          }\n        }),\n        homepageOverride: getSettingsAPI(extension.id, HOMEPAGE_OVERRIDE_SETTING, () => {\n          return Services.prefs.getStringPref(HOMEPAGE_URL_PREF);\n        }, undefined, true),\n        imageAnimationBehavior: getSettingsAPI(extension.id, \"imageAnimationBehavior\", () => {\n          return Services.prefs.getCharPref(\"image.animation_mode\");\n        }),\n        newTabPosition: getSettingsAPI(extension.id, \"newTabPosition\", () => {\n          if (Services.prefs.getBoolPref(\"browser.tabs.insertAfterCurrent\")) {\n            return \"afterCurrent\";\n          }\n\n          if (Services.prefs.getBoolPref(\"browser.tabs.insertRelatedAfterCurrent\")) {\n            return \"relatedAfterCurrent\";\n          }\n\n          return \"atEnd\";\n        }),\n        newTabPageOverride: getSettingsAPI(extension.id, NEW_TAB_OVERRIDE_SETTING, () => {\n          return aboutNewTabService.newTabURL;\n        }, URL_STORE_TYPE, true),\n        openBookmarksInNewTabs: getSettingsAPI(extension.id, \"openBookmarksInNewTabs\", () => {\n          return Services.prefs.getBoolPref(\"browser.tabs.loadBookmarksInTabs\");\n        }),\n        openSearchResultsInNewTabs: getSettingsAPI(extension.id, \"openSearchResultsInNewTabs\", () => {\n          return Services.prefs.getBoolPref(\"browser.search.openintab\");\n        }),\n        openUrlbarResultsInNewTabs: getSettingsAPI(extension.id, \"openUrlbarResultsInNewTabs\", () => {\n          return Services.prefs.getBoolPref(\"browser.urlbar.openintab\");\n        }),\n        webNotificationsDisabled: getSettingsAPI(extension.id, \"webNotificationsDisabled\", () => {\n          let prefValue = Services.prefs.getIntPref(\"permissions.default.desktop-notification\", null);\n          return prefValue === PERM_DENY_ACTION;\n        }),\n        overrideDocumentColors: Object.assign(getSettingsAPI(extension.id, \"overrideDocumentColors\", () => {\n          let prefValue = Services.prefs.getIntPref(\"browser.display.document_color_use\");\n\n          if (prefValue === 1) {\n            return \"never\";\n          } else if (prefValue === 2) {\n            return \"always\";\n          }\n\n          return \"high-contrast-only\";\n        }), {\n          set: details => {\n            if (![\"never\", \"always\", \"high-contrast-only\"].includes(details.value)) {\n              throw new ExtensionError(`${details.value} is not a valid value for overrideDocumentColors.`);\n            }\n\n            let prefValue = 0;\n\n            if (details.value === \"never\") {\n              prefValue = 1;\n            } else if (details.value === \"always\") {\n              prefValue = 2;\n            }\n\n            return ExtensionPreferencesManager.setSetting(extension.id, \"overrideDocumentColors\", prefValue);\n          }\n        }),\n        useDocumentFonts: Object.assign(getSettingsAPI(extension.id, \"useDocumentFonts\", () => {\n          return Services.prefs.getIntPref(\"browser.display.use_document_fonts\") !== 0;\n        }), {\n          set: details => {\n            if (typeof details.value !== \"boolean\") {\n              throw new ExtensionError(`${details.value} is not a valid value for useDocumentFonts.`);\n            }\n\n            return ExtensionPreferencesManager.setSetting(extension.id, \"useDocumentFonts\", Number(details.value));\n          }\n        })\n      }\n    };\n  }\n\n}"}],"CONTAINER_PREF_INSTALL_DEFAULTS":[{"filepath":"toolkit/components/extensions/parent/ext-contextualIdentities.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const CONTAINER_PREF_INSTALL_DEFAULTS = {\n  \"privacy.userContext.enabled\": true,\n  \"privacy.userContext.longPressBehavior\": 2,\n  \"privacy.userContext.ui.enabled\": true,\n  \"privacy.usercontext.about_newtab_segregation.enabled\": true,\n  \"privacy.userContext.extension\": undefined\n};"}],"CONTAINERS_ENABLED_SETTING_NAME":[{"filepath":"toolkit/components/extensions/parent/ext-contextualIdentities.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const CONTAINERS_ENABLED_SETTING_NAME = \"privacy.containers\";"}],"CONTAINER_COLORS":[{"filepath":"toolkit/components/extensions/parent/ext-contextualIdentities.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const CONTAINER_COLORS = new Map([[\"blue\", \"#37adff\"], [\"turquoise\", \"#00c79a\"], [\"green\", \"#51cd00\"], [\"yellow\", \"#ffcb00\"], [\"orange\", \"#ff9f00\"], [\"red\", \"#ff613d\"], [\"pink\", \"#ff4bda\"], [\"purple\", \"#af51f5\"], [\"toolbar\", \"#7c7c7d\"]]);"}],"CONTAINER_ICONS":[{"filepath":"toolkit/components/extensions/parent/ext-contextualIdentities.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const CONTAINER_ICONS = new Set([\"briefcase\", \"cart\", \"circle\", \"dollar\", \"fence\", \"fingerprint\", \"gift\", \"vacation\", \"food\", \"fruit\", \"pet\", \"tree\", \"chill\"]);"}],"getContainerIcon":[{"filepath":"toolkit/components/extensions/parent/ext-contextualIdentities.js","kind":"function","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"function getContainerIcon(iconName) {\n  if (!CONTAINER_ICONS.has(iconName)) {\n    throw new ExtensionError(`Invalid icon ${iconName} for container`);\n  }\n\n  return `resource://usercontext-content/${iconName}.svg`;\n}"}],"getContainerColor":[{"filepath":"toolkit/components/extensions/parent/ext-contextualIdentities.js","kind":"function","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"function getContainerColor(colorName) {\n  if (!CONTAINER_COLORS.has(colorName)) {\n    throw new ExtensionError(`Invalid color name ${colorName} for container`);\n  }\n\n  return CONTAINER_COLORS.get(colorName);\n}"}],"convertIdentity":[{"filepath":"toolkit/components/extensions/parent/ext-contextualIdentities.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const convertIdentity = identity => {\n  let result = {\n    name: ContextualIdentityService.getUserContextLabel(identity.userContextId),\n    icon: identity.icon,\n    iconUrl: getContainerIcon(identity.icon),\n    color: identity.color,\n    colorCode: getContainerColor(identity.color),\n    cookieStoreId: getCookieStoreIdForContainer(identity.userContextId)\n  };\n  return result;\n};"}],"checkAPIEnabled":[{"filepath":"toolkit/components/extensions/parent/ext-contextualIdentities.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const checkAPIEnabled = () => {\n  if (!containersEnabled) {\n    throw new ExtensionError(\"Contextual identities are currently disabled\");\n  }\n};"}],"convertIdentityFromObserver":[{"filepath":"toolkit/components/extensions/parent/ext-contextualIdentities.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const convertIdentityFromObserver = wrappedIdentity => {\n  let identity = wrappedIdentity.wrappedJSObject;\n  let iconUrl, colorCode;\n\n  try {\n    iconUrl = getContainerIcon(identity.icon);\n    colorCode = getContainerColor(identity.color);\n  } catch (e) {\n    return null;\n  }\n\n  let result = {\n    name: identity.name,\n    icon: identity.icon,\n    iconUrl,\n    color: identity.color,\n    colorCode,\n    cookieStoreId: getCookieStoreIdForContainer(identity.userContextId)\n  };\n  return result;\n};"}],"contextualIdentities":[{"filepath":"toolkit/components/extensions/parent/ext-contextualIdentities.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.contextualIdentities = class extends ExtensionAPI {\n  onStartup() {\n    let {\n      extension\n    } = this;\n\n    if (extension.hasPermission(\"contextualIdentities\")) {\n      ExtensionPreferencesManager.setSetting(extension.id, CONTAINERS_ENABLED_SETTING_NAME, extension.id);\n    }\n  }\n\n  getAPI(context) {\n    let self = {\n      contextualIdentities: {\n        async get(cookieStoreId) {\n          checkAPIEnabled();\n          let containerId = getContainerForCookieStoreId(cookieStoreId);\n\n          if (!containerId) {\n            throw new ExtensionError(`Invalid contextual identity: ${cookieStoreId}`);\n          }\n\n          let identity = ContextualIdentityService.getPublicIdentityFromId(containerId);\n          return convertIdentity(identity);\n        },\n\n        async query(details) {\n          checkAPIEnabled();\n          let identities = [];\n          ContextualIdentityService.getPublicIdentities().forEach(identity => {\n            if (details.name && ContextualIdentityService.getUserContextLabel(identity.userContextId) != details.name) {\n              return;\n            }\n\n            identities.push(convertIdentity(identity));\n          });\n          return identities;\n        },\n\n        async create(details) {\n          getContainerIcon(details.icon);\n          getContainerColor(details.color);\n          let identity = ContextualIdentityService.create(details.name, details.icon, details.color);\n          return convertIdentity(identity);\n        },\n\n        async update(cookieStoreId, details) {\n          checkAPIEnabled();\n          let containerId = getContainerForCookieStoreId(cookieStoreId);\n\n          if (!containerId) {\n            throw new ExtensionError(`Invalid contextual identity: ${cookieStoreId}`);\n          }\n\n          let identity = ContextualIdentityService.getPublicIdentityFromId(containerId);\n\n          if (!identity) {\n            throw new ExtensionError(`Invalid contextual identity: ${cookieStoreId}`);\n          }\n\n          if (details.name !== null) {\n            identity.name = details.name;\n          }\n\n          if (details.color !== null) {\n            getContainerColor(details.color);\n            identity.color = details.color;\n          }\n\n          if (details.icon !== null) {\n            getContainerIcon(details.icon);\n            identity.icon = details.icon;\n          }\n\n          if (!ContextualIdentityService.update(identity.userContextId, identity.name, identity.icon, identity.color)) {\n            throw new ExtensionError(`Contextual identity failed to update: ${cookieStoreId}`);\n          }\n\n          return convertIdentity(identity);\n        },\n\n        async remove(cookieStoreId) {\n          checkAPIEnabled();\n          let containerId = getContainerForCookieStoreId(cookieStoreId);\n\n          if (!containerId) {\n            throw new ExtensionError(`Invalid contextual identity: ${cookieStoreId}`);\n          }\n\n          let identity = ContextualIdentityService.getPublicIdentityFromId(containerId);\n\n          if (!identity) {\n            throw new ExtensionError(`Invalid contextual identity: ${cookieStoreId}`);\n          }\n\n          let convertedIdentity = convertIdentity(identity);\n\n          if (!ContextualIdentityService.remove(identity.userContextId)) {\n            throw new ExtensionError(`Contextual identity failed to remove: ${cookieStoreId}`);\n          }\n\n          return convertedIdentity;\n        },\n\n        onCreated: new EventManager({\n          context,\n          name: \"contextualIdentities.onCreated\",\n          register: fire => {\n            let observer = (subject, topic) => {\n              let convertedIdentity = convertIdentityFromObserver(subject);\n\n              if (convertedIdentity) {\n                fire.async({\n                  contextualIdentity: convertedIdentity\n                });\n              }\n            };\n\n            Services.obs.addObserver(observer, \"contextual-identity-created\");\n            return () => {\n              Services.obs.removeObserver(observer, \"contextual-identity-created\");\n            };\n          }\n        }).api(),\n        onUpdated: new EventManager({\n          context,\n          name: \"contextualIdentities.onUpdated\",\n          register: fire => {\n            let observer = (subject, topic) => {\n              let convertedIdentity = convertIdentityFromObserver(subject);\n\n              if (convertedIdentity) {\n                fire.async({\n                  contextualIdentity: convertedIdentity\n                });\n              }\n            };\n\n            Services.obs.addObserver(observer, \"contextual-identity-updated\");\n            return () => {\n              Services.obs.removeObserver(observer, \"contextual-identity-updated\");\n            };\n          }\n        }).api(),\n        onRemoved: new EventManager({\n          context,\n          name: \"contextualIdentities.onRemoved\",\n          register: fire => {\n            let observer = (subject, topic) => {\n              let convertedIdentity = convertIdentityFromObserver(subject);\n\n              if (convertedIdentity) {\n                fire.async({\n                  contextualIdentity: convertedIdentity\n                });\n              }\n            };\n\n            Services.obs.addObserver(observer, \"contextual-identity-deleted\");\n            return () => {\n              Services.obs.removeObserver(observer, \"contextual-identity-deleted\");\n            };\n          }\n        }).api()\n      }\n    };\n    return self;\n  }\n\n}"}],"_":[{"filepath":"toolkit/components/extensions/parent/ext-management.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const _ = (key, ...args) => {\n  if (args.length) {\n    return strBundle.formatStringFromName(key, args);\n  }\n\n  return strBundle.GetStringFromName(key);\n};"}],"installType":[{"filepath":"toolkit/components/extensions/parent/ext-management.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const installType = addon => {\n  if (addon.temporarilyInstalled) {\n    return \"development\";\n  } else if (addon.foreignInstall) {\n    return \"sideload\";\n  } else if (addon.isSystem) {\n    return \"other\";\n  }\n\n  return \"normal\";\n};"}],"getExtensionInfoForAddon":[{"filepath":"toolkit/components/extensions/parent/ext-management.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const getExtensionInfoForAddon = (extension, addon) => {\n  let extInfo = {\n    id: addon.id,\n    name: addon.name,\n    description: addon.description || \"\",\n    version: addon.version,\n    mayDisable: !!(addon.permissions & AddonManager.PERM_CAN_DISABLE),\n    enabled: addon.isActive,\n    optionsUrl: addon.optionsURL || \"\",\n    installType: installType(addon),\n    type: addon.type\n  };\n\n  if (extension) {\n    let m = extension.manifest;\n    let hostPerms = extension.whiteListedHosts.patterns.map(matcher => matcher.pattern);\n    extInfo.permissions = Array.from(extension.permissions).filter(perm => {\n      return !hostPerms.includes(perm);\n    });\n    extInfo.hostPermissions = hostPerms;\n    extInfo.shortName = m.short_name || \"\";\n\n    if (m.icons) {\n      extInfo.icons = Object.keys(m.icons).map(key => {\n        return {\n          size: Number(key),\n          url: m.icons[key]\n        };\n      });\n    }\n  }\n\n  if (!addon.isActive) {\n    extInfo.disabledReason = \"unknown\";\n  }\n\n  if (addon.homepageURL) {\n    extInfo.homepageUrl = addon.homepageURL;\n  }\n\n  if (addon.updateURL) {\n    extInfo.updateUrl = addon.updateURL;\n  }\n\n  return extInfo;\n};"}],"listenerMap":[{"filepath":"toolkit/components/extensions/parent/ext-management.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const listenerMap = new WeakMap();"}],"allowedTypes":[{"filepath":"toolkit/components/extensions/parent/ext-management.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const allowedTypes = [\"theme\", \"extension\"];"}],"checkAllowedAddon":[{"filepath":"toolkit/components/extensions/parent/ext-management.js","kind":"function","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"function checkAllowedAddon(addon) {\n  if (addon.isSystem || addon.isAPIExtension) {\n    return false;\n  }\n\n  if (addon.type == \"extension\" && !addon.isWebExtension) {\n    return false;\n  }\n\n  return allowedTypes.includes(addon.type);\n}"}],"addonListener":[{"filepath":"toolkit/components/extensions/parent/ext-management.js","kind":"let","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"let addonListener;"}],"getManagementListener":[{"filepath":"toolkit/components/extensions/parent/ext-management.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const getManagementListener = (extension, context) => {\n  if (!listenerMap.has(extension)) {\n    if (!addonListener) {\n      addonListener = new AddonListener();\n    }\n\n    listenerMap.set(extension, {});\n    context.callOnClose({\n      close: () => {\n        listenerMap.delete(extension);\n\n        if (listenerMap.length === 0) {\n          addonListener.release();\n          addonListener = null;\n        }\n      }\n    });\n  }\n\n  return addonListener;\n};"}],"management":[{"filepath":"toolkit/components/extensions/parent/ext-management.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.management = class extends ExtensionAPI {\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    return {\n      management: {\n        async get(id) {\n          let addon = await AddonManager.getAddonByID(id);\n\n          if (!addon) {\n            throw new ExtensionError(`No such addon ${id}`);\n          }\n\n          if (!checkAllowedAddon(addon)) {\n            throw new ExtensionError(\"get not allowed for this addon\");\n          }\n\n          let ext = GlobalManager.extensionMap.get(addon.id);\n          return getExtensionInfoForAddon(ext, addon);\n        },\n\n        async getAll() {\n          let addons = await AddonManager.getAddonsByTypes(allowedTypes);\n          return addons.filter(checkAllowedAddon).map(addon => {\n            let ext = GlobalManager.extensionMap.get(addon.id);\n            return getExtensionInfoForAddon(ext, addon);\n          });\n        },\n\n        async install({\n          url,\n          hash\n        }) {\n          let listener = {\n            onDownloadEnded(install) {\n              if (install.addon.appDisabled || install.addon.type !== \"theme\") {\n                install.cancel();\n                return false;\n              }\n            }\n\n          };\n          let telemetryInfo = {\n            source: \"extension\",\n            method: \"management-webext-api\"\n          };\n          let install = await AddonManager.getInstallForURL(url, {\n            hash,\n            telemetryInfo,\n            triggeringPrincipal: extension.principal\n          });\n          install.addListener(listener);\n\n          try {\n            await install.install();\n          } catch (e) {\n            Cu.reportError(e);\n            throw new ExtensionError(\"Incompatible addon\");\n          }\n\n          await install.addon.enable();\n          return {\n            id: install.addon.id\n          };\n        },\n\n        async getSelf() {\n          let addon = await AddonManager.getAddonByID(extension.id);\n          return getExtensionInfoForAddon(extension, addon);\n        },\n\n        async uninstallSelf(options) {\n          if (options && options.showConfirmDialog) {\n            let message = _(\"uninstall.confirmation.message\", extension.name);\n\n            if (options.dialogMessage) {\n              message = `${options.dialogMessage}\\n${message}`;\n            }\n\n            let title = _(\"uninstall.confirmation.title\", extension.name);\n\n            let buttonFlags = promptService.BUTTON_POS_0 * promptService.BUTTON_TITLE_IS_STRING + promptService.BUTTON_POS_1 * promptService.BUTTON_TITLE_IS_STRING;\n\n            let button0Title = _(\"uninstall.confirmation.button-0.label\");\n\n            let button1Title = _(\"uninstall.confirmation.button-1.label\");\n\n            let response = promptService.confirmEx(null, title, message, buttonFlags, button0Title, button1Title, null, null, {\n              value: 0\n            });\n\n            if (response == 1) {\n              throw new ExtensionError(\"User cancelled uninstall of extension\");\n            }\n          }\n\n          let addon = await AddonManager.getAddonByID(extension.id);\n          let canUninstall = Boolean(addon.permissions & AddonManager.PERM_CAN_UNINSTALL);\n\n          if (!canUninstall) {\n            throw new ExtensionError(\"The add-on cannot be uninstalled\");\n          }\n\n          addon.uninstall();\n        },\n\n        async setEnabled(id, enabled) {\n          let addon = await AddonManager.getAddonByID(id);\n\n          if (!addon) {\n            throw new ExtensionError(`No such addon ${id}`);\n          }\n\n          if (addon.type !== \"theme\") {\n            throw new ExtensionError(\"setEnabled applies only to theme addons\");\n          }\n\n          if (addon.isSystem) {\n            throw new ExtensionError(\"setEnabled cannot be used with a system addon\");\n          }\n\n          if (enabled) {\n            await addon.enable();\n          } else {\n            await addon.disable();\n          }\n        },\n\n        onDisabled: new EventManager({\n          context,\n          name: \"management.onDisabled\",\n          register: fire => {\n            let listener = (event, data) => {\n              fire.async(data);\n            };\n\n            getManagementListener(extension, context).on(\"onDisabled\", listener);\n            return () => {\n              getManagementListener(extension, context).off(\"onDisabled\", listener);\n            };\n          }\n        }).api(),\n        onEnabled: new EventManager({\n          context,\n          name: \"management.onEnabled\",\n          register: fire => {\n            let listener = (event, data) => {\n              fire.async(data);\n            };\n\n            getManagementListener(extension, context).on(\"onEnabled\", listener);\n            return () => {\n              getManagementListener(extension, context).off(\"onEnabled\", listener);\n            };\n          }\n        }).api(),\n        onInstalled: new EventManager({\n          context,\n          name: \"management.onInstalled\",\n          register: fire => {\n            let listener = (event, data) => {\n              fire.async(data);\n            };\n\n            getManagementListener(extension, context).on(\"onInstalled\", listener);\n            return () => {\n              getManagementListener(extension, context).off(\"onInstalled\", listener);\n            };\n          }\n        }).api(),\n        onUninstalled: new EventManager({\n          context,\n          name: \"management.onUninstalled\",\n          register: fire => {\n            let listener = (event, data) => {\n              fire.async(data);\n            };\n\n            getManagementListener(extension, context).on(\"onUninstalled\", listener);\n            return () => {\n              getManagementListener(extension, context).off(\"onUninstalled\", listener);\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"cookieSvc":[{"filepath":"toolkit/components/extensions/parent/ext-privacy.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const cookieSvc = Ci.nsICookieService;"}],"cookieBehaviorValues":[{"filepath":"toolkit/components/extensions/parent/ext-privacy.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const cookieBehaviorValues = new Map([[\"allow_all\", cookieSvc.BEHAVIOR_ACCEPT], [\"reject_third_party\", cookieSvc.BEHAVIOR_REJECT_FOREIGN], [\"reject_all\", cookieSvc.BEHAVIOR_REJECT], [\"allow_visited\", cookieSvc.BEHAVIOR_LIMIT_FOREIGN], [\"reject_trackers\", cookieSvc.BEHAVIOR_REJECT_TRACKER]]);"}],"checkScope":[{"filepath":"toolkit/components/extensions/parent/ext-privacy.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const checkScope = scope => {\n  if (scope && scope !== \"regular\") {\n    throw new ExtensionError(`Firefox does not support the ${scope} settings scope.`);\n  }\n};"}],"getPrivacyAPI":[{"filepath":"toolkit/components/extensions/parent/ext-privacy.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const getPrivacyAPI = (extension, name, callback) => {\n  return {\n    async get(details) {\n      return {\n        levelOfControl: details.incognito ? \"not_controllable\" : await ExtensionPreferencesManager.getLevelOfControl(extension.id, name),\n        value: await callback()\n      };\n    },\n\n    set(details) {\n      checkScope(details.scope);\n      return ExtensionPreferencesManager.setSetting(extension.id, name, details.value);\n    },\n\n    clear(details) {\n      checkScope(details.scope);\n      return ExtensionPreferencesManager.removeSetting(extension.id, name);\n    }\n\n  };\n};"}],"privacy":[{"filepath":"toolkit/components/extensions/parent/ext-privacy.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.privacy = class extends ExtensionAPI {\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    return {\n      privacy: {\n        network: {\n          networkPredictionEnabled: getPrivacyAPI(extension, \"network.networkPredictionEnabled\", () => {\n            return Preferences.get(\"network.predictor.enabled\") && Preferences.get(\"network.prefetch-next\") && Preferences.get(\"network.http.speculative-parallel-limit\") > 0 && !Preferences.get(\"network.dns.disablePrefetch\");\n          }),\n          peerConnectionEnabled: getPrivacyAPI(extension, \"network.peerConnectionEnabled\", () => {\n            return Preferences.get(\"media.peerconnection.enabled\");\n          }),\n          webRTCIPHandlingPolicy: getPrivacyAPI(extension, \"network.webRTCIPHandlingPolicy\", () => {\n            if (Preferences.get(\"media.peerconnection.ice.proxy_only\")) {\n              return \"proxy_only\";\n            }\n\n            let default_address_only = Preferences.get(\"media.peerconnection.ice.default_address_only\");\n\n            if (default_address_only) {\n              let no_host = Preferences.get(\"media.peerconnection.ice.no_host\");\n\n              if (no_host) {\n                if (Preferences.get(\"media.peerconnection.ice.proxy_only_if_behind_proxy\")) {\n                  return \"disable_non_proxied_udp\";\n                }\n\n                return \"default_public_interface_only\";\n              }\n\n              return \"default_public_and_private_interfaces\";\n            }\n\n            return \"default\";\n          })\n        },\n        services: {\n          passwordSavingEnabled: getPrivacyAPI(extension, \"services.passwordSavingEnabled\", () => {\n            return Preferences.get(\"signon.rememberSignons\");\n          })\n        },\n        websites: {\n          cookieConfig: getPrivacyAPI(extension, \"websites.cookieConfig\", () => {\n            let prefValue = Preferences.get(\"network.cookie.cookieBehavior\");\n            return {\n              behavior: Array.from(cookieBehaviorValues.entries()).find(entry => entry[1] === prefValue)[0],\n              nonPersistentCookies: Preferences.get(\"network.cookie.lifetimePolicy\") === cookieSvc.ACCEPT_SESSION\n            };\n          }),\n          firstPartyIsolate: getPrivacyAPI(extension, \"websites.firstPartyIsolate\", () => {\n            return Preferences.get(\"privacy.firstparty.isolate\");\n          }),\n          hyperlinkAuditingEnabled: getPrivacyAPI(extension, \"websites.hyperlinkAuditingEnabled\", () => {\n            return Preferences.get(\"browser.send_pings\");\n          }),\n          referrersEnabled: getPrivacyAPI(extension, \"websites.referrersEnabled\", () => {\n            return Preferences.get(\"network.http.sendRefererHeader\") !== 0;\n          }),\n          resistFingerprinting: getPrivacyAPI(extension, \"websites.resistFingerprinting\", () => {\n            return Preferences.get(\"privacy.resistFingerprinting\");\n          }),\n          trackingProtectionMode: getPrivacyAPI(extension, \"websites.trackingProtectionMode\", () => {\n            if (Preferences.get(\"privacy.trackingprotection.enabled\")) {\n              return \"always\";\n            } else if (Preferences.get(\"privacy.trackingprotection.pbmode.enabled\")) {\n              return \"private_browsing\";\n            }\n\n            return \"never\";\n          })\n        }\n      }\n    };\n  }\n\n}"}],"proxySvc":[{"filepath":"toolkit/components/extensions/parent/ext-proxy.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const proxySvc = Ci.nsIProtocolProxyService;"}],"PROXY_TYPES_MAP":[{"filepath":"toolkit/components/extensions/parent/ext-proxy.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const PROXY_TYPES_MAP = new Map([[\"none\", proxySvc.PROXYCONFIG_DIRECT], [\"autoDetect\", proxySvc.PROXYCONFIG_WPAD], [\"system\", proxySvc.PROXYCONFIG_SYSTEM], [\"manual\", proxySvc.PROXYCONFIG_MANUAL], [\"autoConfig\", proxySvc.PROXYCONFIG_PAC]]);"}],"DEFAULT_PORTS":[{"filepath":"toolkit/components/extensions/parent/ext-proxy.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const DEFAULT_PORTS = new Map([[\"http\", 80], [\"ssl\", 443], [\"ftp\", 21], [\"socks\", 1080]]);"}],"registerProxyFilterEvent":[{"filepath":"toolkit/components/extensions/parent/ext-proxy.js","kind":"function","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"function registerProxyFilterEvent(context, extension, fire, filterProps, extraInfoSpec = []) {\n  let listener = data => {\n    return fire.sync(data);\n  };\n\n  let filter = { ...filterProps\n  };\n\n  if (filter.urls) {\n    let perms = new MatchPatternSet([...extension.whiteListedHosts.patterns, ...extension.optionalOrigins.patterns]);\n    filter.urls = new MatchPatternSet(filter.urls);\n\n    if (!perms.overlapsAll(filter.urls)) {\n      Cu.reportError(\"The proxy.onRequest filter doesn't overlap with host permissions.\");\n    }\n  }\n\n  let proxyFilter = new ProxyChannelFilter(context, extension, listener, filter, extraInfoSpec);\n  return {\n    unregister: () => {\n      proxyFilter.destroy();\n    },\n\n    convert(_fire, _context) {\n      fire = _fire;\n      proxyFilter.context = _context;\n    }\n\n  };\n}"}],"proxy":[{"filepath":"toolkit/components/extensions/parent/ext-proxy.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.proxy = class extends ExtensionAPI {\n  primeListener(extension, event, fire, params) {\n    if (event === \"onRequest\") {\n      return registerProxyFilterEvent(undefined, extension, fire, ...params);\n    }\n  }\n\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    return {\n      proxy: {\n        onRequest: new EventManager({\n          context,\n          name: `proxy.onRequest`,\n          persistent: {\n            module: \"proxy\",\n            event: \"onRequest\"\n          },\n          register: (fire, filter, info) => {\n            return registerProxyFilterEvent(context, context.extension, fire, filter, info).unregister;\n          }\n        }).api(),\n        onError: new EventManager({\n          context,\n          name: \"proxy.onError\",\n          register: fire => {\n            let listener = (name, error) => {\n              fire.async(error);\n            };\n\n            extension.on(\"proxy-error\", listener);\n            return () => {\n              extension.off(\"proxy-error\", listener);\n            };\n          }\n        }).api(),\n        settings: Object.assign(getSettingsAPI(extension.id, \"proxy.settings\", () => {\n          let prefValue = Services.prefs.getIntPref(\"network.proxy.type\");\n          let proxyConfig = {\n            proxyType: Array.from(PROXY_TYPES_MAP.entries()).find(entry => entry[1] === prefValue)[0],\n            autoConfigUrl: Services.prefs.getCharPref(\"network.proxy.autoconfig_url\"),\n            autoLogin: Services.prefs.getBoolPref(\"signon.autologin.proxy\"),\n            proxyDNS: Services.prefs.getBoolPref(\"network.proxy.socks_remote_dns\"),\n            httpProxyAll: Services.prefs.getBoolPref(\"network.proxy.share_proxy_settings\"),\n            socksVersion: Services.prefs.getIntPref(\"network.proxy.socks_version\"),\n            passthrough: Services.prefs.getCharPref(\"network.proxy.no_proxies_on\")\n          };\n\n          for (let prop of [\"http\", \"ftp\", \"ssl\", \"socks\"]) {\n            let host = Services.prefs.getCharPref(`network.proxy.${prop}`);\n            let port = Services.prefs.getIntPref(`network.proxy.${prop}_port`);\n            proxyConfig[prop] = port ? `${host}:${port}` : host;\n          }\n\n          return proxyConfig;\n        }, undefined, false, () => {\n          if (AppConstants.platform == \"android\") {\n            throw new ExtensionError(`proxy.settings is not supported on android.`);\n          }\n        }), {\n          set: details => {\n            if (AppConstants.platform === \"android\") {\n              throw new ExtensionError(\"proxy.settings is not supported on android.\");\n            }\n\n            if (!extension.privateBrowsingAllowed) {\n              throw new ExtensionError(\"proxy.settings requires private browsing permission.\");\n            }\n\n            if (!Services.policies.isAllowed(\"changeProxySettings\")) {\n              throw new ExtensionError(\"Proxy settings are being managed by the Policies manager.\");\n            }\n\n            let value = details.value;\n\n            if (value.proxyType == null) {\n              value.proxyType = \"system\";\n            }\n\n            if (!PROXY_TYPES_MAP.has(value.proxyType)) {\n              throw new ExtensionError(`${value.proxyType} is not a valid value for proxyType.`);\n            }\n\n            if (value.httpProxyAll) {\n              for (let prop of [\"ftp\", \"ssl\", \"socks\"]) {\n                value[prop] = value.http;\n              }\n            }\n\n            for (let prop of [\"http\", \"ftp\", \"ssl\", \"socks\"]) {\n              let host = value[prop];\n\n              if (host) {\n                try {\n                  if (host.includes(\"://\")) {\n                    value[prop] = new URL(host).host;\n                  } else {\n                    new URL(`http://${host}`);\n                  }\n                } catch (e) {\n                  throw new ExtensionError(`${value[prop]} is not a valid value for ${prop}.`);\n                }\n              }\n            }\n\n            if (value.proxyType === \"autoConfig\" || value.autoConfigUrl) {\n              try {\n                new URL(value.autoConfigUrl);\n              } catch (e) {\n                throw new ExtensionError(`${value.autoConfigUrl} is not a valid value for autoConfigUrl.`);\n              }\n            }\n\n            if (value.socksVersion !== undefined) {\n              if (!Number.isInteger(value.socksVersion) || value.socksVersion < 4 || value.socksVersion > 5) {\n                throw new ExtensionError(`${value.socksVersion} is not a valid value for socksVersion.`);\n              }\n            }\n\n            return ExtensionPreferencesManager.setSetting(extension.id, \"proxy.settings\", value);\n          }\n        })\n      }\n    };\n  }\n\n}"}],"getWinUtils":[{"filepath":"toolkit/components/extensions/parent/ext-theme.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  getWinUtils\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/parent/ext-tabs-base.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  DefaultMap,\n  DefaultWeakMap,\n  ExtensionError,\n  getWinUtils\n} = ExtensionUtils;"}],"onUpdatedEmitter":[{"filepath":"toolkit/components/extensions/parent/ext-theme.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const onUpdatedEmitter = new EventEmitter();"}],"emptyTheme":[{"filepath":"toolkit/components/extensions/parent/ext-theme.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const emptyTheme = {\n  details: {}\n};"}],"defaultTheme":[{"filepath":"toolkit/components/extensions/parent/ext-theme.js","kind":"let","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"let defaultTheme = emptyTheme;"}],"windowOverrides":[{"filepath":"toolkit/components/extensions/parent/ext-theme.js","kind":"let","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"let windowOverrides = new Map();"}],"theme":[{"filepath":"toolkit/components/extensions/parent/ext-theme.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.theme = class extends ExtensionAPI {\n  onManifestEntry(entryName) {\n    let {\n      extension\n    } = this;\n    let {\n      manifest\n    } = extension;\n    defaultTheme = new Theme({\n      extension,\n      details: manifest.theme,\n      darkDetails: manifest.dark_theme,\n      experiment: manifest.theme_experiment,\n      startupData: extension.startupData\n    });\n  }\n\n  onShutdown(isAppShutdown) {\n    if (isAppShutdown) {\n      return;\n    }\n\n    let {\n      extension\n    } = this;\n\n    for (let [windowId, theme] of windowOverrides) {\n      if (theme.extension === extension) {\n        Theme.unload(windowId);\n      }\n    }\n\n    if (defaultTheme.extension === extension) {\n      Theme.unload();\n    }\n  }\n\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    return {\n      theme: {\n        getCurrent: windowId => {\n          if (!windowId) {\n            windowId = windowTracker.getId(windowTracker.topWindow);\n          }\n\n          if (!windowTracker.getWindow(windowId, context)) {\n            return Promise.reject(`Invalid window ID: ${windowId}`);\n          }\n\n          if (windowOverrides.has(windowId)) {\n            return Promise.resolve(windowOverrides.get(windowId).details);\n          }\n\n          return Promise.resolve(defaultTheme.details);\n        },\n        update: (windowId, details) => {\n          if (windowId) {\n            const browserWindow = windowTracker.getWindow(windowId, context);\n\n            if (!browserWindow) {\n              return Promise.reject(`Invalid window ID: ${windowId}`);\n            }\n          }\n\n          new Theme({\n            extension,\n            details,\n            windowId,\n            experiment: this.extension.manifest.theme_experiment\n          });\n        },\n        reset: windowId => {\n          if (windowId) {\n            const browserWindow = windowTracker.getWindow(windowId, context);\n\n            if (!browserWindow) {\n              return Promise.reject(`Invalid window ID: ${windowId}`);\n            }\n          }\n\n          if (!defaultTheme && !windowOverrides.has(windowId)) {\n            return;\n          }\n\n          Theme.unload(windowId);\n        },\n        onUpdated: new EventManager({\n          context,\n          name: \"theme.onUpdated\",\n          register: fire => {\n            let callback = (event, theme, windowId) => {\n              if (windowId) {\n                if (windowTracker.getWindow(windowId, context, false)) {\n                  fire.async({\n                    theme,\n                    windowId\n                  });\n                }\n              } else {\n                fire.async({\n                  theme\n                });\n              }\n            };\n\n            onUpdatedEmitter.on(\"theme-updated\", callback);\n            return () => {\n              onUpdatedEmitter.off(\"theme-updated\", callback);\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"PlacesUtils":[{"filepath":"browser/components/extensions/parent/ext-bookmarks.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  PlacesUtils\n} = ChromeUtils.import(\"resource://gre/modules/PlacesUtils.jsm\");"},{"filepath":"browser/components/extensions/parent/ext-browsingData.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  PlacesUtils\n} = ChromeUtils.import(\"resource://gre/modules/PlacesUtils.jsm\");"},{"filepath":"browser/components/extensions/parent/ext-history.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  PlacesUtils\n} = ChromeUtils.import(\"resource://gre/modules/PlacesUtils.jsm\");"}],"TYPE_BOOKMARK":[{"filepath":"browser/components/extensions/parent/ext-bookmarks.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const {\n  TYPE_BOOKMARK,\n  TYPE_FOLDER,\n  TYPE_SEPARATOR\n} = PlacesUtils.bookmarks;"}],"TYPE_FOLDER":[{"filepath":"browser/components/extensions/parent/ext-bookmarks.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const {\n  TYPE_BOOKMARK,\n  TYPE_FOLDER,\n  TYPE_SEPARATOR\n} = PlacesUtils.bookmarks;"}],"TYPE_SEPARATOR":[{"filepath":"browser/components/extensions/parent/ext-bookmarks.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const {\n  TYPE_BOOKMARK,\n  TYPE_FOLDER,\n  TYPE_SEPARATOR\n} = PlacesUtils.bookmarks;"}],"BOOKMARKS_TYPES_TO_API_TYPES_MAP":[{"filepath":"browser/components/extensions/parent/ext-bookmarks.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const BOOKMARKS_TYPES_TO_API_TYPES_MAP = new Map([[TYPE_BOOKMARK, \"bookmark\"], [TYPE_FOLDER, \"folder\"], [TYPE_SEPARATOR, \"separator\"]]);"}],"BOOKMARK_SEPERATOR_URL":[{"filepath":"browser/components/extensions/parent/ext-bookmarks.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const BOOKMARK_SEPERATOR_URL = \"data:\";"}],"listenerCount":[{"filepath":"browser/components/extensions/parent/ext-bookmarks.js","kind":"let","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"let listenerCount = 0;"}],"getUrl":[{"filepath":"browser/components/extensions/parent/ext-bookmarks.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function getUrl(type, url) {\n  switch (type) {\n    case TYPE_BOOKMARK:\n      return url;\n\n    case TYPE_SEPARATOR:\n      return BOOKMARK_SEPERATOR_URL;\n\n    default:\n      return undefined;\n  }\n}"}],"getTree":[{"filepath":"browser/components/extensions/parent/ext-bookmarks.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const getTree = (rootGuid, onlyChildren) => {\n  function convert(node, parent) {\n    let treenode = {\n      id: node.guid,\n      title: PlacesUtils.bookmarks.getLocalizedTitle(node) || \"\",\n      index: node.index,\n      dateAdded: node.dateAdded / 1000,\n      type: BOOKMARKS_TYPES_TO_API_TYPES_MAP.get(node.typeCode),\n      url: getUrl(node.typeCode, node.uri)\n    };\n\n    if (parent && node.guid != PlacesUtils.bookmarks.rootGuid) {\n      treenode.parentId = parent.guid;\n    }\n\n    if (node.typeCode == TYPE_FOLDER) {\n      treenode.dateGroupModified = node.lastModified / 1000;\n\n      if (!onlyChildren) {\n        treenode.children = node.children ? node.children.map(child => convert(child, node)) : [];\n      }\n    }\n\n    return treenode;\n  }\n\n  return PlacesUtils.promiseBookmarksTree(rootGuid).then(root => {\n    if (onlyChildren) {\n      let children = root.children || [];\n      return children.map(child => convert(child, root));\n    }\n\n    let treenode = convert(root, null);\n    treenode.parentId = root.parentGuid;\n    return [treenode];\n  }).catch(e => Promise.reject({\n    message: e.message\n  }));\n};"}],"convertBookmarks":[{"filepath":"browser/components/extensions/parent/ext-bookmarks.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const convertBookmarks = result => {\n  let node = {\n    id: result.guid,\n    title: PlacesUtils.bookmarks.getLocalizedTitle(result) || \"\",\n    index: result.index,\n    dateAdded: result.dateAdded.getTime(),\n    type: BOOKMARKS_TYPES_TO_API_TYPES_MAP.get(result.type),\n    url: getUrl(result.type, result.url && result.url.href)\n  };\n\n  if (result.guid != PlacesUtils.bookmarks.rootGuid) {\n    node.parentId = result.parentGuid;\n  }\n\n  if (result.type == TYPE_FOLDER) {\n    node.dateGroupModified = result.lastModified.getTime();\n  }\n\n  return node;\n};"}],"throwIfRootId":[{"filepath":"browser/components/extensions/parent/ext-bookmarks.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const throwIfRootId = id => {\n  if (id == PlacesUtils.bookmarks.rootGuid) {\n    throw new ExtensionError(\"The bookmark root cannot be modified\");\n  }\n};"}],"observer":[{"filepath":"browser/components/extensions/parent/ext-bookmarks.js","kind":"let","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"let observer = new class extends EventEmitter {\n  constructor() {\n    super();\n    this.skipTags = true;\n    this.skipDescendantsOnItemRemoval = true;\n    this.handlePlacesEvents = this.handlePlacesEvents.bind(this);\n  }\n\n  onBeginUpdateBatch() {}\n\n  onEndUpdateBatch() {}\n\n  handlePlacesEvents(events) {\n    for (let event of events) {\n      if (event.isTagging) {\n        continue;\n      }\n\n      let bookmark = {\n        id: event.guid,\n        parentId: event.parentGuid,\n        index: event.index,\n        title: event.title,\n        dateAdded: event.dateAdded,\n        type: BOOKMARKS_TYPES_TO_API_TYPES_MAP.get(event.itemType),\n        url: getUrl(event.itemType, event.url)\n      };\n\n      if (event.itemType == TYPE_FOLDER) {\n        bookmark.dateGroupModified = bookmark.dateAdded;\n      }\n\n      this.emit(\"created\", bookmark);\n    }\n  }\n\n  onItemVisited() {}\n\n  onItemMoved(id, oldParentId, oldIndex, newParentId, newIndex, itemType, guid, oldParentGuid, newParentGuid, source) {\n    let info = {\n      parentId: newParentGuid,\n      index: newIndex,\n      oldParentId: oldParentGuid,\n      oldIndex\n    };\n    this.emit(\"moved\", {\n      guid,\n      info\n    });\n  }\n\n  onItemRemoved(id, parentId, index, itemType, uri, guid, parentGuid, source) {\n    let node = {\n      id: guid,\n      parentId: parentGuid,\n      index,\n      type: BOOKMARKS_TYPES_TO_API_TYPES_MAP.get(itemType),\n      url: getUrl(itemType, uri && uri.spec)\n    };\n    this.emit(\"removed\", {\n      guid,\n      info: {\n        parentId: parentGuid,\n        index,\n        node\n      }\n    });\n  }\n\n  onItemChanged(id, prop, isAnno, val, lastMod, itemType, parentId, guid, parentGuid, oldVal, source) {\n    let info = {};\n\n    if (prop == \"title\") {\n      info.title = val;\n    } else if (prop == \"uri\") {\n      info.url = val;\n    } else {\n      return;\n    }\n\n    this.emit(\"changed\", {\n      guid,\n      info\n    });\n  }\n\n}();"}],"decrementListeners":[{"filepath":"browser/components/extensions/parent/ext-bookmarks.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const decrementListeners = () => {\n  listenerCount -= 1;\n\n  if (!listenerCount) {\n    PlacesUtils.bookmarks.removeObserver(observer);\n    PlacesUtils.observers.removeListener([\"bookmark-added\"], observer.handlePlacesEvents);\n  }\n};"}],"incrementListeners":[{"filepath":"browser/components/extensions/parent/ext-bookmarks.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const incrementListeners = () => {\n  listenerCount++;\n\n  if (listenerCount == 1) {\n    PlacesUtils.bookmarks.addObserver(observer);\n    PlacesUtils.observers.addListener([\"bookmark-added\"], observer.handlePlacesEvents);\n  }\n};"}],"bookmarks":[{"filepath":"browser/components/extensions/parent/ext-bookmarks.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.bookmarks = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      bookmarks: {\n        async get(idOrIdList) {\n          let list = Array.isArray(idOrIdList) ? idOrIdList : [idOrIdList];\n\n          try {\n            let bookmarks = [];\n\n            for (let id of list) {\n              let bookmark = await PlacesUtils.bookmarks.fetch({\n                guid: id\n              });\n\n              if (!bookmark) {\n                throw new Error(\"Bookmark not found\");\n              }\n\n              bookmarks.push(convertBookmarks(bookmark));\n            }\n\n            return bookmarks;\n          } catch (error) {\n            return Promise.reject({\n              message: error.message\n            });\n          }\n        },\n\n        getChildren: function (id) {\n          return getTree(id, true);\n        },\n        getTree: function () {\n          return getTree(PlacesUtils.bookmarks.rootGuid, false);\n        },\n        getSubTree: function (id) {\n          return getTree(id, false);\n        },\n        search: function (query) {\n          return PlacesUtils.bookmarks.search(query).then(result => result.map(convertBookmarks));\n        },\n        getRecent: function (numberOfItems) {\n          return PlacesUtils.bookmarks.getRecent(numberOfItems).then(result => result.map(convertBookmarks));\n        },\n        create: function (bookmark) {\n          let info = {\n            title: bookmark.title || \"\"\n          };\n          info.type = API_TYPES_TO_BOOKMARKS_TYPES_MAP.get(bookmark.type);\n\n          if (!info.type) {\n            if (bookmark.url !== null) {\n              info.type = TYPE_BOOKMARK;\n            } else {\n              info.type = TYPE_FOLDER;\n            }\n          }\n\n          if (info.type === TYPE_BOOKMARK) {\n            info.url = bookmark.url || \"\";\n          }\n\n          if (bookmark.index !== null) {\n            info.index = bookmark.index;\n          }\n\n          if (bookmark.parentId !== null) {\n            throwIfRootId(bookmark.parentId);\n            info.parentGuid = bookmark.parentId;\n          } else {\n            info.parentGuid = PlacesUtils.bookmarks.unfiledGuid;\n          }\n\n          try {\n            return PlacesUtils.bookmarks.insert(info).then(convertBookmarks).catch(error => Promise.reject({\n              message: error.message\n            }));\n          } catch (e) {\n            return Promise.reject({\n              message: `Invalid bookmark: ${JSON.stringify(info)}`\n            });\n          }\n        },\n        move: function (id, destination) {\n          throwIfRootId(id);\n          let info = {\n            guid: id\n          };\n\n          if (destination.parentId !== null) {\n            throwIfRootId(destination.parentId);\n            info.parentGuid = destination.parentId;\n          }\n\n          info.index = destination.index === null ? PlacesUtils.bookmarks.DEFAULT_INDEX : destination.index;\n\n          try {\n            return PlacesUtils.bookmarks.update(info).then(convertBookmarks).catch(error => Promise.reject({\n              message: error.message\n            }));\n          } catch (e) {\n            return Promise.reject({\n              message: `Invalid bookmark: ${JSON.stringify(info)}`\n            });\n          }\n        },\n        update: function (id, changes) {\n          throwIfRootId(id);\n          let info = {\n            guid: id\n          };\n\n          if (changes.title !== null) {\n            info.title = changes.title;\n          }\n\n          if (changes.url !== null) {\n            info.url = changes.url;\n          }\n\n          try {\n            return PlacesUtils.bookmarks.update(info).then(convertBookmarks).catch(error => Promise.reject({\n              message: error.message\n            }));\n          } catch (e) {\n            return Promise.reject({\n              message: `Invalid bookmark: ${JSON.stringify(info)}`\n            });\n          }\n        },\n        remove: function (id) {\n          throwIfRootId(id);\n          let info = {\n            guid: id\n          };\n\n          try {\n            return PlacesUtils.bookmarks.remove(info, {\n              preventRemovalOfNonEmptyFolders: true\n            }).catch(error => Promise.reject({\n              message: error.message\n            }));\n          } catch (e) {\n            return Promise.reject({\n              message: `Invalid bookmark: ${JSON.stringify(info)}`\n            });\n          }\n        },\n        removeTree: function (id) {\n          throwIfRootId(id);\n          let info = {\n            guid: id\n          };\n\n          try {\n            return PlacesUtils.bookmarks.remove(info).catch(error => Promise.reject({\n              message: error.message\n            }));\n          } catch (e) {\n            return Promise.reject({\n              message: `Invalid bookmark: ${JSON.stringify(info)}`\n            });\n          }\n        },\n        onCreated: new EventManager({\n          context,\n          name: \"bookmarks.onCreated\",\n          register: fire => {\n            let listener = (event, bookmark) => {\n              fire.sync(bookmark.id, bookmark);\n            };\n\n            observer.on(\"created\", listener);\n            incrementListeners();\n            return () => {\n              observer.off(\"created\", listener);\n              decrementListeners();\n            };\n          }\n        }).api(),\n        onRemoved: new EventManager({\n          context,\n          name: \"bookmarks.onRemoved\",\n          register: fire => {\n            let listener = (event, data) => {\n              fire.sync(data.guid, data.info);\n            };\n\n            observer.on(\"removed\", listener);\n            incrementListeners();\n            return () => {\n              observer.off(\"removed\", listener);\n              decrementListeners();\n            };\n          }\n        }).api(),\n        onChanged: new EventManager({\n          context,\n          name: \"bookmarks.onChanged\",\n          register: fire => {\n            let listener = (event, data) => {\n              fire.sync(data.guid, data.info);\n            };\n\n            observer.on(\"changed\", listener);\n            incrementListeners();\n            return () => {\n              observer.off(\"changed\", listener);\n              decrementListeners();\n            };\n          }\n        }).api(),\n        onMoved: new EventManager({\n          context,\n          name: \"bookmarks.onMoved\",\n          register: fire => {\n            let listener = (event, data) => {\n              fire.sync(data.guid, data.info);\n            };\n\n            observer.on(\"moved\", listener);\n            incrementListeners();\n            return () => {\n              observer.off(\"moved\", listener);\n              decrementListeners();\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"YIELD_PERIOD":[{"filepath":"browser/components/extensions/parent/ext-browsingData.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const YIELD_PERIOD = 10;"}],"makeRange":[{"filepath":"browser/components/extensions/parent/ext-browsingData.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const makeRange = options => {\n  return options.since == null ? null : [PlacesUtils.toPRTime(options.since), PlacesUtils.toPRTime(Date.now())];\n};"}],"clearHistory":[{"filepath":"browser/components/extensions/parent/ext-browsingData.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const clearHistory = options => {\n  return Sanitizer.items.history.clear(makeRange(options));\n};"}],"clearIndexedDB":[{"filepath":"browser/components/extensions/parent/ext-browsingData.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const clearIndexedDB = async function (options) {\n  let promises = [];\n  await new Promise((resolve, reject) => {\n    quotaManagerService.getUsage(request => {\n      if (request.resultCode != Cr.NS_OK) {\n        reject({\n          message: \"Clear indexedDB failed\"\n        });\n        return;\n      }\n\n      for (let item of request.result) {\n        let principal = Services.scriptSecurityManager.createContentPrincipalFromOrigin(item.origin);\n\n        if (principal.schemeIs(\"http\") || principal.schemeIs(\"https\") || principal.schemeIs(\"file\")) {\n          promises.push(new Promise((resolve, reject) => {\n            let clearRequest = quotaManagerService.clearStoragesForPrincipal(principal, null, \"idb\");\n\n            clearRequest.callback = () => {\n              if (clearRequest.resultCode == Cr.NS_OK) {\n                resolve();\n              } else {\n                reject({\n                  message: \"Clear indexedDB failed\"\n                });\n              }\n            };\n          }));\n        }\n      }\n\n      resolve();\n    });\n  });\n  return Promise.all(promises);\n};"}],"clearLocalStorage":[{"filepath":"browser/components/extensions/parent/ext-browsingData.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const clearLocalStorage = async function (options) {\n  if (options.since) {\n    return Promise.reject({\n      message: \"Firefox does not support clearing localStorage with 'since'.\"\n    });\n  }\n\n  if (options.hostnames) {\n    for (let hostname of options.hostnames) {\n      Services.obs.notifyObservers(null, \"extension:purge-localStorage\", hostname);\n    }\n  } else {\n    Services.obs.notifyObservers(null, \"extension:purge-localStorage\");\n  }\n\n  if (Services.lsm.nextGenLocalStorageEnabled) {\n    let promises = [];\n    await new Promise((resolve, reject) => {\n      quotaManagerService.getUsage(request => {\n        if (request.resultCode != Cr.NS_OK) {\n          reject({\n            message: \"Clear localStorage failed\"\n          });\n          return;\n        }\n\n        for (let item of request.result) {\n          let principal = Services.scriptSecurityManager.createContentPrincipalFromOrigin(item.origin);\n          let host = principal.URI.hostPort;\n\n          if (!options.hostnames || options.hostnames.includes(host)) {\n            promises.push(new Promise((resolve, reject) => {\n              let clearRequest = quotaManagerService.clearStoragesForPrincipal(principal, \"default\", \"ls\");\n\n              clearRequest.callback = () => {\n                if (clearRequest.resultCode == Cr.NS_OK) {\n                  resolve();\n                } else {\n                  reject({\n                    message: \"Clear localStorage failed\"\n                  });\n                }\n              };\n            }));\n          }\n        }\n\n        resolve();\n      });\n    });\n    return Promise.all(promises);\n  }\n};"}],"clearPasswords":[{"filepath":"browser/components/extensions/parent/ext-browsingData.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const clearPasswords = async function (options) {\n  let loginManager = Services.logins;\n  let yieldCounter = 0;\n\n  if (options.since) {\n    let logins = loginManager.getAllLogins();\n\n    for (let login of logins) {\n      login.QueryInterface(Ci.nsILoginMetaInfo);\n\n      if (login.timePasswordChanged >= options.since) {\n        loginManager.removeLogin(login);\n\n        if (++yieldCounter % YIELD_PERIOD == 0) {\n          await new Promise(resolve => setTimeout(resolve, 0));\n        }\n      }\n    }\n  } else {\n    loginManager.removeAllLogins();\n  }\n};"}],"clearPluginData":[{"filepath":"browser/components/extensions/parent/ext-browsingData.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const clearPluginData = options => {\n  return Sanitizer.items.pluginData.clear(makeRange(options));\n};"}],"findResults":[{"filepath":"browser/components/extensions/parent/ext-find.js","kind":"let","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"let findResults = new WeakMap();"}],"getActorForBrowsingContext":[{"filepath":"browser/components/extensions/parent/ext-find.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function getActorForBrowsingContext(browsingContext) {\n  let windowGlobal = browsingContext.currentWindowGlobal;\n  return windowGlobal ? windowGlobal.getActor(\"ExtFind\") : null;\n}"}],"getTopLevelActor":[{"filepath":"browser/components/extensions/parent/ext-find.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function getTopLevelActor(browser) {\n  return getActorForBrowsingContext(browser.browsingContext);\n}"}],"gatherActors":[{"filepath":"browser/components/extensions/parent/ext-find.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function gatherActors(browsingContext) {\n  let list = [];\n  let actor = getActorForBrowsingContext(browsingContext);\n\n  if (actor) {\n    list.push({\n      actor,\n      result: null\n    });\n  }\n\n  let children = browsingContext.getChildren();\n\n  for (let child of children) {\n    list.push(...gatherActors(child));\n  }\n\n  return list;\n}"}],"mergeFindResults":[{"filepath":"browser/components/extensions/parent/ext-find.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function mergeFindResults(params, list) {\n  let finalResult = {\n    count: 0\n  };\n\n  if (params.includeRangeData) {\n    finalResult.rangeData = [];\n  }\n\n  if (params.includeRectData) {\n    finalResult.rectData = [];\n  }\n\n  let currentFramePos = -1;\n\n  for (let item of list) {\n    if (item.result.count == 0) {\n      continue;\n    }\n\n    currentFramePos++;\n    finalResult.count += item.result.count;\n\n    if (params.includeRangeData && item.result.rangeData) {\n      for (let range of item.result.rangeData) {\n        range.framePos = currentFramePos;\n      }\n\n      finalResult.rangeData.push(...item.result.rangeData);\n    }\n\n    if (params.includeRectData && item.result.rectData) {\n      finalResult.rectData.push(...item.result.rectData);\n    }\n  }\n\n  return finalResult;\n}"}],"sendMessageToAllActors":[{"filepath":"browser/components/extensions/parent/ext-find.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function sendMessageToAllActors(browser, message, params) {\n  for (let {\n    actor\n  } of gatherActors(browser.browsingContext)) {\n    actor.sendAsyncMessage(\"ext-Finder:\" + message, params);\n  }\n}"}],"getFindResultsForActor":[{"filepath":"browser/components/extensions/parent/ext-find.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"async function getFindResultsForActor(findContext, message, params) {\n  findContext.result = await findContext.actor.sendQuery(\"ext-Finder:\" + message, params);\n  return findContext;\n}"}],"queryAllActors":[{"filepath":"browser/components/extensions/parent/ext-find.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function queryAllActors(browser, message, params) {\n  let promises = [];\n\n  for (let findContext of gatherActors(browser.browsingContext)) {\n    promises.push(getFindResultsForActor(findContext, message, params));\n  }\n\n  return Promise.all(promises);\n}"}],"collectFindResults":[{"filepath":"browser/components/extensions/parent/ext-find.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"async function collectFindResults(browser, findResults, params) {\n  let results = await queryAllActors(browser, \"CollectResults\", params);\n  findResults.set(getTopLevelActor(browser), results);\n  return mergeFindResults(params, results);\n}"}],"runHighlight":[{"filepath":"browser/components/extensions/parent/ext-find.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"async function runHighlight(browser, params) {\n  let hasResults = false;\n  let foundResults = false;\n  let list = findResults.get(getTopLevelActor(browser));\n\n  if (!list) {\n    return Promise.reject({\n      message: \"no search results to highlight\"\n    });\n  }\n\n  let highlightPromises = [];\n  let index = params.rangeIndex;\n\n  for (let c = 0; c < list.length; c++) {\n    if (list[c].result.count) {\n      hasResults = true;\n    }\n\n    let actor = list[c].actor;\n\n    if (!foundResults && index < list[c].result.count) {\n      foundResults = true;\n      params.rangeIndex = index;\n      highlightPromises.push(actor.sendQuery(\"ext-Finder:HighlightResults\", params));\n    } else {\n      highlightPromises.push(actor.sendQuery(\"ext-Finder:ClearHighlighting\", params));\n    }\n\n    index -= list[c].result.count;\n  }\n\n  let responses = await Promise.all(highlightPromises);\n\n  if (hasResults) {\n    if (responses.includes(\"OutOfRange\") || index >= 0) {\n      return Promise.reject({\n        message: \"index supplied was out of range\"\n      });\n    } else if (responses.includes(\"Success\")) {\n      return;\n    }\n  }\n\n  return Promise.reject({\n    message: \"no search results to highlight\"\n  });\n}"}],"runFindOperation":[{"filepath":"browser/components/extensions/parent/ext-find.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function runFindOperation(context, params, message) {\n  let {\n    tabId\n  } = params;\n  let tab = tabId ? tabTracker.getTab(tabId) : tabTracker.activeTab;\n  let browser = tab.linkedBrowser;\n  tabId = tabId || tabTracker.getId(tab);\n\n  if (!context.privateBrowsingAllowed && PrivateBrowsingUtils.isBrowserPrivate(browser)) {\n    return Promise.reject({\n      message: `Unable to search: ${tabId}`\n    });\n  }\n\n  if (tab.linkedBrowser.contentPrincipal.isSystemPrincipal || [\"about\", \"chrome\", \"resource\"].includes(tab.linkedBrowser.currentURI.scheme) && tab.linkedBrowser.currentURI.spec != \"about:blank\") {\n    return Promise.reject({\n      message: `Unable to search: ${tabId}`\n    });\n  }\n\n  if (message == \"HighlightResults\") {\n    return runHighlight(browser, params);\n  } else if (message == \"CollectResults\") {\n    findResults.delete(getTopLevelActor(browser));\n    return collectFindResults(browser, findResults, params);\n  }\n}"}],"find":[{"filepath":"browser/components/extensions/parent/ext-find.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.find = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      find: {\n        find(queryphrase, params) {\n          params = params || {};\n          params.queryphrase = queryphrase;\n          return runFindOperation(context, params, \"CollectResults\");\n        },\n\n        highlightResults(params) {\n          params = params || {};\n          return runFindOperation(context, params, \"HighlightResults\");\n        },\n\n        removeHighlighting(tabId) {\n          let tab = tabId ? tabTracker.getTab(tabId) : tabTracker.activeTab;\n\n          if (!context.privateBrowsingAllowed && PrivateBrowsingUtils.isBrowserPrivate(tab.linkedBrowser)) {\n            throw new ExtensionError(`Invalid tab ID: ${tabId}`);\n          }\n\n          sendMessageToAllActors(tab.linkedBrowser, \"ClearHighlighting\", {});\n        }\n\n      }\n    };\n  }\n\n}"}],"watchExtensionProxyContextLoad":[{"filepath":"browser/components/extensions/parent/ext-devtools.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  HiddenExtensionPage,\n  watchExtensionProxyContextLoad\n} = ExtensionParent;"},{"filepath":"browser/components/extensions/parent/ext-devtools-panels.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  IconDetails,\n  watchExtensionProxyContextLoad\n} = ExtensionParent;"}],"getDevToolsPrefBranchName":[{"filepath":"browser/components/extensions/parent/ext-devtools.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function getDevToolsPrefBranchName(extensionId) {\n  return `devtools.webextensions.${extensionId}`;\n}"}],"StartupCache":[{"filepath":"browser/components/extensions/parent/ext-pageAction.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  IconDetails,\n  StartupCache\n} = ExtensionParent;"},{"filepath":"browser/components/extensions/parent/ext-browserAction.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  IconDetails,\n  StartupCache\n} = ExtensionParent;"}],"DefaultWeakMap":[{"filepath":"browser/components/extensions/parent/ext-pageAction.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  DefaultWeakMap\n} = ExtensionUtils;"},{"filepath":"mobile/android/components/extensions/ext-utils.js","kind":"var","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"var {\n  DefaultWeakMap,\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"browser/components/extensions/parent/ext-browserAction.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  DefaultWeakMap,\n  ExtensionError\n} = ExtensionUtils;"},{"filepath":"toolkit/components/extensions/parent/ext-tabs-base.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  DefaultMap,\n  DefaultWeakMap,\n  ExtensionError,\n  getWinUtils\n} = ExtensionUtils;"}],"normalizeTime":[{"filepath":"browser/components/extensions/parent/ext-history.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  normalizeTime\n} = ExtensionCommon;"}],"nsINavHistoryService":[{"filepath":"browser/components/extensions/parent/ext-history.js","kind":"let","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"let nsINavHistoryService = Ci.nsINavHistoryService;"}],"TRANSITION_TO_TRANSITION_TYPES_MAP":[{"filepath":"browser/components/extensions/parent/ext-history.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const TRANSITION_TO_TRANSITION_TYPES_MAP = new Map([[\"link\", nsINavHistoryService.TRANSITION_LINK], [\"typed\", nsINavHistoryService.TRANSITION_TYPED], [\"auto_bookmark\", nsINavHistoryService.TRANSITION_BOOKMARK], [\"auto_subframe\", nsINavHistoryService.TRANSITION_EMBED], [\"manual_subframe\", nsINavHistoryService.TRANSITION_FRAMED_LINK], [\"reload\", nsINavHistoryService.TRANSITION_RELOAD]]);"}],"TRANSITION_TYPE_TO_TRANSITIONS_MAP":[{"filepath":"browser/components/extensions/parent/ext-history.js","kind":"let","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"let TRANSITION_TYPE_TO_TRANSITIONS_MAP = new Map();"}],"getTransitionType":[{"filepath":"browser/components/extensions/parent/ext-history.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const getTransitionType = transition => {\n  transition = transition || \"link\";\n  let transitionType = TRANSITION_TO_TRANSITION_TYPES_MAP.get(transition);\n\n  if (!transitionType) {\n    throw new Error(`|${transition}| is not a supported transition for history`);\n  }\n\n  return transitionType;\n};"}],"getTransition":[{"filepath":"browser/components/extensions/parent/ext-history.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const getTransition = transitionType => {\n  return TRANSITION_TYPE_TO_TRANSITIONS_MAP.get(transitionType) || \"link\";\n};"}],"convertNodeToHistoryItem":[{"filepath":"browser/components/extensions/parent/ext-history.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const convertNodeToHistoryItem = node => {\n  return {\n    id: node.pageGuid,\n    url: node.uri,\n    title: node.title,\n    lastVisitTime: PlacesUtils.toDate(node.time).getTime(),\n    visitCount: node.accessCount\n  };\n};"}],"convertNodeToVisitItem":[{"filepath":"browser/components/extensions/parent/ext-history.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const convertNodeToVisitItem = node => {\n  return {\n    id: node.pageGuid,\n    visitId: String(node.visitId),\n    visitTime: PlacesUtils.toDate(node.time).getTime(),\n    referringVisitId: String(node.fromVisitId),\n    transition: getTransition(node.visitType)\n  };\n};"}],"convertNavHistoryContainerResultNode":[{"filepath":"browser/components/extensions/parent/ext-history.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const convertNavHistoryContainerResultNode = (container, converter) => {\n  let results = [];\n  container.containerOpen = true;\n\n  for (let i = 0; i < container.childCount; i++) {\n    let node = container.getChild(i);\n    results.push(converter(node));\n  }\n\n  container.containerOpen = false;\n  return results;\n};"}],"_observer":[{"filepath":"browser/components/extensions/parent/ext-history.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var _observer;"}],"getHistoryObserver":[{"filepath":"browser/components/extensions/parent/ext-history.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const getHistoryObserver = () => {\n  if (!_observer) {\n    _observer = new class extends EventEmitter {\n      onDeleteURI(uri, guid, reason) {\n        this.emit(\"visitRemoved\", {\n          allHistory: false,\n          urls: [uri.spec]\n        });\n      }\n\n      handlePlacesEvents(events) {\n        for (let event of events) {\n          let visit = {\n            id: event.pageGuid,\n            url: event.url,\n            title: event.lastKnownTitle || \"\",\n            lastVisitTime: event.visitTime,\n            visitCount: event.visitCount,\n            typedCount: event.typedCount\n          };\n          this.emit(\"visited\", visit);\n        }\n      }\n\n      onBeginUpdateBatch() {}\n\n      onEndUpdateBatch() {}\n\n      onTitleChanged(uri, title) {\n        this.emit(\"titleChanged\", {\n          url: uri.spec,\n          title: title\n        });\n      }\n\n      onClearHistory() {\n        this.emit(\"visitRemoved\", {\n          allHistory: true,\n          urls: []\n        });\n      }\n\n      onPageChanged() {}\n\n      onFrecencyChanged() {}\n\n      onManyFrecenciesChanged() {}\n\n      onDeleteVisits(uri, partialRemoval, guid, reason) {\n        if (!partialRemoval) {\n          this.emit(\"visitRemoved\", {\n            allHistory: false,\n            urls: [uri.spec]\n          });\n        }\n      }\n\n    }();\n    PlacesUtils.observers.addListener([\"page-visited\"], _observer.handlePlacesEvents.bind(_observer));\n    PlacesUtils.history.addObserver(_observer);\n  }\n\n  return _observer;\n};"}],"history":[{"filepath":"browser/components/extensions/parent/ext-history.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.history = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      history: {\n        addUrl: function (details) {\n          let transition, date;\n\n          try {\n            transition = getTransitionType(details.transition);\n          } catch (error) {\n            return Promise.reject({\n              message: error.message\n            });\n          }\n\n          if (details.visitTime) {\n            date = normalizeTime(details.visitTime);\n          }\n\n          let pageInfo = {\n            title: details.title,\n            url: details.url,\n            visits: [{\n              transition,\n              date\n            }]\n          };\n\n          try {\n            return PlacesUtils.history.insert(pageInfo).then(() => undefined);\n          } catch (error) {\n            return Promise.reject({\n              message: error.message\n            });\n          }\n        },\n        deleteAll: function () {\n          return PlacesUtils.history.clear();\n        },\n        deleteRange: function (filter) {\n          let newFilter = {\n            beginDate: normalizeTime(filter.startTime),\n            endDate: normalizeTime(filter.endTime)\n          };\n          return PlacesUtils.history.removeVisitsByFilter(newFilter).then(() => undefined);\n        },\n        deleteUrl: function (details) {\n          let url = details.url;\n          return PlacesUtils.history.remove(url).then(() => undefined);\n        },\n        search: function (query) {\n          let beginTime = query.startTime == null ? PlacesUtils.toPRTime(Date.now() - 24 * 60 * 60 * 1000) : PlacesUtils.toPRTime(normalizeTime(query.startTime));\n          let endTime = query.endTime == null ? Number.MAX_VALUE : PlacesUtils.toPRTime(normalizeTime(query.endTime));\n\n          if (beginTime > endTime) {\n            return Promise.reject({\n              message: \"The startTime cannot be after the endTime\"\n            });\n          }\n\n          let options = PlacesUtils.history.getNewQueryOptions();\n          options.includeHidden = true;\n          options.sortingMode = options.SORT_BY_DATE_DESCENDING;\n          options.maxResults = query.maxResults || 100;\n          let historyQuery = PlacesUtils.history.getNewQuery();\n          historyQuery.searchTerms = query.text;\n          historyQuery.beginTime = beginTime;\n          historyQuery.endTime = endTime;\n          let queryResult = PlacesUtils.history.executeQuery(historyQuery, options).root;\n          let results = convertNavHistoryContainerResultNode(queryResult, convertNodeToHistoryItem);\n          return Promise.resolve(results);\n        },\n        getVisits: function (details) {\n          let url = details.url;\n\n          if (!url) {\n            return Promise.reject({\n              message: \"A URL must be provided for getVisits\"\n            });\n          }\n\n          let options = PlacesUtils.history.getNewQueryOptions();\n          options.includeHidden = true;\n          options.sortingMode = options.SORT_BY_DATE_DESCENDING;\n          options.resultType = options.RESULTS_AS_VISIT;\n          let historyQuery = PlacesUtils.history.getNewQuery();\n          historyQuery.uri = Services.io.newURI(url);\n          let queryResult = PlacesUtils.history.executeQuery(historyQuery, options).root;\n          let results = convertNavHistoryContainerResultNode(queryResult, convertNodeToVisitItem);\n          return Promise.resolve(results);\n        },\n        onVisited: new EventManager({\n          context,\n          name: \"history.onVisited\",\n          register: fire => {\n            let listener = (event, data) => {\n              fire.sync(data);\n            };\n\n            getHistoryObserver().on(\"visited\", listener);\n            return () => {\n              getHistoryObserver().off(\"visited\", listener);\n            };\n          }\n        }).api(),\n        onVisitRemoved: new EventManager({\n          context,\n          name: \"history.onVisitRemoved\",\n          register: fire => {\n            let listener = (event, data) => {\n              fire.sync(data);\n            };\n\n            getHistoryObserver().on(\"visitRemoved\", listener);\n            return () => {\n              getHistoryObserver().off(\"visitRemoved\", listener);\n            };\n          }\n        }).api(),\n        onTitleChanged: new EventManager({\n          context,\n          name: \"history.onTitleChanged\",\n          register: fire => {\n            let listener = (event, data) => {\n              fire.sync(data);\n            };\n\n            getHistoryObserver().on(\"titleChanged\", listener);\n            return () => {\n              getHistoryObserver().off(\"titleChanged\", listener);\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"sidebarActionMap":[{"filepath":"browser/components/extensions/parent/ext-sidebarAction.js","kind":"let","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"let sidebarActionMap = new WeakMap();"}],"sidebarURL":[{"filepath":"browser/components/extensions/parent/ext-sidebarAction.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const sidebarURL = \"chrome://browser/content/webext-panels.xul\";"}],"sidebarAction":[{"filepath":"browser/components/extensions/parent/ext-sidebarAction.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.sidebarAction = class extends ExtensionAPI {\n  static for(extension) {\n    return sidebarActionMap.get(extension);\n  }\n\n  onManifestEntry(entryName) {\n    let {\n      extension\n    } = this;\n    extension.once(\"ready\", this.onReady.bind(this));\n    let options = extension.manifest.sidebar_action;\n    let widgetId = makeWidgetId(extension.id);\n    this.id = `${widgetId}-sidebar-action`;\n    this.menuId = `menu_${this.id}`;\n    this.buttonId = `button_${this.id}`;\n    this.browserStyle = options.browser_style;\n    this.defaults = {\n      enabled: true,\n      title: options.default_title || extension.name,\n      icon: IconDetails.normalize({\n        path: options.default_icon\n      }, extension),\n      panel: options.default_panel || \"\"\n    };\n    this.globals = Object.create(this.defaults);\n    this.tabContext = new TabContext(target => {\n      let window = target.ownerGlobal;\n\n      if (target === window) {\n        return this.globals;\n      }\n\n      return this.tabContext.get(window);\n    });\n\n    this.windowOpenListener = window => {\n      this.createMenuItem(window, this.globals);\n    };\n\n    windowTracker.addOpenListener(this.windowOpenListener);\n\n    this.updateHeader = event => {\n      let window = event.target.ownerGlobal;\n      let details = this.tabContext.get(window.gBrowser.selectedTab);\n      let header = window.document.getElementById(\"sidebar-switcher-target\");\n\n      if (window.SidebarUI.currentID === this.id) {\n        this.setMenuIcon(header, details);\n      }\n    };\n\n    this.windowCloseListener = window => {\n      let header = window.document.getElementById(\"sidebar-switcher-target\");\n\n      if (header) {\n        header.removeEventListener(\"SidebarShown\", this.updateHeader);\n      }\n    };\n\n    windowTracker.addCloseListener(this.windowCloseListener);\n    sidebarActionMap.set(extension, this);\n  }\n\n  onReady() {\n    this.build();\n  }\n\n  onShutdown(isAppShutdown) {\n    sidebarActionMap.delete(this.this);\n    this.tabContext.shutdown();\n\n    if (isAppShutdown) {\n      return;\n    }\n\n    for (let window of windowTracker.browserWindows()) {\n      let {\n        document,\n        SidebarUI\n      } = window;\n\n      if (SidebarUI.currentID === this.id) {\n        SidebarUI.hide();\n      }\n\n      let menu = document.getElementById(this.menuId);\n\n      if (menu) {\n        menu.remove();\n      }\n\n      let button = document.getElementById(this.buttonId);\n\n      if (button) {\n        button.remove();\n      }\n\n      let header = document.getElementById(\"sidebar-switcher-target\");\n      header.removeEventListener(\"SidebarShown\", this.updateHeader);\n      SidebarUI.sidebars.delete(this.id);\n    }\n\n    windowTracker.removeOpenListener(this.windowOpenListener);\n    windowTracker.removeCloseListener(this.windowCloseListener);\n  }\n\n  static onUninstall(id) {\n    const sidebarId = `${makeWidgetId(id)}-sidebar-action`;\n\n    for (let window of windowTracker.browserWindows()) {\n      let {\n        SidebarUI\n      } = window;\n\n      if (SidebarUI.lastOpenedId === sidebarId) {\n        SidebarUI.lastOpenedId = null;\n      }\n    }\n  }\n\n  build() {\n    this.tabContext.on(\"tab-select\", (evt, tab) => {\n      this.updateWindow(tab.ownerGlobal);\n    });\n    let install = this.extension.startupReason === \"ADDON_INSTALL\";\n\n    for (let window of windowTracker.browserWindows()) {\n      this.updateWindow(window);\n      let {\n        SidebarUI\n      } = window;\n\n      if (install && this.extension.manifest.sidebar_action.open_at_install || SidebarUI.lastOpenedId == this.id) {\n        SidebarUI.show(this.id);\n      }\n    }\n  }\n\n  createMenuItem(window, details) {\n    if (!this.extension.canAccessWindow(window)) {\n      return;\n    }\n\n    let {\n      document,\n      SidebarUI\n    } = window;\n    let keyId = `ext-key-id-${this.id}`;\n    SidebarUI.sidebars.set(this.id, {\n      title: details.title,\n      url: sidebarURL,\n      menuId: this.menuId,\n      buttonId: this.buttonId,\n      extensionId: this.extension.id,\n      panel: details.panel,\n      browserStyle: this.browserStyle\n    });\n    let header = document.getElementById(\"sidebar-switcher-target\");\n    header.addEventListener(\"SidebarShown\", this.updateHeader);\n    let menuitem = document.createXULElement(\"menuitem\");\n    menuitem.setAttribute(\"id\", this.menuId);\n    menuitem.setAttribute(\"type\", \"checkbox\");\n    menuitem.setAttribute(\"label\", details.title);\n    menuitem.setAttribute(\"oncommand\", `SidebarUI.toggle(\"${this.id}\");`);\n    menuitem.setAttribute(\"class\", \"menuitem-iconic webextension-menuitem\");\n    menuitem.setAttribute(\"key\", keyId);\n    this.setMenuIcon(menuitem, details);\n    let toolbarbutton = document.createXULElement(\"toolbarbutton\");\n    toolbarbutton.setAttribute(\"id\", this.buttonId);\n    toolbarbutton.setAttribute(\"type\", \"checkbox\");\n    toolbarbutton.setAttribute(\"label\", details.title);\n    toolbarbutton.setAttribute(\"oncommand\", `SidebarUI.show(\"${this.id}\");`);\n    toolbarbutton.setAttribute(\"class\", \"subviewbutton subviewbutton-iconic webextension-menuitem\");\n    toolbarbutton.setAttribute(\"key\", keyId);\n    this.setMenuIcon(toolbarbutton, details);\n    document.getElementById(\"viewSidebarMenu\").appendChild(menuitem);\n    let separator = document.getElementById(\"sidebar-extensions-separator\");\n    separator.parentNode.insertBefore(toolbarbutton, separator);\n    SidebarUI.updateShortcut({\n      button: toolbarbutton\n    });\n    return menuitem;\n  }\n\n  setMenuIcon(menuitem, details) {\n    let getIcon = size => IconDetails.escapeUrl(IconDetails.getPreferredIcon(details.icon, this.extension, size).icon);\n\n    menuitem.setAttribute(\"style\", `\n      --webextension-menuitem-image: url(\"${getIcon(16)}\");\n      --webextension-menuitem-image-2x: url(\"${getIcon(32)}\");\n    `);\n  }\n\n  updateButton(window, tabData) {\n    let {\n      document,\n      SidebarUI\n    } = window;\n    let title = tabData.title || this.extension.name;\n    let menu = document.getElementById(this.menuId);\n\n    if (!menu) {\n      menu = this.createMenuItem(window, tabData);\n    }\n\n    let urlChanged = tabData.panel !== SidebarUI.sidebars.get(this.id).panel;\n\n    if (urlChanged) {\n      SidebarUI.sidebars.get(this.id).panel = tabData.panel;\n    }\n\n    menu.setAttribute(\"label\", title);\n    this.setMenuIcon(menu, tabData);\n    let button = document.getElementById(this.buttonId);\n    button.setAttribute(\"label\", title);\n    this.setMenuIcon(button, tabData);\n\n    if (SidebarUI.currentID === this.id) {\n      SidebarUI.title = title;\n      let header = document.getElementById(\"sidebar-switcher-target\");\n      this.setMenuIcon(header, tabData);\n\n      if (SidebarUI.isOpen && urlChanged) {\n        SidebarUI.show(this.id);\n      }\n    }\n  }\n\n  updateWindow(window) {\n    if (!this.extension.canAccessWindow(window)) {\n      return;\n    }\n\n    let nativeTab = window.gBrowser.selectedTab;\n    this.updateButton(window, this.tabContext.get(nativeTab));\n  }\n\n  updateOnChange(target) {\n    if (target) {\n      let window = target.ownerGlobal;\n\n      if (target === window || target.selected) {\n        this.updateWindow(window);\n      }\n    } else {\n      for (let window of windowTracker.browserWindows()) {\n        this.updateWindow(window);\n      }\n    }\n  }\n\n  getTargetFromDetails({\n    tabId,\n    windowId\n  }) {\n    if (tabId != null && windowId != null) {\n      throw new ExtensionError(\"Only one of tabId and windowId can be specified.\");\n    }\n\n    let target = null;\n\n    if (tabId != null) {\n      target = tabTracker.getTab(tabId);\n\n      if (!this.extension.canAccessWindow(target.ownerGlobal)) {\n        throw new ExtensionError(`Invalid tab ID: ${tabId}`);\n      }\n    } else if (windowId != null) {\n      target = windowTracker.getWindow(windowId);\n\n      if (!this.extension.canAccessWindow(target)) {\n        throw new ExtensionError(`Invalid window ID: ${windowId}`);\n      }\n    }\n\n    return target;\n  }\n\n  getContextData(target) {\n    if (target) {\n      return this.tabContext.get(target);\n    }\n\n    return this.globals;\n  }\n\n  setProperty(target, prop, value) {\n    let values = this.getContextData(target);\n\n    if (value === null) {\n      delete values[prop];\n    } else {\n      values[prop] = value;\n    }\n\n    this.updateOnChange(target);\n  }\n\n  getProperty(target, prop) {\n    return this.getContextData(target)[prop];\n  }\n\n  setPropertyFromDetails(details, prop, value) {\n    return this.setProperty(this.getTargetFromDetails(details), prop, value);\n  }\n\n  getPropertyFromDetails(details, prop) {\n    return this.getProperty(this.getTargetFromDetails(details), prop);\n  }\n\n  triggerAction(window) {\n    let {\n      SidebarUI\n    } = window;\n\n    if (SidebarUI && this.extension.canAccessWindow(window)) {\n      SidebarUI.toggle(this.id);\n    }\n  }\n\n  open(window) {\n    let {\n      SidebarUI\n    } = window;\n\n    if (SidebarUI && this.extension.canAccessWindow(window)) {\n      SidebarUI.show(this.id);\n    }\n  }\n\n  close(window) {\n    if (this.isOpen(window)) {\n      window.SidebarUI.hide();\n    }\n  }\n\n  isOpen(window) {\n    let {\n      SidebarUI\n    } = window;\n    return SidebarUI.isOpen && this.id == SidebarUI.currentID;\n  }\n\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    const sidebarAction = this;\n    return {\n      sidebarAction: {\n        async setTitle(details) {\n          sidebarAction.setPropertyFromDetails(details, \"title\", details.title);\n        },\n\n        getTitle(details) {\n          return sidebarAction.getPropertyFromDetails(details, \"title\");\n        },\n\n        async setIcon(details) {\n          let icon = IconDetails.normalize(details, extension, context);\n\n          if (!Object.keys(icon).length) {\n            icon = null;\n          }\n\n          sidebarAction.setPropertyFromDetails(details, \"icon\", icon);\n        },\n\n        async setPanel(details) {\n          let url;\n\n          if (!details.panel) {\n            url = null;\n          } else {\n            url = context.uri.resolve(details.panel);\n\n            if (!context.checkLoadURL(url)) {\n              return Promise.reject({\n                message: `Access denied for URL ${url}`\n              });\n            }\n          }\n\n          sidebarAction.setPropertyFromDetails(details, \"panel\", url);\n        },\n\n        getPanel(details) {\n          return sidebarAction.getPropertyFromDetails(details, \"panel\");\n        },\n\n        open() {\n          let window = windowTracker.topWindow;\n\n          if (context.canAccessWindow(window)) {\n            sidebarAction.open(window);\n          }\n        },\n\n        close() {\n          let window = windowTracker.topWindow;\n\n          if (context.canAccessWindow(window)) {\n            sidebarAction.close(window);\n          }\n        },\n\n        isOpen(details) {\n          let {\n            windowId\n          } = details;\n\n          if (windowId == null) {\n            windowId = Window.WINDOW_ID_CURRENT;\n          }\n\n          let window = windowTracker.getWindow(windowId, context);\n          return sidebarAction.isOpen(window);\n        }\n\n      }\n    };\n  }\n\n}"},{"filepath":"browser/components/extensions/parent/ext-sidebarAction.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"global.sidebarActionFor = this.sidebarAction.for"}],"promiseObserved":[{"filepath":"browser/components/extensions/parent/ext-sessions.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  ExtensionError,\n  promiseObserved\n} = ExtensionUtils;"},{"filepath":"browser/components/extensions/parent/ext-windows.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  promiseObserved\n} = ExtensionUtils;"}],"SS_ON_CLOSED_OBJECTS_CHANGED":[{"filepath":"browser/components/extensions/parent/ext-sessions.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const SS_ON_CLOSED_OBJECTS_CHANGED = \"sessionstore-closed-objects-changed\";"}],"getRecentlyClosed":[{"filepath":"browser/components/extensions/parent/ext-sessions.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const getRecentlyClosed = (maxResults, extension) => {\n  let recentlyClosed = [];\n  let closedWindowData = SessionStore.getClosedWindowData(false);\n\n  for (let window of closedWindowData) {\n    recentlyClosed.push({\n      lastModified: window.closedAt,\n      window: Window.convertFromSessionStoreClosedData(extension, window)\n    });\n  }\n\n  for (let window of windowTracker.browserWindows()) {\n    if (!extension.canAccessWindow(window)) {\n      continue;\n    }\n\n    let closedTabData = SessionStore.getClosedTabData(window, false);\n\n    for (let tab of closedTabData) {\n      recentlyClosed.push({\n        lastModified: tab.closedAt,\n        tab: Tab.convertFromSessionStoreClosedData(extension, tab, window)\n      });\n    }\n  }\n\n  recentlyClosed.sort((a, b) => b.lastModified - a.lastModified);\n  return recentlyClosed.slice(0, maxResults);\n};"}],"createSession":[{"filepath":"browser/components/extensions/parent/ext-sessions.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const createSession = async function createSession(restored, extension, sessionId) {\n  if (!restored) {\n    throw new ExtensionError(`Could not restore object using sessionId ${sessionId}.`);\n  }\n\n  let sessionObj = {\n    lastModified: Date.now()\n  };\n\n  if (restored instanceof Ci.nsIDOMChromeWindow) {\n    await promiseObserved(\"sessionstore-single-window-restored\", subject => subject == restored);\n    sessionObj.window = extension.windowManager.convert(restored, {\n      populate: true\n    });\n    return sessionObj;\n  }\n\n  sessionObj.tab = extension.tabManager.convert(restored);\n  return sessionObj;\n};"}],"getEncodedKey":[{"filepath":"browser/components/extensions/parent/ext-sessions.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const getEncodedKey = function getEncodedKey(extensionId, key) {\n  if (AddonManagerPrivate.isTemporaryInstallID(extensionId)) {\n    let message = \"Sessions API storage methods will not work with a temporary addon ID. \" + \"Please add an explicit addon ID to your manifest.\";\n    throw new ExtensionError(message);\n  }\n\n  return `extension:${extensionId}:${key}`;\n};"}],"sessions":[{"filepath":"browser/components/extensions/parent/ext-sessions.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.sessions = class extends ExtensionAPI {\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n\n    function getTabParams(key, id) {\n      let encodedKey = getEncodedKey(extension.id, key);\n      let tab = tabTracker.getTab(id);\n\n      if (!context.canAccessWindow(tab.ownerGlobal)) {\n        throw new ExtensionError(`Invalid tab ID: ${id}`);\n      }\n\n      return {\n        encodedKey,\n        tab\n      };\n    }\n\n    function getWindowParams(key, id) {\n      let encodedKey = getEncodedKey(extension.id, key);\n      let win = windowTracker.getWindow(id, context);\n      return {\n        encodedKey,\n        win\n      };\n    }\n\n    return {\n      sessions: {\n        async getRecentlyClosed(filter) {\n          await SessionStore.promiseInitialized;\n          let maxResults = filter.maxResults == undefined ? this.MAX_SESSION_RESULTS : filter.maxResults;\n          return getRecentlyClosed(maxResults, extension);\n        },\n\n        async forgetClosedTab(windowId, sessionId) {\n          await SessionStore.promiseInitialized;\n          let window = windowTracker.getWindow(windowId, context);\n          let closedTabData = SessionStore.getClosedTabData(window, false);\n          let closedTabIndex = closedTabData.findIndex(closedTab => {\n            return closedTab.closedId === parseInt(sessionId, 10);\n          });\n\n          if (closedTabIndex < 0) {\n            throw new ExtensionError(`Could not find closed tab using sessionId ${sessionId}.`);\n          }\n\n          SessionStore.forgetClosedTab(window, closedTabIndex);\n        },\n\n        async forgetClosedWindow(sessionId) {\n          await SessionStore.promiseInitialized;\n          let closedWindowData = SessionStore.getClosedWindowData(false);\n          let closedWindowIndex = closedWindowData.findIndex(closedWindow => {\n            return closedWindow.closedId === parseInt(sessionId, 10);\n          });\n\n          if (closedWindowIndex < 0) {\n            throw new ExtensionError(`Could not find closed window using sessionId ${sessionId}.`);\n          }\n\n          SessionStore.forgetClosedWindow(closedWindowIndex);\n        },\n\n        async restore(sessionId) {\n          await SessionStore.promiseInitialized;\n          let session, closedId;\n\n          if (sessionId) {\n            closedId = sessionId;\n            session = SessionStore.undoCloseById(closedId, extension.privateBrowsingAllowed);\n          } else if (SessionStore.lastClosedObjectType == \"window\") {\n            session = SessionStore.undoCloseWindow(0);\n          } else {\n            let recentlyClosedTabs = [];\n\n            for (let window of windowTracker.browserWindows()) {\n              let closedTabData = SessionStore.getClosedTabData(window, false);\n\n              for (let tab of closedTabData) {\n                recentlyClosedTabs.push(tab);\n              }\n            }\n\n            if (recentlyClosedTabs.length) {\n              recentlyClosedTabs.sort((a, b) => b.closedAt - a.closedAt);\n              closedId = recentlyClosedTabs[0].closedId;\n              session = SessionStore.undoCloseById(closedId, extension.privateBrowsingAllowed);\n            }\n          }\n\n          return createSession(session, extension, closedId);\n        },\n\n        setTabValue(tabId, key, value) {\n          let {\n            tab,\n            encodedKey\n          } = getTabParams(key, tabId);\n          SessionStore.setCustomTabValue(tab, encodedKey, JSON.stringify(value));\n        },\n\n        async getTabValue(tabId, key) {\n          let {\n            tab,\n            encodedKey\n          } = getTabParams(key, tabId);\n          let value = SessionStore.getCustomTabValue(tab, encodedKey);\n\n          if (value) {\n            return JSON.parse(value);\n          }\n\n          return undefined;\n        },\n\n        removeTabValue(tabId, key) {\n          let {\n            tab,\n            encodedKey\n          } = getTabParams(key, tabId);\n          SessionStore.deleteCustomTabValue(tab, encodedKey);\n        },\n\n        setWindowValue(windowId, key, value) {\n          let {\n            win,\n            encodedKey\n          } = getWindowParams(key, windowId);\n          SessionStore.setCustomWindowValue(win, encodedKey, JSON.stringify(value));\n        },\n\n        async getWindowValue(windowId, key) {\n          let {\n            win,\n            encodedKey\n          } = getWindowParams(key, windowId);\n          let value = SessionStore.getCustomWindowValue(win, encodedKey);\n\n          if (value) {\n            return JSON.parse(value);\n          }\n\n          return undefined;\n        },\n\n        removeWindowValue(windowId, key) {\n          let {\n            win,\n            encodedKey\n          } = getWindowParams(key, windowId);\n          SessionStore.deleteCustomWindowValue(win, encodedKey);\n        },\n\n        onChanged: new EventManager({\n          context,\n          name: \"sessions.onChanged\",\n          register: fire => {\n            let observer = () => {\n              fire.async();\n            };\n\n            Services.obs.addObserver(observer, SS_ON_CLOSED_OBJECTS_CHANGED);\n            return () => {\n              Services.obs.removeObserver(observer, SS_ON_CLOSED_OBJECTS_CHANGED);\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"WindowEventManager":[{"filepath":"browser/components/extensions/parent/ext-windows.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function WindowEventManager(context, name, event, listener) {\n  let register = fire => {\n    let listener2 = (window, ...args) => {\n      if (context.canAccessWindow(window)) {\n        listener(fire, window, ...args);\n      }\n    };\n\n    windowTracker.addListener(event, listener2);\n    return () => {\n      windowTracker.removeListener(event, listener2);\n    };\n  };\n\n  return new EventManager({\n    context,\n    name,\n    register\n  }).api();\n}"}],"windows":[{"filepath":"browser/components/extensions/parent/ext-windows.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.windows = class extends ExtensionAPI {\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    const {\n      windowManager\n    } = extension;\n    return {\n      windows: {\n        onCreated: WindowEventManager(context, \"windows.onCreated\", \"domwindowopened\", (fire, window) => {\n          fire.async(windowManager.convert(window));\n        }),\n        onRemoved: WindowEventManager(context, \"windows.onRemoved\", \"domwindowclosed\", (fire, window) => {\n          fire.async(windowTracker.getId(window));\n        }),\n        onFocusChanged: new EventManager({\n          context,\n          name: \"windows.onFocusChanged\",\n          register: fire => {\n            let lastOnFocusChangedWindowId;\n\n            let listener = event => {\n              Promise.resolve().then(() => {\n                let windowId = Window.WINDOW_ID_NONE;\n                let window = Services.focus.activeWindow;\n\n                if (window) {\n                  if (!context.canAccessWindow(window)) {\n                    return;\n                  }\n\n                  windowId = windowTracker.getId(window);\n                }\n\n                if (windowId !== lastOnFocusChangedWindowId) {\n                  fire.async(windowId);\n                  lastOnFocusChangedWindowId = windowId;\n                }\n              });\n            };\n\n            windowTracker.addListener(\"focus\", listener);\n            windowTracker.addListener(\"blur\", listener);\n            return () => {\n              windowTracker.removeListener(\"focus\", listener);\n              windowTracker.removeListener(\"blur\", listener);\n            };\n          }\n        }).api(),\n        get: function (windowId, getInfo) {\n          let window = windowTracker.getWindow(windowId, context);\n\n          if (!window || !context.canAccessWindow(window)) {\n            return Promise.reject({\n              message: `Invalid window ID: ${windowId}`\n            });\n          }\n\n          return Promise.resolve(windowManager.convert(window, getInfo));\n        },\n        getCurrent: function (getInfo) {\n          let window = context.currentWindow || windowTracker.topWindow;\n\n          if (!context.canAccessWindow(window)) {\n            return Promise.reject({\n              message: `Invalid window`\n            });\n          }\n\n          return Promise.resolve(windowManager.convert(window, getInfo));\n        },\n        getLastFocused: function (getInfo) {\n          let window = windowTracker.topWindow;\n\n          if (!context.canAccessWindow(window)) {\n            return Promise.reject({\n              message: `Invalid window`\n            });\n          }\n\n          return Promise.resolve(windowManager.convert(window, getInfo));\n        },\n        getAll: function (getInfo) {\n          let doNotCheckTypes = getInfo === null || getInfo.windowTypes === null;\n          let windows = [];\n\n          for (let win of windowManager.getAll()) {\n            if (doNotCheckTypes || getInfo.windowTypes.includes(win.type)) {\n              windows.push(win.convert(getInfo));\n            }\n          }\n\n          return windows;\n        },\n        create: function (createData) {\n          let needResize = createData.left !== null || createData.top !== null || createData.width !== null || createData.height !== null;\n\n          if (createData.incognito && !context.privateBrowsingAllowed) {\n            return Promise.reject({\n              message: \"Extension does not have permission for incognito mode\"\n            });\n          }\n\n          if (needResize) {\n            if (createData.state !== null && createData.state != \"normal\") {\n              return Promise.reject({\n                message: `\"state\": \"${createData.state}\" may not be combined with \"left\", \"top\", \"width\", or \"height\"`\n              });\n            }\n\n            createData.state = \"normal\";\n          }\n\n          function mkstr(s) {\n            let result = Cc[\"@mozilla.org/supports-string;1\"].createInstance(Ci.nsISupportsString);\n            result.data = s;\n            return result;\n          }\n\n          let args = Cc[\"@mozilla.org/array;1\"].createInstance(Ci.nsIMutableArray);\n          let principal = context.principal;\n\n          if (createData.tabId !== null) {\n            if (createData.url !== null) {\n              return Promise.reject({\n                message: \"`tabId` may not be used in conjunction with `url`\"\n              });\n            }\n\n            if (createData.allowScriptsToClose) {\n              return Promise.reject({\n                message: \"`tabId` may not be used in conjunction with `allowScriptsToClose`\"\n              });\n            }\n\n            let tab = tabTracker.getTab(createData.tabId);\n\n            if (!context.canAccessWindow(tab.ownerGlobal)) {\n              return Promise.reject({\n                message: `Invalid tab ID: ${createData.tabId}`\n              });\n            }\n\n            let incognito = PrivateBrowsingUtils.isBrowserPrivate(tab.linkedBrowser);\n\n            if (createData.incognito !== null && createData.incognito != incognito) {\n              return Promise.reject({\n                message: \"`incognito` property must match the incognito state of tab\"\n              });\n            }\n\n            createData.incognito = incognito;\n\n            if (createData.cookieStoreId && createData.cookieStoreId !== getCookieStoreIdForTab(createData, tab)) {\n              return Promise.reject({\n                message: \"`cookieStoreId` must match the tab's cookieStoreId\"\n              });\n            }\n\n            args.appendElement(tab);\n          } else if (createData.url !== null) {\n            if (Array.isArray(createData.url)) {\n              let array = Cc[\"@mozilla.org/array;1\"].createInstance(Ci.nsIMutableArray);\n\n              for (let url of createData.url) {\n                array.appendElement(mkstr(url));\n              }\n\n              args.appendElement(array);\n            } else {\n              args.appendElement(mkstr(createData.url));\n            }\n          } else {\n            let url = createData.incognito && !PrivateBrowsingUtils.permanentPrivateBrowsing ? \"about:privatebrowsing\" : HomePage.get().split(\"|\", 1)[0];\n            args.appendElement(mkstr(url));\n\n            if (url.startsWith(\"about:\") && !context.checkLoadURL(url, {\n              dontReportErrors: true\n            })) {\n              principal = Services.scriptSecurityManager.getSystemPrincipal();\n            }\n          }\n\n          args.appendElement(null);\n          args.appendElement(null);\n          args.appendElement(null);\n          args.appendElement(null);\n\n          if (createData.cookieStoreId) {\n            let userContextIdSupports = Cc[\"@mozilla.org/supports-PRUint32;1\"].createInstance(Ci.nsISupportsPRUint32);\n            userContextIdSupports.data = getUserContextIdForCookieStoreId(extension, createData.cookieStoreId, createData.incognito);\n            args.appendElement(userContextIdSupports);\n          } else {\n            args.appendElement(null);\n          }\n\n          args.appendElement(context.principal);\n          args.appendElement(context.principal);\n          args.appendElement(principal);\n          args.appendElement(Cc[\"@mozilla.org/supports-PRBool;1\"].createInstance(Ci.nsISupportsPRBool));\n          args.appendElement(null);\n          let features = [\"chrome\"];\n\n          if (createData.type === null || createData.type == \"normal\") {\n            features.push(\"dialog=no\", \"all\");\n          } else {\n            features.push(\"dialog\", \"resizable\", \"minimizable\", \"centerscreen\", \"titlebar\", \"close\");\n          }\n\n          if (createData.incognito !== null) {\n            if (createData.incognito) {\n              if (!PrivateBrowsingUtils.enabled) {\n                return Promise.reject({\n                  message: \"`incognito` cannot be used if incognito mode is disabled\"\n                });\n              }\n\n              features.push(\"private\");\n            } else {\n              features.push(\"non-private\");\n            }\n          }\n\n          let {\n            allowScriptsToClose,\n            url\n          } = createData;\n\n          if (allowScriptsToClose === null) {\n            allowScriptsToClose = typeof url === \"string\" && url.startsWith(\"moz-extension://\");\n          }\n\n          let window = Services.ww.openWindow(null, AppConstants.BROWSER_CHROME_URL, \"_blank\", features.join(\",\"), args);\n          let win = windowManager.getWrapper(window);\n          win.updateGeometry(createData);\n          return new Promise(resolve => {\n            window.addEventListener(\"DOMContentLoaded\", function () {\n              if (allowScriptsToClose) {\n                window.gBrowserAllowScriptsToCloseInitialTabs = true;\n              }\n\n              resolve(promiseObserved(\"browser-delayed-startup-finished\", win => win == window));\n            }, {\n              once: true\n            });\n          }).then(() => {\n            if ([\"minimized\", \"fullscreen\", \"docked\", \"normal\", \"maximized\"].includes(createData.state)) {\n              win.state = createData.state;\n            }\n\n            if (createData.titlePreface !== null) {\n              win.setTitlePreface(createData.titlePreface);\n            }\n\n            return win.convert({\n              populate: true\n            });\n          });\n        },\n        update: function (windowId, updateInfo) {\n          if (updateInfo.state !== null && updateInfo.state != \"normal\") {\n            if (updateInfo.left !== null || updateInfo.top !== null || updateInfo.width !== null || updateInfo.height !== null) {\n              return Promise.reject({\n                message: `\"state\": \"${updateInfo.state}\" may not be combined with \"left\", \"top\", \"width\", or \"height\"`\n              });\n            }\n          }\n\n          let win = windowManager.get(windowId, context);\n\n          if (!win) {\n            return Promise.reject({\n              message: `Invalid window ID: ${windowId}`\n            });\n          }\n\n          if (updateInfo.focused) {\n            Services.focus.activeWindow = win.window;\n          }\n\n          if (updateInfo.state !== null) {\n            win.state = updateInfo.state;\n          }\n\n          if (updateInfo.drawAttention) {\n            win.window.getAttention();\n          }\n\n          win.updateGeometry(updateInfo);\n\n          if (updateInfo.titlePreface !== null) {\n            win.setTitlePreface(updateInfo.titlePreface);\n            win.window.gBrowser.updateTitlebar();\n          }\n\n          return Promise.resolve(win.convert());\n        },\n        remove: function (windowId) {\n          let window = windowTracker.getWindow(windowId, context);\n\n          if (!context.canAccessWindow(window)) {\n            return Promise.reject({\n              message: `Invalid window ID: ${windowId}`\n            });\n          }\n\n          window.close();\n          return new Promise(resolve => {\n            let listener = () => {\n              windowTracker.removeListener(\"domwindowclosed\", listener);\n              resolve();\n            };\n\n            windowTracker.addListener(\"domwindowclosed\", listener);\n          });\n        }\n      }\n    };\n  }\n\n}"}],"idOfExtUsingContextualTip":[{"filepath":"browser/components/extensions/parent/ext-urlbar.js","kind":"let","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"let idOfExtUsingContextualTip = null;"}],"urlbar":[{"filepath":"browser/components/extensions/parent/ext-urlbar.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.urlbar = class extends ExtensionAPI {\n  onShutdown() {\n    if (idOfExtUsingContextualTip === this.extension.id) {\n      for (let w of windowTracker.browserWindows()) {\n        w.gURLBar.view.removeContextualTip();\n      }\n\n      idOfExtUsingContextualTip = null;\n    }\n  }\n\n  _getStyleFromIconsObject(icons) {\n    let getIcon = (icon, theme) => {\n      if (typeof icon === \"object\") {\n        return IconDetails.escapeUrl(icon[theme]);\n      }\n\n      return IconDetails.escapeUrl(icon);\n    };\n\n    let getStyle = (name, icon) => {\n      return `\n        --webextension-${name}: url(\"${getIcon(icon, \"default\")}\");\n        --webextension-${name}-light: url(\"${getIcon(icon, \"light\")}\");\n        --webextension-${name}-dark: url(\"${getIcon(icon, \"dark\")}\");\n      `;\n    };\n\n    let icon16 = IconDetails.getPreferredIcon(icons, this.extension, 16).icon;\n    let icon32 = IconDetails.getPreferredIcon(icons, this.extension, 32).icon;\n    return `\n      ${getStyle(\"contextual-tip-icon\", icon16)}\n      ${getStyle(\"contextual-tip-icon-2x\", icon32)}\n    `;\n  }\n\n  _registerExtensionToUseContextualTip() {\n    if (idOfExtUsingContextualTip == null) {\n      idOfExtUsingContextualTip = this.extension.id;\n    }\n\n    if (idOfExtUsingContextualTip !== this.extension.id) {\n      throw new Error(\"There was an attempt to use the contextual tip API but \" + \"another extension is already using the contextual tip API.\");\n    }\n  }\n\n  _registerClickListener(type) {\n    return fire => {\n      this._registerExtensionToUseContextualTip();\n\n      const listener = window => {\n        const windowId = this.extension.windowManager.wrapWindow(window).id;\n        fire.async(windowId);\n      };\n\n      UrlbarContextualTip.addClickListener(type, listener);\n      return () => {\n        UrlbarContextualTip.removeClickListener(type, listener);\n      };\n    };\n  }\n\n  getAPI(context) {\n    return {\n      urlbar: {\n        onBehaviorRequested: new EventManager({\n          context,\n          name: \"urlbar.onBehaviorRequested\",\n          register: (fire, providerName) => {\n            let provider = UrlbarProviderExtension.getOrCreate(providerName);\n            provider.setEventListener(\"behaviorRequested\", async queryContext => {\n              if (queryContext.isPrivate && !context.privateBrowsingAllowed) {\n                return \"inactive\";\n              }\n\n              return fire.async(queryContext).catch(error => {\n                throw context.normalizeError(error);\n              });\n            });\n            return () => provider.setEventListener(\"behaviorRequested\", null);\n          }\n        }).api(),\n        onQueryCanceled: new EventManager({\n          context,\n          name: \"urlbar.onQueryCanceled\",\n          register: (fire, providerName) => {\n            let provider = UrlbarProviderExtension.getOrCreate(providerName);\n            provider.setEventListener(\"queryCanceled\", async queryContext => {\n              if (queryContext.isPrivate && !context.privateBrowsingAllowed) {\n                return;\n              }\n\n              await fire.async(queryContext).catch(error => {\n                throw context.normalizeError(error);\n              });\n            });\n            return () => provider.setEventListener(\"queryCanceled\", null);\n          }\n        }).api(),\n        onResultsRequested: new EventManager({\n          context,\n          name: \"urlbar.onResultsRequested\",\n          register: (fire, providerName) => {\n            let provider = UrlbarProviderExtension.getOrCreate(providerName);\n            provider.setEventListener(\"resultsRequested\", async queryContext => {\n              if (queryContext.isPrivate && !context.privateBrowsingAllowed) {\n                return [];\n              }\n\n              return fire.async(queryContext).catch(error => {\n                throw context.normalizeError(error);\n              });\n            });\n            return () => provider.setEventListener(\"resultsRequested\", null);\n          }\n        }).api(),\n        onResultPicked: new EventManager({\n          context,\n          name: \"urlbar.onResultPicked\",\n          register: (fire, providerName) => {\n            let provider = UrlbarProviderExtension.getOrCreate(providerName);\n            provider.setEventListener(\"resultPicked\", async (resultPayload, details) => {\n              return fire.async(resultPayload, details).catch(error => {\n                throw context.normalizeError(error);\n              });\n            });\n            return () => provider.setEventListener(\"resultPicked\", null);\n          }\n        }).api(),\n        openViewOnFocus: getSettingsAPI(context.extension.id, \"openViewOnFocus\", () => UrlbarPrefs.get(\"openViewOnFocus\")),\n        engagementTelemetry: getSettingsAPI(context.extension.id, \"engagementTelemetry\", () => UrlbarPrefs.get(\"eventTelemetry.enabled\")),\n        contextualTip: {\n          set: details => {\n            this._registerExtensionToUseContextualTip();\n\n            const mostRecentWindow = windowTracker.getTopNormalWindow(context);\n            const iconPathFromDetails = details.icon ? details.icon.defaultIcon : null;\n            const iconPathFromExtensionManifest = context.extension.manifest.icons;\n            const icons = IconDetails.normalize({\n              path: iconPathFromDetails || iconPathFromExtensionManifest,\n              iconType: \"contextualTip\",\n              themeIcons: details.icon ? details.icon.themeIcons : null\n            }, context.extension);\n\n            const iconStyle = this._getStyleFromIconsObject(icons);\n\n            mostRecentWindow.gURLBar.view.setContextualTip({\n              iconStyle,\n              title: details.title,\n              buttonTitle: details.buttonTitle,\n              linkTitle: details.linkTitle\n            });\n          },\n          remove: () => {\n            this._registerExtensionToUseContextualTip();\n\n            const mostRecentWindow = windowTracker.getTopNormalWindow(context);\n            mostRecentWindow.gURLBar.view.hideContextualTip();\n          },\n          onButtonClicked: new EventManager({\n            context,\n            name: \"urlbar.contextualTip.onButtonClicked\",\n            register: this._registerClickListener(\"button\")\n          }).api(),\n          onLinkClicked: new EventManager({\n            context,\n            name: \"urlbar.contextualTip.onLinkClicked\",\n            register: this._registerClickListener(\"link\")\n          }).api()\n        }\n      }\n    };\n  }\n\n}"}],"measureOp":[{"filepath":"toolkit/components/extensions/child/ext-storage.js","kind":"function","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"async function measureOp(telemetryMetric, extension, fn) {\n  const stopwatchKey = {};\n  telemetryMetric.stopwatchStart(extension, stopwatchKey);\n\n  try {\n    let result = await fn();\n    telemetryMetric.stopwatchFinish(extension, stopwatchKey);\n    return result;\n  } catch (err) {\n    telemetryMetric.stopwatchCancel(extension, stopwatchKey);\n    throw err;\n  }\n}"}],"TYPEOF_PRIMITIVES":[{"filepath":"toolkit/components/extensions/child/ext-userScripts-content.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"const TYPEOF_PRIMITIVES = [\"bigint\", \"boolean\", \"number\", \"string\", \"symbol\"];"}],"userScriptsContent":[{"filepath":"toolkit/components/extensions/child/ext-userScripts-content.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":false,"child":true},"jscode":"this.userScriptsContent = class extends ExtensionAPI {\n  getAPI(context) {\n    return {\n      userScripts: {\n        onBeforeScript: new EventManager({\n          context,\n          name: \"userScripts.onBeforeScript\",\n          register: fire => {\n            if (!userScriptsEnabled) {\n              throw new ExtensionError(USERSCRIPT_DISABLED_ERRORMSG);\n            }\n\n            let handler = (event, metadata, scriptSandbox, eventResult) => {\n              const us = new UserScript({\n                context,\n                metadata,\n                scriptSandbox\n              });\n              const apiObj = Cu.cloneInto(us.api(), context.cloneScope, {\n                cloneFunctions: true\n              });\n              Object.defineProperty(apiObj, \"global\", {\n                value: scriptSandbox,\n                enumerable: true,\n                configurable: true,\n                writable: true\n              });\n              fire.raw(apiObj);\n            };\n\n            context.userScriptsEvents.on(\"on-before-script\", handler);\n            return () => {\n              context.userScriptsEvents.off(\"on-before-script\", handler);\n            };\n          }\n        }).api()\n      }\n    };\n  }\n\n}"}],"XPCOMUtils":[{"filepath":"browser/components/extensions/child/ext-devtools-panels.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":false,"child":true},"jscode":"var {\n  XPCOMUtils\n} = ChromeUtils.import(\"resource://gre/modules/XPCOMUtils.jsm\");"}],"devtools_panels":[{"filepath":"browser/components/extensions/child/ext-devtools-panels.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":false,"child":true},"jscode":"this.devtools_panels = class extends ExtensionAPI {\n  getAPI(context) {\n    const themeChangeObserver = ExtensionChildDevToolsUtils.getThemeChangeObserver();\n    return {\n      devtools: {\n        panels: {\n          elements: {\n            createSidebarPane(title) {\n              return context.cloneScope.Promise.resolve().then(async () => {\n                const sidebarId = await context.childManager.callParentAsyncFunction(\"devtools.panels.elements.createSidebarPane\", [title]);\n                const sidebar = new ChildDevToolsInspectorSidebar(context, {\n                  id: sidebarId\n                });\n                const sidebarAPI = Cu.cloneInto(sidebar.api(), context.cloneScope, {\n                  cloneFunctions: true\n                });\n                return sidebarAPI;\n              });\n            }\n\n          },\n\n          create(title, icon, url) {\n            return context.cloneScope.Promise.resolve().then(async () => {\n              const panelId = await context.childManager.callParentAsyncFunction(\"devtools.panels.create\", [title, icon, url]);\n              const devtoolsPanel = new ChildDevToolsPanel(context, {\n                id: panelId\n              });\n              const devtoolsPanelAPI = Cu.cloneInto(devtoolsPanel.api(), context.cloneScope, {\n                cloneFunctions: true\n              });\n              return devtoolsPanelAPI;\n            });\n          },\n\n          get themeName() {\n            return themeChangeObserver.themeName;\n          },\n\n          onThemeChanged: new EventManager({\n            context,\n            name: \"devtools.panels.onThemeChanged\",\n            register: fire => {\n              const listener = (eventName, themeName) => {\n                fire.async(themeName);\n              };\n\n              themeChangeObserver.on(\"themeChanged\", listener);\n              return () => {\n                themeChangeObserver.off(\"themeChanged\", listener);\n              };\n            }\n          }).api()\n        }\n      }\n    };\n  }\n\n}"},{"filepath":"browser/components/extensions/parent/ext-devtools-panels.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.devtools_panels = class extends ExtensionAPI {\n  getAPI(context) {\n    let waitForInspectedWindowFront;\n    const callerInfo = {\n      addonId: context.extension.id,\n      url: context.extension.baseURI.spec\n    };\n    let nextPanelId = 0;\n    const toolboxSelectionObserver = new DevToolsSelectionObserver(context);\n\n    function newBasePanelId() {\n      return `${context.extension.id}-${context.contextId}-${nextPanelId++}`;\n    }\n\n    return {\n      devtools: {\n        panels: {\n          elements: {\n            onSelectionChanged: new EventManager({\n              context,\n              name: \"devtools.panels.elements.onSelectionChanged\",\n              register: fire => {\n                const listener = eventName => {\n                  fire.async();\n                };\n\n                toolboxSelectionObserver.on(\"selectionChanged\", listener);\n                return () => {\n                  toolboxSelectionObserver.off(\"selectionChanged\", listener);\n                };\n              }\n            }).api(),\n\n            createSidebarPane(title) {\n              const id = `devtools-inspector-sidebar-${makeWidgetId(newBasePanelId())}`;\n              const parentSidebar = new ParentDevToolsInspectorSidebar(context, {\n                title,\n                id\n              });\n              sidebarsById.set(id, parentSidebar);\n              context.callOnClose({\n                close() {\n                  sidebarsById.delete(id);\n                }\n\n              });\n              return Promise.resolve(id);\n            },\n\n            Sidebar: {\n              setPage(sidebarId, extensionPageURL) {\n                const sidebar = sidebarsById.get(sidebarId);\n                return sidebar.setPage(extensionPageURL);\n              },\n\n              setObject(sidebarId, jsonObject, rootTitle) {\n                const sidebar = sidebarsById.get(sidebarId);\n                return sidebar.setObject(jsonObject, rootTitle);\n              },\n\n              async setExpression(sidebarId, evalExpression, rootTitle) {\n                const sidebar = sidebarsById.get(sidebarId);\n\n                if (!waitForInspectedWindowFront) {\n                  waitForInspectedWindowFront = getInspectedWindowFront(context);\n                }\n\n                const front = await waitForInspectedWindowFront;\n                const evalOptions = Object.assign({\n                  evalResultAsGrip: true\n                }, getToolboxEvalOptions(context));\n                const evalResult = await front.eval(callerInfo, evalExpression, evalOptions);\n                let jsonObject;\n\n                if (evalResult.exceptionInfo) {\n                  jsonObject = evalResult.exceptionInfo;\n                  return sidebar.setObject(jsonObject, rootTitle);\n                }\n\n                return sidebar.setObjectValueGrip(evalResult.valueGrip, rootTitle);\n              }\n\n            }\n          },\n\n          create(title, icon, url) {\n            if (icon === \"\" && context.extension.manifest.icons) {\n              const iconInfo = IconDetails.getPreferredIcon(context.extension.manifest.icons, context.extension, 128);\n              icon = iconInfo ? iconInfo.icon : \"\";\n            }\n\n            icon = context.extension.baseURI.resolve(icon);\n            url = context.extension.baseURI.resolve(url);\n            const id = `webext-devtools-panel-${makeWidgetId(newBasePanelId())}`;\n            new ParentDevToolsPanel(context, {\n              title,\n              icon,\n              url,\n              id\n            });\n            return Promise.resolve(id);\n          }\n\n        }\n      }\n    };\n  }\n\n}"}],"withHandlingUserInput":[{"filepath":"browser/components/extensions/child/ext-menus.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":false,"child":true},"jscode":"var {\n  withHandlingUserInput\n} = ExtensionCommon;"}],"gNextMenuItemID":[{"filepath":"browser/components/extensions/child/ext-menus.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":false,"child":true},"jscode":"var gNextMenuItemID = 0;"},{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var gNextMenuItemID = 0;"}],"gPropHandlers":[{"filepath":"browser/components/extensions/child/ext-menus.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":false,"child":true},"jscode":"var gPropHandlers = new Map();"}],"menusInternal":[{"filepath":"browser/components/extensions/child/ext-menus.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":false,"child":true},"jscode":"this.menusInternal = class extends ExtensionAPI {\n  getAPI(context) {\n    let onClickedProp = new ContextMenusClickPropHandler(context);\n    let pendingMenuEvent;\n    let api = {\n      menus: {\n        create(createProperties, callback) {\n          if (createProperties.id === null) {\n            createProperties.id = ++gNextMenuItemID;\n          }\n\n          let {\n            onclick\n          } = createProperties;\n          delete createProperties.onclick;\n          context.childManager.callParentAsyncFunction(\"menusInternal.create\", [createProperties]).then(() => {\n            if (onclick) {\n              onClickedProp.setListener(createProperties.id, onclick);\n            }\n\n            if (callback) {\n              context.runSafeWithoutClone(callback);\n            }\n          }).catch(error => {\n            context.withLastError(error, null, () => {\n              if (callback) {\n                context.runSafeWithoutClone(callback);\n              }\n            });\n          });\n          return createProperties.id;\n        },\n\n        update(id, updateProperties) {\n          let {\n            onclick\n          } = updateProperties;\n          delete updateProperties.onclick;\n          return context.childManager.callParentAsyncFunction(\"menusInternal.update\", [id, updateProperties]).then(() => {\n            if (onclick) {\n              onClickedProp.setListener(id, onclick);\n            } else if (onclick === null) {\n              onClickedProp.unsetListenerFromAnyContext(id);\n            }\n          });\n        },\n\n        remove(id) {\n          onClickedProp.unsetListenerFromAnyContext(id);\n          return context.childManager.callParentAsyncFunction(\"menusInternal.remove\", [id]);\n        },\n\n        removeAll() {\n          onClickedProp.deleteAllListenersFromExtension();\n          return context.childManager.callParentAsyncFunction(\"menusInternal.removeAll\", []);\n        },\n\n        overrideContext(contextOptions) {\n          let checkValidArg = (contextType, propKey) => {\n            if (contextOptions.context !== contextType) {\n              if (contextOptions[propKey]) {\n                throw new ExtensionError(`Property \"${propKey}\" can only be used with context \"${contextType}\"`);\n              }\n\n              return false;\n            }\n\n            if (contextOptions.showDefaults) {\n              throw new ExtensionError(`Property \"showDefaults\" cannot be used with context \"${contextType}\"`);\n            }\n\n            if (!contextOptions[propKey]) {\n              throw new ExtensionError(`Property \"${propKey}\" is required for context \"${contextType}\"`);\n            }\n\n            return true;\n          };\n\n          if (checkValidArg(\"tab\", \"tabId\")) {\n            if (!context.extension.hasPermission(\"tabs\")) {\n              throw new ExtensionError(`The \"tab\" context requires the \"tabs\" permission.`);\n            }\n          }\n\n          if (checkValidArg(\"bookmark\", \"bookmarkId\")) {\n            if (!context.extension.hasPermission(\"bookmarks\")) {\n              throw new ExtensionError(`The \"bookmark\" context requires the \"bookmarks\" permission.`);\n            }\n          }\n\n          let webExtContextData = {\n            extensionId: context.extension.id,\n            showDefaults: contextOptions.showDefaults,\n            overrideContext: contextOptions.context,\n            bookmarkId: contextOptions.bookmarkId,\n            tabId: contextOptions.tabId\n          };\n\n          if (pendingMenuEvent) {\n            pendingMenuEvent.webExtContextData = webExtContextData;\n            return;\n          }\n\n          pendingMenuEvent = {\n            webExtContextData,\n\n            observe(subject, topic, data) {\n              pendingMenuEvent = null;\n              Services.obs.removeObserver(this, \"on-prepare-contextmenu\");\n              subject = subject.wrappedJSObject;\n\n              if (context.principal.subsumes(subject.context.principal)) {\n                subject.webExtContextData = this.webExtContextData;\n              }\n            },\n\n            run() {\n              if (pendingMenuEvent === this) {\n                pendingMenuEvent = null;\n                Services.obs.removeObserver(this, \"on-prepare-contextmenu\");\n              }\n            }\n\n          };\n          Services.obs.addObserver(pendingMenuEvent, \"on-prepare-contextmenu\");\n          Services.tm.dispatchToMainThread(pendingMenuEvent);\n        },\n\n        onClicked: new EventManager({\n          context,\n          name: \"menus.onClicked\",\n          register: fire => {\n            let listener = (info, tab) => {\n              withHandlingUserInput(context.contentWindow, () => fire.sync(info, tab));\n            };\n\n            let event = context.childManager.getParentEvent(\"menusInternal.onClicked\");\n            event.addListener(listener);\n            return () => {\n              event.removeListener(listener);\n            };\n          }\n        }).api()\n      }\n    };\n    const result = {};\n\n    if (context.extension.hasPermission(\"menus\")) {\n      result.menus = api.menus;\n    }\n\n    if (context.extension.hasPermission(\"contextMenus\")) {\n      result.contextMenus = api.menus;\n    }\n\n    return result;\n  }\n\n}"},{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.menusInternal = class extends ExtensionAPI {\n  constructor(extension) {\n    super(extension);\n\n    if (!gMenuMap.size) {\n      menuTracker.register();\n    }\n\n    gMenuMap.set(extension, new Map());\n  }\n\n  onShutdown() {\n    let {\n      extension\n    } = this;\n\n    if (gMenuMap.has(extension)) {\n      gMenuMap.delete(extension);\n      gRootItems.delete(extension);\n      gShownMenuItems.delete(extension);\n      gOnShownSubscribers.delete(extension);\n\n      if (!gMenuMap.size) {\n        menuTracker.unregister();\n      }\n    }\n  }\n\n  primeListener(extension, event, fire) {\n    return this.registerEvent({\n      extension,\n      event,\n      fire\n    });\n  }\n\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    const menus = {\n      refresh() {\n        gMenuBuilder.rebuildMenu(extension);\n      },\n\n      onShown: new EventManager({\n        context,\n        name: \"menus.onShown\",\n        persistent: {\n          module: \"menusInternal\",\n          event: \"onShown\"\n        },\n        register: fire => {\n          const {\n            unregister\n          } = this.registerEvent({\n            context,\n            extension: context.extension,\n            event: \"onShown\",\n            fire\n          });\n          return unregister;\n        }\n      }).api(),\n      onHidden: new EventManager({\n        context,\n        name: \"menus.onHidden\",\n        persistent: {\n          module: \"menusInternal\",\n          event: \"onHidden\"\n        },\n        register: fire => {\n          const {\n            unregister\n          } = this.registerEvent({\n            context,\n            extension: context.extension,\n            event: \"onHidden\",\n            fire\n          });\n          return unregister;\n        }\n      }).api()\n    };\n    return {\n      contextMenus: menus,\n      menus,\n      menusInternal: {\n        create: function (createProperties) {\n          const itemsMap = gMenuMap.get(extension);\n\n          if (context.isSuspendible) {\n            if (typeof createProperties.id === \"number\") {\n              return Promise.reject({\n                message: \"id is mandatory for menus created from suspendible contexts\"\n              });\n            }\n\n            if (itemsMap.has(createProperties.id)) {\n              return;\n            }\n          }\n\n          let menuItem = new MenuItem(extension, createProperties);\n          itemsMap.set(menuItem.id, menuItem);\n        },\n        update: function (id, updateProperties) {\n          let menuItem = gMenuMap.get(extension).get(id);\n\n          if (menuItem) {\n            menuItem.setProps(updateProperties);\n          }\n        },\n        remove: function (id) {\n          let menuItem = gMenuMap.get(extension).get(id);\n\n          if (menuItem) {\n            menuItem.remove();\n          }\n        },\n        removeAll: function () {\n          let root = gRootItems.get(extension);\n\n          if (root) {\n            root.remove();\n          }\n        },\n        onClicked: new EventManager({\n          context,\n          name: \"menusInternal.onClicked\",\n          persistent: {\n            module: \"menusInternal\",\n            event: \"onClicked\",\n            withPendingBrowser: true\n          },\n          register: fire => {\n            const {\n              unregister\n            } = this.registerEvent({\n              context,\n              extension: context.extension,\n              event: \"onClicked\",\n              withPendingBrowser: true,\n              fire\n            });\n            return unregister;\n          }\n        }).api()\n      }\n    };\n  }\n\n  registerEvent({\n    extension,\n    event,\n    fire,\n    context,\n    withPendingBrowser\n  }) {\n    let menuEvt;\n\n    let onUnregister = () => {};\n\n    let processEvent;\n\n    switch (event) {\n      case \"onShown\":\n        menuEvt = \"webext-menu-shown\";\n\n        processEvent = (...args) => this.processShownEvent(...args);\n\n        gOnShownSubscribers.add(extension);\n        break;\n\n      case \"onHidden\":\n        menuEvt = \"webext-menu-hidden\";\n\n        processEvent = () => [];\n\n        break;\n\n      case \"onClicked\":\n        menuEvt = \"webext-menu-menuitem-click\";\n\n        processEvent = (...args) => this.processClickedEvent(...args);\n\n        onUnregister = () => gOnShownSubscribers.delete(extension);\n\n        break;\n\n      default:\n        throw new Error(`Cannot register unknown menu event: ${event}`);\n    }\n\n    let eventListener = function (...args) {\n      if (context && withPendingBrowser) {\n        const [pendingBrowser, ...fireArgs] = processEvent({\n          extension,\n          args\n        });\n        context.withPendingBrowser(pendingBrowser, () => fire.sync(...fireArgs));\n      } else {\n        fire.sync(...processEvent({\n          extension,\n          args\n        }));\n      }\n    };\n\n    extension.on(menuEvt, eventListener);\n    return {\n      unregister: () => {\n        onUnregister();\n        extension.off(menuEvt, eventListener);\n      },\n      convert: (_fire, _context) => {\n        fire = _fire;\n        context = _context;\n      }\n    };\n  }\n\n  processShownEvent({\n    extension,\n    args: [event, menuIds, contextData]\n  }) {\n    let info = {\n      menuIds,\n      contexts: Array.from(getMenuContexts(contextData))\n    };\n    let nativeTab = contextData.tab;\n    let contextUrl = contextData.inFrame ? contextData.frameUrl : contextData.pageUrl;\n    let includeSensitiveData = nativeTab && extension.tabManager.hasActiveTabPermission(nativeTab) || contextUrl && extension.whiteListedHosts.matches(contextUrl);\n    addMenuEventInfo(info, contextData, extension, includeSensitiveData);\n    let tab = nativeTab && extension.tabManager.convert(nativeTab);\n    return [info, tab];\n  }\n\n  processClickedEvent({\n    extension,\n    args: [event, info, nativeTab]\n  }) {\n    let {\n      linkedBrowser\n    } = nativeTab || tabTracker.activeTab;\n    let tab = nativeTab && extension.tabManager.convert(nativeTab);\n    return [linkedBrowser, info, tab];\n  }\n\n}"}],"getBrowserWindow":[{"filepath":"mobile/android/components/extensions/ext-tabs.js","kind":"const","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"const getBrowserWindow = window => {\n  return window.docShell.rootTreeItem.domWindow;\n};"}],"tabListener":[{"filepath":"mobile/android/components/extensions/ext-tabs.js","kind":"let","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"let tabListener = {\n  tabReadyInitialized: false,\n  tabReadyPromises: new WeakMap(),\n  initializingTabs: new WeakSet(),\n\n  initTabReady() {\n    if (!this.tabReadyInitialized) {\n      windowTracker.addListener(\"progress\", this);\n      this.tabReadyInitialized = true;\n    }\n  },\n\n  onLocationChange(browser, webProgress, request, locationURI, flags) {\n    if (webProgress.isTopLevel) {\n      let {\n        BrowserApp\n      } = browser.ownerGlobal;\n      let nativeTab = BrowserApp.getTabForBrowser(browser);\n\n      if (!request && this.initializingTabs.has(nativeTab)) {\n        return;\n      }\n\n      this.initializingTabs.delete(nativeTab);\n      let deferred = this.tabReadyPromises.get(nativeTab);\n\n      if (deferred) {\n        deferred.resolve(nativeTab);\n        this.tabReadyPromises.delete(nativeTab);\n      }\n    }\n  },\n\n  awaitTabReady(nativeTab) {\n    let deferred = this.tabReadyPromises.get(nativeTab);\n\n    if (!deferred) {\n      deferred = PromiseUtils.defer();\n\n      if (!this.initializingTabs.has(nativeTab) && (nativeTab.browser.innerWindowID || nativeTab.browser.currentURI.spec === \"about:blank\")) {\n        deferred.resolve(nativeTab);\n      } else {\n        this.initTabReady();\n        this.tabReadyPromises.set(nativeTab, deferred);\n      }\n    }\n\n    return deferred.promise;\n  }\n\n};"},{"filepath":"browser/components/extensions/parent/ext-tabs.js","kind":"let","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"let tabListener = {\n  tabReadyInitialized: false,\n  tabBlockedPromises: new WeakMap(),\n  tabReadyPromises: new WeakMap(),\n  initializingTabs: new WeakSet(),\n\n  initTabReady() {\n    if (!this.tabReadyInitialized) {\n      windowTracker.addListener(\"progress\", this);\n      this.tabReadyInitialized = true;\n    }\n  },\n\n  onLocationChange(browser, webProgress, request, locationURI, flags) {\n    if (webProgress.isTopLevel) {\n      let {\n        gBrowser\n      } = browser.ownerGlobal;\n      let nativeTab = gBrowser.getTabForBrowser(browser);\n      this.initializingTabs.delete(nativeTab);\n      let deferred = this.tabReadyPromises.get(nativeTab);\n\n      if (deferred) {\n        deferred.resolve(nativeTab);\n        this.tabReadyPromises.delete(nativeTab);\n      }\n    }\n  },\n\n  blockTabUntilRestored(nativeTab) {\n    let promise = ExtensionUtils.promiseEvent(nativeTab, \"SSTabRestored\").then(({\n      target\n    }) => {\n      this.tabBlockedPromises.delete(target);\n      return target;\n    });\n    this.tabBlockedPromises.set(nativeTab, promise);\n  },\n\n  awaitTabReady(nativeTab) {\n    let deferred = this.tabReadyPromises.get(nativeTab);\n\n    if (!deferred) {\n      let promise = this.tabBlockedPromises.get(nativeTab);\n\n      if (promise) {\n        return promise;\n      }\n\n      deferred = PromiseUtils.defer();\n\n      if (!this.initializingTabs.has(nativeTab) && (nativeTab.linkedBrowser.innerWindowID || nativeTab.linkedBrowser.currentURI.spec === \"about:blank\")) {\n        deferred.resolve(nativeTab);\n      } else {\n        this.initTabReady();\n        this.tabReadyPromises.set(nativeTab, deferred);\n      }\n    }\n\n    return deferred.promise;\n  }\n\n};"}],"SAME_SITE_STATUSES":[{"filepath":"toolkit/components/extensions/parent/ext-cookies.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const SAME_SITE_STATUSES = [\"no_restriction\", \"lax\", \"strict\"];"}],"isIPv4":[{"filepath":"toolkit/components/extensions/parent/ext-cookies.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const isIPv4 = host => {\n  let match = /^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/.exec(host);\n\n  if (match) {\n    return match[1] < 256 && match[2] < 256 && match[3] < 256 && match[4] < 256;\n  }\n\n  return false;\n};"}],"isIPv6":[{"filepath":"toolkit/components/extensions/parent/ext-cookies.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const isIPv6 = host => host.includes(\":\");"}],"addBracketIfIPv6":[{"filepath":"toolkit/components/extensions/parent/ext-cookies.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const addBracketIfIPv6 = host => isIPv6(host) && !host.startsWith(\"[\") ? `[${host}]` : host;"}],"dropBracketIfIPv6":[{"filepath":"toolkit/components/extensions/parent/ext-cookies.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const dropBracketIfIPv6 = host => isIPv6(host) && host.startsWith(\"[\") && host.endsWith(\"]\") ? host.slice(1, -1) : host;"}],"convertCookie":[{"filepath":"toolkit/components/extensions/parent/ext-cookies.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const convertCookie = ({\n  cookie,\n  isPrivate\n}) => {\n  let result = {\n    name: cookie.name,\n    value: cookie.value,\n    domain: addBracketIfIPv6(cookie.host),\n    hostOnly: !cookie.isDomain,\n    path: cookie.path,\n    secure: cookie.isSecure,\n    httpOnly: cookie.isHttpOnly,\n    sameSite: SAME_SITE_STATUSES[cookie.sameSite],\n    session: cookie.isSession,\n    firstPartyDomain: cookie.originAttributes.firstPartyDomain || \"\"\n  };\n\n  if (!cookie.isSession) {\n    result.expirationDate = cookie.expiry;\n  }\n\n  if (cookie.originAttributes.userContextId) {\n    result.storeId = getCookieStoreIdForContainer(cookie.originAttributes.userContextId);\n  } else if (cookie.originAttributes.privateBrowsingId || isPrivate) {\n    result.storeId = PRIVATE_STORE;\n  } else {\n    result.storeId = DEFAULT_STORE;\n  }\n\n  return result;\n};"}],"isSubdomain":[{"filepath":"toolkit/components/extensions/parent/ext-cookies.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const isSubdomain = (otherDomain, baseDomain) => {\n  return otherDomain == baseDomain || otherDomain.endsWith(\".\" + baseDomain);\n};"}],"checkSetCookiePermissions":[{"filepath":"toolkit/components/extensions/parent/ext-cookies.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const checkSetCookiePermissions = (extension, uri, cookie) => {\n  if (uri.scheme != \"http\" && uri.scheme != \"https\") {\n    return false;\n  }\n\n  if (!extension.whiteListedHosts.matches(uri)) {\n    return false;\n  }\n\n  if (!cookie.host) {\n    cookie.host = uri.host;\n    return true;\n  }\n\n  if (cookie.host.length > 1) {\n    cookie.host = cookie.host.replace(/^\\./, \"\");\n  }\n\n  cookie.host = cookie.host.toLowerCase();\n  cookie.host = dropBracketIfIPv6(cookie.host);\n\n  if (cookie.host != uri.host) {\n    let baseDomain;\n\n    try {\n      baseDomain = Services.eTLD.getBaseDomain(uri);\n    } catch (e) {\n      if (e.result == Cr.NS_ERROR_HOST_IS_IP_ADDRESS || e.result == Cr.NS_ERROR_INSUFFICIENT_DOMAIN_LEVELS) {\n        return false;\n      }\n\n      throw e;\n    }\n\n    if (!isSubdomain(cookie.host, baseDomain) || !isSubdomain(uri.host, cookie.host)) {\n      return false;\n    }\n  }\n\n  if (isIPv6(cookie.host) || isIPv4(cookie.host)) {\n    return true;\n  }\n\n  cookie.host = \".\" + cookie.host;\n  return true;\n};"}],"query":[{"filepath":"toolkit/components/extensions/parent/ext-cookies.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const query = function* (detailsIn, props, context) {\n  let details = {};\n  props.forEach(property => {\n    if (detailsIn[property] !== null) {\n      details[property] = detailsIn[property];\n    }\n  });\n\n  if (\"domain\" in details) {\n    details.domain = details.domain.toLowerCase().replace(/^\\./, \"\");\n    details.domain = dropBracketIfIPv6(details.domain);\n  }\n\n  let userContextId = 0;\n  let isPrivate = context.incognito;\n\n  if (details.storeId) {\n    if (!isValidCookieStoreId(details.storeId)) {\n      return;\n    }\n\n    if (isDefaultCookieStoreId(details.storeId)) {\n      isPrivate = false;\n    } else if (isPrivateCookieStoreId(details.storeId)) {\n      isPrivate = true;\n    } else if (isContainerCookieStoreId(details.storeId)) {\n      isPrivate = false;\n      userContextId = getContainerForCookieStoreId(details.storeId);\n\n      if (!userContextId) {\n        return;\n      }\n    }\n  }\n\n  let storeId = DEFAULT_STORE;\n\n  if (isPrivate) {\n    storeId = PRIVATE_STORE;\n  } else if (\"storeId\" in details) {\n    storeId = details.storeId;\n  }\n\n  if (storeId == PRIVATE_STORE && !context.privateBrowsingAllowed) {\n    throw new ExtensionError(\"Extension disallowed access to the private cookies storeId.\");\n  }\n\n  let enumerator;\n  let host;\n  let url;\n  let originAttributes = {\n    userContextId,\n    privateBrowsingId: isPrivate ? 1 : 0\n  };\n\n  if (\"firstPartyDomain\" in details) {\n    originAttributes.firstPartyDomain = details.firstPartyDomain;\n  }\n\n  if (\"url\" in details) {\n    try {\n      url = new URL(details.url);\n      host = dropBracketIfIPv6(url.hostname);\n    } catch (ex) {\n      return;\n    }\n  } else if (\"domain\" in details) {\n    host = details.domain;\n  }\n\n  if (host && \"firstPartyDomain\" in originAttributes) {\n    enumerator = Services.cookies.getCookiesFromHost(host, originAttributes);\n  } else {\n    enumerator = Services.cookies.getCookiesWithOriginAttributes(JSON.stringify(originAttributes), host);\n  }\n\n  function matches(cookie) {\n    function domainMatches(host) {\n      return cookie.rawHost == host || cookie.isDomain && host.endsWith(cookie.host);\n    }\n\n    function pathMatches(path) {\n      let cookiePath = cookie.path.replace(/\\/$/, \"\");\n\n      if (!path.startsWith(cookiePath)) {\n        return false;\n      }\n\n      if (path.length == cookiePath.length) {\n        return true;\n      }\n\n      return path[cookiePath.length] === \"/\";\n    }\n\n    if (url) {\n      if (!domainMatches(host)) {\n        return false;\n      }\n\n      if (cookie.isSecure && url.protocol != \"https:\") {\n        return false;\n      }\n\n      if (!pathMatches(url.pathname)) {\n        return false;\n      }\n    }\n\n    if (\"name\" in details && details.name != cookie.name) {\n      return false;\n    }\n\n    if (\"domain\" in details && !isSubdomain(cookie.rawHost, details.domain)) {\n      return false;\n    }\n\n    if (\"path\" in details && details.path != cookie.path) {\n      return false;\n    }\n\n    if (\"secure\" in details && details.secure != cookie.isSecure) {\n      return false;\n    }\n\n    if (\"session\" in details && details.session != cookie.isSession) {\n      return false;\n    }\n\n    if (!context.extension.whiteListedHosts.matchesCookie(cookie)) {\n      return false;\n    }\n\n    return true;\n  }\n\n  for (const cookie of enumerator) {\n    if (matches(cookie)) {\n      yield {\n        cookie,\n        isPrivate,\n        storeId\n      };\n    }\n  }\n};"}],"normalizeFirstPartyDomain":[{"filepath":"toolkit/components/extensions/parent/ext-cookies.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const normalizeFirstPartyDomain = details => {\n  if (details.firstPartyDomain != null) {\n    return;\n  }\n\n  if (Services.prefs.getBoolPref(\"privacy.firstparty.isolate\")) {\n    throw new ExtensionError(\"First-Party Isolation is enabled, but the required 'firstPartyDomain' attribute was not set.\");\n  }\n\n  details.firstPartyDomain = \"\";\n};"}],"cookies":[{"filepath":"toolkit/components/extensions/parent/ext-cookies.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.cookies = class extends ExtensionAPI {\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    let self = {\n      cookies: {\n        get: function (details) {\n          normalizeFirstPartyDomain(details);\n          let allowed = [\"url\", \"name\", \"storeId\", \"firstPartyDomain\"];\n\n          for (let cookie of query(details, allowed, context)) {\n            return Promise.resolve(convertCookie(cookie));\n          }\n\n          return Promise.resolve(null);\n        },\n        getAll: function (details) {\n          if (!(\"firstPartyDomain\" in details)) {\n            normalizeFirstPartyDomain(details);\n          }\n\n          let allowed = [\"url\", \"name\", \"domain\", \"path\", \"secure\", \"session\", \"storeId\"];\n\n          if (details.firstPartyDomain != null) {\n            allowed.push(\"firstPartyDomain\");\n          }\n\n          let result = Array.from(query(details, allowed, context), convertCookie);\n          return Promise.resolve(result);\n        },\n        set: function (details) {\n          normalizeFirstPartyDomain(details);\n          let uri = Services.io.newURI(details.url);\n          let path;\n\n          if (details.path !== null) {\n            path = details.path;\n          } else {\n            path = uri.QueryInterface(Ci.nsIURL).directory;\n          }\n\n          let name = details.name !== null ? details.name : \"\";\n          let value = details.value !== null ? details.value : \"\";\n          let secure = details.secure !== null ? details.secure : false;\n          let httpOnly = details.httpOnly !== null ? details.httpOnly : false;\n          let isSession = details.expirationDate === null;\n          let expiry = isSession ? Number.MAX_SAFE_INTEGER : details.expirationDate;\n          let isPrivate = context.incognito;\n          let userContextId = 0;\n\n          if (isDefaultCookieStoreId(details.storeId)) {\n            isPrivate = false;\n          } else if (isPrivateCookieStoreId(details.storeId)) {\n            if (!context.privateBrowsingAllowed) {\n              return Promise.reject({\n                message: \"Extension disallowed access to the private cookies storeId.\"\n              });\n            }\n\n            isPrivate = true;\n          } else if (isContainerCookieStoreId(details.storeId)) {\n            let containerId = getContainerForCookieStoreId(details.storeId);\n\n            if (containerId === null) {\n              return Promise.reject({\n                message: `Illegal storeId: ${details.storeId}`\n              });\n            }\n\n            isPrivate = false;\n            userContextId = containerId;\n          } else if (details.storeId !== null) {\n            return Promise.reject({\n              message: \"Unknown storeId\"\n            });\n          }\n\n          let cookieAttrs = {\n            host: details.domain,\n            path: path,\n            isSecure: secure\n          };\n\n          if (!checkSetCookiePermissions(extension, uri, cookieAttrs)) {\n            return Promise.reject({\n              message: `Permission denied to set cookie ${JSON.stringify(details)}`\n            });\n          }\n\n          let originAttributes = {\n            userContextId,\n            privateBrowsingId: isPrivate ? 1 : 0,\n            firstPartyDomain: details.firstPartyDomain\n          };\n          let sameSite = SAME_SITE_STATUSES.indexOf(details.sameSite);\n          Services.cookies.add(cookieAttrs.host, path, name, value, secure, httpOnly, isSession, expiry, originAttributes, sameSite);\n          return self.cookies.get(details);\n        },\n        remove: function (details) {\n          normalizeFirstPartyDomain(details);\n          let allowed = [\"url\", \"name\", \"storeId\", \"firstPartyDomain\"];\n\n          for (let {\n            cookie,\n            storeId\n          } of query(details, allowed, context)) {\n            if (isPrivateCookieStoreId(details.storeId) && !context.privateBrowsingAllowed) {\n              return Promise.reject({\n                message: \"Unknown storeId\"\n              });\n            }\n\n            Services.cookies.remove(cookie.host, cookie.name, cookie.path, cookie.originAttributes);\n            return Promise.resolve({\n              url: details.url,\n              name: details.name,\n              storeId,\n              firstPartyDomain: details.firstPartyDomain\n            });\n          }\n\n          return Promise.resolve(null);\n        },\n        getAllCookieStores: function () {\n          let data = {};\n\n          for (let tab of extension.tabManager.query()) {\n            if (!(tab.cookieStoreId in data)) {\n              data[tab.cookieStoreId] = [];\n            }\n\n            data[tab.cookieStoreId].push(tab.id);\n          }\n\n          let result = [];\n\n          for (let key in data) {\n            result.push({\n              id: key,\n              tabIds: data[key],\n              incognito: key == PRIVATE_STORE\n            });\n          }\n\n          return Promise.resolve(result);\n        },\n        onChanged: new EventManager({\n          context,\n          name: \"cookies.onChanged\",\n          register: fire => {\n            let observer = (subject, topic, data) => {\n              let notify = (removed, cookie, cause) => {\n                cookie.QueryInterface(Ci.nsICookie);\n\n                if (extension.whiteListedHosts.matchesCookie(cookie)) {\n                  fire.async({\n                    removed,\n                    cookie: convertCookie({\n                      cookie,\n                      isPrivate: topic == \"private-cookie-changed\"\n                    }),\n                    cause\n                  });\n                }\n              };\n\n              switch (data) {\n                case \"deleted\":\n                  notify(true, subject, \"explicit\");\n                  break;\n\n                case \"added\":\n                  notify(false, subject, \"explicit\");\n                  break;\n\n                case \"changed\":\n                  notify(true, subject, \"overwrite\");\n                  notify(false, subject, \"explicit\");\n                  break;\n\n                case \"batch-deleted\":\n                  subject.QueryInterface(Ci.nsIArray);\n\n                  for (let i = 0; i < subject.length; i++) {\n                    let cookie = subject.queryElementAt(i, Ci.nsICookie);\n\n                    if (!cookie.isSession && cookie.expiry * 1000 <= Date.now()) {\n                      notify(true, cookie, \"expired\");\n                    } else {\n                      notify(true, cookie, \"evicted\");\n                    }\n                  }\n\n                  break;\n              }\n            };\n\n            Services.obs.addObserver(observer, \"cookie-changed\");\n\n            if (context.privateBrowsingAllowed) {\n              Services.obs.addObserver(observer, \"private-cookie-changed\");\n            }\n\n            return () => {\n              Services.obs.removeObserver(observer, \"cookie-changed\");\n\n              if (context.privateBrowsingAllowed) {\n                Services.obs.removeObserver(observer, \"private-cookie-changed\");\n              }\n            };\n          }\n        }).api()\n      }\n    };\n    return self;\n  }\n\n}"}],"DEFAULT_SEARCH_STORE_TYPE":[{"filepath":"browser/components/extensions/parent/ext-chrome-settings-overrides.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const DEFAULT_SEARCH_STORE_TYPE = \"default_search\";"}],"DEFAULT_SEARCH_SETTING_NAME":[{"filepath":"browser/components/extensions/parent/ext-chrome-settings-overrides.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const DEFAULT_SEARCH_SETTING_NAME = \"defaultSearch\";"}],"ENGINE_ADDED_SETTING_NAME":[{"filepath":"browser/components/extensions/parent/ext-chrome-settings-overrides.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const ENGINE_ADDED_SETTING_NAME = \"engineAdded\";"}],"HOMEPAGE_PREF":[{"filepath":"browser/components/extensions/parent/ext-chrome-settings-overrides.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const HOMEPAGE_PREF = \"browser.startup.homepage\";"}],"HOMEPAGE_PRIVATE_ALLOWED":[{"filepath":"browser/components/extensions/parent/ext-chrome-settings-overrides.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const HOMEPAGE_PRIVATE_ALLOWED = \"browser.startup.homepage_override.privateAllowed\";"}],"HOMEPAGE_EXTENSION_CONTROLLED":[{"filepath":"browser/components/extensions/parent/ext-chrome-settings-overrides.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const HOMEPAGE_EXTENSION_CONTROLLED = \"browser.startup.homepage_override.extensionControlled\";"}],"HOMEPAGE_CONFIRMED_TYPE":[{"filepath":"browser/components/extensions/parent/ext-chrome-settings-overrides.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const HOMEPAGE_CONFIRMED_TYPE = \"homepageNotification\";"}],"HOMEPAGE_SETTING_TYPE":[{"filepath":"browser/components/extensions/parent/ext-chrome-settings-overrides.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const HOMEPAGE_SETTING_TYPE = \"prefs\";"}],"HOMEPAGE_SETTING_NAME":[{"filepath":"browser/components/extensions/parent/ext-chrome-settings-overrides.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const HOMEPAGE_SETTING_NAME = \"homepage_override\";"}],"handleInitialHomepagePopup":[{"filepath":"browser/components/extensions/parent/ext-chrome-settings-overrides.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"async function handleInitialHomepagePopup(extensionId, homepageUrl) {\n  if (Services.prefs.getIntPref(\"browser.startup.page\") == 1) {\n    let {\n      gBrowser\n    } = windowTracker.topWindow;\n    let tab = gBrowser.selectedTab;\n    let currentUrl = gBrowser.currentURI.spec;\n\n    if (currentUrl != homepageUrl && currentUrl == \"about:blank\") {\n      await waitForTabLoaded(tab);\n      currentUrl = gBrowser.currentURI.spec;\n    }\n\n    if (currentUrl == homepageUrl && gBrowser.selectedTab == tab) {\n      homepagePopup.open();\n      return;\n    }\n  }\n\n  homepagePopup.addObserver(extensionId);\n}"}],"handleHomepageUrl":[{"filepath":"browser/components/extensions/parent/ext-chrome-settings-overrides.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"async function handleHomepageUrl(extension, homepageUrl) {\n  let inControl;\n\n  if (extension.startupReason == \"ADDON_INSTALL\" || extension.startupReason == \"ADDON_ENABLE\") {\n    inControl = await ExtensionPreferencesManager.setSetting(extension.id, \"homepage_override\", homepageUrl);\n  } else {\n    let item = await ExtensionPreferencesManager.getSetting(\"homepage_override\");\n    inControl = item && item.id == extension.id;\n  }\n\n  if (inControl) {\n    Services.prefs.setBoolPref(HOMEPAGE_PRIVATE_ALLOWED, extension.privateBrowsingAllowed);\n    Services.prefs.setBoolPref(HOMEPAGE_EXTENSION_CONTROLLED, true);\n\n    if (extension.startupReason == \"APP_STARTUP\") {\n      handleInitialHomepagePopup(extension.id, homepageUrl);\n    } else {\n      homepagePopup.addObserver(extension.id);\n    }\n  }\n\n  extension.on(\"add-permissions\", async (ignoreEvent, permissions) => {\n    if (permissions.permissions.includes(\"internal:privateBrowsingAllowed\")) {\n      let item = await ExtensionPreferencesManager.getSetting(\"homepage_override\");\n\n      if (item && item.id == extension.id) {\n        Services.prefs.setBoolPref(HOMEPAGE_PRIVATE_ALLOWED, true);\n      }\n    }\n  });\n  extension.on(\"remove-permissions\", async (ignoreEvent, permissions) => {\n    if (permissions.permissions.includes(\"internal:privateBrowsingAllowed\")) {\n      let item = await ExtensionPreferencesManager.getSetting(\"homepage_override\");\n\n      if (item && item.id == extension.id) {\n        Services.prefs.setBoolPref(HOMEPAGE_PRIVATE_ALLOWED, false);\n      }\n    }\n  });\n}"}],"pendingSearchSetupTasks":[{"filepath":"browser/components/extensions/parent/ext-chrome-settings-overrides.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var pendingSearchSetupTasks = new Map();"}],"chrome_settings_overrides":[{"filepath":"browser/components/extensions/parent/ext-chrome-settings-overrides.js","kind":"globalThisAssignment","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"this.chrome_settings_overrides = class extends ExtensionAPI {\n  static async processDefaultSearchSetting(action, id) {\n    await ExtensionSettingsStore.initialize();\n    let item = ExtensionSettingsStore.getSetting(DEFAULT_SEARCH_STORE_TYPE, DEFAULT_SEARCH_SETTING_NAME);\n\n    if (!item) {\n      return;\n    }\n\n    if (Services.search.defaultEngine.name != item.value && Services.search.defaultEngine.name != item.initialValue) {\n      ExtensionSettingsStore.removeSetting(id, DEFAULT_SEARCH_STORE_TYPE, DEFAULT_SEARCH_SETTING_NAME);\n      return;\n    }\n\n    item = ExtensionSettingsStore[action](id, DEFAULT_SEARCH_STORE_TYPE, DEFAULT_SEARCH_SETTING_NAME);\n\n    if (item) {\n      try {\n        let engine = Services.search.getEngineByName(item.value || item.initialValue);\n\n        if (engine) {\n          Services.search.defaultEngine = engine;\n        }\n      } catch (e) {\n        Cu.reportError(e);\n      }\n    }\n  }\n\n  static async removeEngine(id) {\n    await ExtensionSettingsStore.initialize();\n    let item = await ExtensionSettingsStore.getSetting(DEFAULT_SEARCH_STORE_TYPE, ENGINE_ADDED_SETTING_NAME, id);\n\n    if (item) {\n      ExtensionSettingsStore.removeSetting(id, DEFAULT_SEARCH_STORE_TYPE, ENGINE_ADDED_SETTING_NAME);\n    }\n\n    if (!Services.search.isInitialized) {\n      return;\n    }\n\n    try {\n      let engines = await Services.search.getEnginesByExtensionID(id);\n\n      if (engines.length) {\n        await Services.search.removeWebExtensionEngine(id);\n      }\n    } catch (e) {\n      Cu.reportError(e);\n    }\n  }\n\n  static removeSearchSettings(id) {\n    return Promise.all([this.processDefaultSearchSetting(\"removeSetting\", id), this.removeEngine(id)]);\n  }\n\n  static async onUninstall(id) {\n    let searchStartupPromise = pendingSearchSetupTasks.get(id);\n\n    if (searchStartupPromise) {\n      await searchStartupPromise;\n    }\n\n    return Promise.all([this.removeSearchSettings(id), homepagePopup.clearConfirmation(id)]);\n  }\n\n  static async onUpdate(id, manifest) {\n    let haveHomepage = manifest && manifest.chrome_settings_overrides && manifest.chrome_settings_overrides.homepage;\n\n    if (!haveHomepage) {\n      ExtensionPreferencesManager.removeSetting(id, \"homepage_override\");\n    }\n\n    let haveSearchProvider = manifest && manifest.chrome_settings_overrides && manifest.chrome_settings_overrides.search_provider;\n\n    if (!haveSearchProvider) {\n      this.removeSearchSettings(id);\n    } else if (!!haveSearchProvider.is_default && (await ExtensionSettingsStore.initialize()) && ExtensionSettingsStore.hasSetting(id, DEFAULT_SEARCH_STORE_TYPE, DEFAULT_SEARCH_SETTING_NAME)) {\n      chrome_settings_overrides.processDefaultSearchSetting(\"removeSetting\", id);\n    }\n  }\n\n  static onDisable(id) {\n    homepagePopup.clearConfirmation(id);\n    chrome_settings_overrides.processDefaultSearchSetting(\"disable\", id);\n    chrome_settings_overrides.removeEngine(id);\n  }\n\n  async onManifestEntry(entryName) {\n    let {\n      extension\n    } = this;\n    let {\n      manifest\n    } = extension;\n    let homepageUrl = manifest.chrome_settings_overrides.homepage;\n\n    if (homepageUrl) {\n      const ignoreHomePageUrl = await HomePage.shouldIgnore(homepageUrl);\n\n      if (ignoreHomePageUrl) {\n        Services.telemetry.recordEvent(\"homepage\", \"preference\", \"ignore\", \"set_blocked_extension\", {\n          webExtensionId: extension.id\n        });\n      } else {\n        await handleHomepageUrl(extension, homepageUrl);\n      }\n    }\n\n    if (manifest.chrome_settings_overrides.search_provider) {\n      let searchStartupPromise = this.processSearchProviderManifestEntry().finally(() => {\n        if (pendingSearchSetupTasks.get(extension.id) === searchStartupPromise) {\n          pendingSearchSetupTasks.delete(extension.id);\n        }\n      });\n      pendingSearchSetupTasks.set(extension.id, searchStartupPromise);\n    }\n  }\n\n  async processSearchProviderManifestEntry() {\n    let {\n      extension\n    } = this;\n    let {\n      manifest\n    } = extension;\n    let searchProvider = manifest.chrome_settings_overrides.search_provider;\n\n    if (searchProvider.is_default) {\n      await searchInitialized;\n\n      if (!this.extension) {\n        Cu.reportError(`Extension shut down before search provider was registered`);\n        return;\n      }\n    }\n\n    let engineName = searchProvider.name.trim();\n\n    if (searchProvider.is_default) {\n      let engine = Services.search.getEngineByName(engineName);\n      let defaultEngines = await Services.search.getDefaultEngines();\n\n      if (engine && defaultEngines.some(defaultEngine => defaultEngine.name == engineName)) {\n        await this.setDefault(engineName);\n        return;\n      }\n    }\n\n    await this.addSearchEngine();\n\n    if (searchProvider.is_default) {\n      if (extension.startupReason === \"ADDON_INSTALL\") {\n        let engine = Services.search.getEngineByName(engineName);\n        let defaultEngine = await Services.search.getDefault();\n\n        if (defaultEngine.name != engine.name) {\n          let subject = {\n            wrappedJSObject: {\n              browser: windowTracker.topWindow.gBrowser.selectedBrowser,\n              name: this.extension.name,\n              icon: this.extension.iconURL,\n              currentEngine: defaultEngine.name,\n              newEngine: engineName,\n\n              async respond(allow) {\n                if (allow) {\n                  await ExtensionSettingsStore.initialize();\n                  ExtensionSettingsStore.addSetting(extension.id, DEFAULT_SEARCH_STORE_TYPE, DEFAULT_SEARCH_SETTING_NAME, engineName, () => defaultEngine.name);\n                  Services.search.defaultEngine = Services.search.getEngineByName(engineName);\n                }\n              }\n\n            }\n          };\n          Services.obs.notifyObservers(subject, \"webextension-defaultsearch-prompt\");\n        }\n      } else {\n        this.setDefault(engineName);\n      }\n    }\n  }\n\n  async setDefault(engineName) {\n    let {\n      extension\n    } = this;\n\n    if (extension.startupReason === \"ADDON_INSTALL\") {\n      let defaultEngine = await Services.search.getDefault();\n      await ExtensionSettingsStore.initialize();\n      let item = await ExtensionSettingsStore.addSetting(extension.id, DEFAULT_SEARCH_STORE_TYPE, DEFAULT_SEARCH_SETTING_NAME, engineName, () => defaultEngine.name);\n      await Services.search.setDefault(Services.search.getEngineByName(item.value));\n    } else if (extension.startupReason === \"ADDON_ENABLE\") {\n      chrome_settings_overrides.processDefaultSearchSetting(\"enable\", extension.id);\n    }\n  }\n\n  async addSearchEngine() {\n    let {\n      extension\n    } = this;\n    let isCurrent = false;\n    let index = -1;\n\n    if (extension.startupReason === \"ADDON_UPGRADE\" && !extension.addonData.builtIn) {\n      let engines = await Services.search.getEnginesByExtensionID(extension.id);\n\n      if (engines.length) {\n        let firstEngine = engines[0];\n        let firstEngineName = firstEngine.name;\n        isCurrent = (await Services.search.getDefault()).name == firstEngineName;\n        index = (await Services.search.getEngines()).map(engine => engine.name).indexOf(firstEngineName);\n        await Services.search.removeEngine(firstEngine);\n      }\n    }\n\n    try {\n      let engines = await Services.search.addEnginesFromExtension(extension);\n\n      if (engines.length) {\n        await ExtensionSettingsStore.initialize();\n        await ExtensionSettingsStore.addSetting(extension.id, DEFAULT_SEARCH_STORE_TYPE, ENGINE_ADDED_SETTING_NAME, engines[0].name);\n      }\n\n      if (extension.startupReason === \"ADDON_UPGRADE\" && !extension.addonData.builtIn) {\n        let engines = await Services.search.getEnginesByExtensionID(extension.id);\n        let engine = Services.search.getEngineByName(engines[0].name);\n\n        if (isCurrent) {\n          await Services.search.setDefault(engine);\n        }\n\n        if (index != -1) {\n          await Services.search.moveEngine(engine, index);\n        }\n      }\n    } catch (e) {\n      Cu.reportError(e);\n      return false;\n    }\n\n    return true;\n  }\n\n}"}],"WEBEXT_PANELS_URL":[{"filepath":"browser/components/extensions/parent/ext-devtools-panels.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const WEBEXT_PANELS_URL = \"chrome://browser/content/webext-panels.xul\";"}],"sidebarsById":[{"filepath":"browser/components/extensions/parent/ext-devtools-panels.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const sidebarsById = new Map();"}],"EventDispatcher":[{"filepath":"mobile/android/components/extensions/ext-utils.js","kind":"var","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"var {\n  EventDispatcher\n} = ChromeUtils.import(\"resource://gre/modules/Messaging.jsm\");"}],"defineLazyGetter":[{"filepath":"mobile/android/components/extensions/ext-utils.js","kind":"var","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"var {\n  defineLazyGetter\n} = ExtensionCommon;"},{"filepath":"browser/components/extensions/parent/ext-browser.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  defineLazyGetter\n} = ExtensionCommon;"},{"filepath":"toolkit/components/extensions/parent/ext-tabs-base.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  defineLazyGetter\n} = ExtensionCommon;"}],"BrowserStatusFilter":[{"filepath":"mobile/android/components/extensions/ext-utils.js","kind":"const","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"const BrowserStatusFilter = Components.Constructor(\"@mozilla.org/appshell/component/browser-status-filter;1\", \"nsIWebProgress\", \"addProgressListener\");"}],"WINDOW_TYPE":[{"filepath":"mobile/android/components/extensions/ext-utils.js","kind":"const","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"const WINDOW_TYPE = Services.androidBridge.isFennec ? \"navigator:browser\" : \"navigator:geckoview\";"}],"tabTracker":[{"filepath":"mobile/android/components/extensions/ext-utils.js","kind":"let","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"let tabTracker;"},{"filepath":"browser/components/extensions/parent/ext-browser.js","kind":"let","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"let tabTracker;"}],"windowTracker":[{"filepath":"mobile/android/components/extensions/ext-utils.js","kind":"let","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"let windowTracker;"},{"filepath":"browser/components/extensions/parent/ext-browser.js","kind":"let","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"let windowTracker;"}],"PROGRESS_LISTENER_FLAGS":[{"filepath":"mobile/android/components/extensions/ext-utils.js","kind":"const","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"const PROGRESS_LISTENER_FLAGS = Ci.nsIWebProgress.NOTIFY_STATE_ALL | Ci.nsIWebProgress.NOTIFY_LOCATION;"}],"ProgressListenerWrapper":[{"filepath":"mobile/android/components/extensions/ext-utils.js","kind":"const","metadata":{"toolkit":false,"browser":false,"mobile":true,"parent":false,"child":false},"jscode":"const ProgressListenerWrapper = Services.androidBridge.isFennec ? FennecProgressListenerWrapper : GeckoViewProgressListenerWrapper;"}],"EventEmitter":[{"filepath":"toolkit/components/extensions/parent/ext-downloads.js","kind":"var","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"var {\n  EventEmitter,\n  ignoreEvent\n} = ExtensionCommon;"}],"DOWNLOAD_ITEM_FIELDS":[{"filepath":"toolkit/components/extensions/parent/ext-downloads.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const DOWNLOAD_ITEM_FIELDS = [\"id\", \"url\", \"referrer\", \"filename\", \"incognito\", \"danger\", \"mime\", \"startTime\", \"endTime\", \"estimatedEndTime\", \"state\", \"paused\", \"canResume\", \"error\", \"bytesReceived\", \"totalBytes\", \"fileSize\", \"exists\", \"byExtensionId\", \"byExtensionName\"];"}],"DOWNLOAD_DATE_FIELDS":[{"filepath":"toolkit/components/extensions/parent/ext-downloads.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const DOWNLOAD_DATE_FIELDS = [\"startTime\", \"endTime\", \"estimatedEndTime\"];"}],"DOWNLOAD_ITEM_CHANGE_FIELDS":[{"filepath":"toolkit/components/extensions/parent/ext-downloads.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const DOWNLOAD_ITEM_CHANGE_FIELDS = [\"endTime\", \"state\", \"paused\", \"canResume\", \"error\", \"exists\"];"}],"FORBIDDEN_HEADERS":[{"filepath":"toolkit/components/extensions/parent/ext-downloads.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const FORBIDDEN_HEADERS = [\"ACCEPT-CHARSET\", \"ACCEPT-ENCODING\", \"ACCESS-CONTROL-REQUEST-HEADERS\", \"ACCESS-CONTROL-REQUEST-METHOD\", \"CONNECTION\", \"CONTENT-LENGTH\", \"COOKIE\", \"COOKIE2\", \"DATE\", \"DNT\", \"EXPECT\", \"HOST\", \"KEEP-ALIVE\", \"ORIGIN\", \"TE\", \"TRAILER\", \"TRANSFER-ENCODING\", \"UPGRADE\", \"VIA\"];"}],"FORBIDDEN_PREFIXES":[{"filepath":"toolkit/components/extensions/parent/ext-downloads.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const FORBIDDEN_PREFIXES = /^PROXY-|^SEC-/i;"}],"PROMPTLESS_DOWNLOAD_PREF":[{"filepath":"toolkit/components/extensions/parent/ext-downloads.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const PROMPTLESS_DOWNLOAD_PREF = \"browser.download.useDownloadDir\";"}],"DownloadMap":[{"filepath":"toolkit/components/extensions/parent/ext-downloads.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const DownloadMap = new class extends EventEmitter {\n  constructor() {\n    super();\n    this.currentId = 0;\n    this.loadPromise = null;\n    this.byId = new Map();\n    this.byDownload = new WeakMap();\n  }\n\n  lazyInit() {\n    if (this.loadPromise == null) {\n      this.loadPromise = Downloads.getList(Downloads.ALL).then(list => {\n        let self = this;\n        return list.addView({\n          onDownloadAdded(download) {\n            const item = self.newFromDownload(download, null);\n            self.emit(\"create\", item);\n\n            item._storePrechange();\n          },\n\n          onDownloadRemoved(download) {\n            const item = self.byDownload.get(download);\n\n            if (item != null) {\n              self.emit(\"erase\", item);\n              self.byDownload.delete(download);\n              self.byId.delete(item.id);\n            }\n          },\n\n          onDownloadChanged(download) {\n            const item = self.byDownload.get(download);\n\n            if (item == null) {\n              Cu.reportError(\"Got onDownloadChanged for unknown download object\");\n            } else {\n              self.emit(\"change\", item);\n\n              item._storePrechange();\n            }\n          }\n\n        }).then(() => list.getAll()).then(downloads => {\n          downloads.forEach(download => {\n            this.newFromDownload(download, null);\n          });\n        }).then(() => list);\n      });\n    }\n\n    return this.loadPromise;\n  }\n\n  getDownloadList() {\n    return this.lazyInit();\n  }\n\n  getAll() {\n    return this.lazyInit().then(() => this.byId.values());\n  }\n\n  fromId(id, privateAllowed = true) {\n    const download = this.byId.get(id);\n\n    if (!download || !privateAllowed && download.incognito) {\n      throw new Error(`Invalid download id ${id}`);\n    }\n\n    return download;\n  }\n\n  newFromDownload(download, extension) {\n    if (this.byDownload.has(download)) {\n      return this.byDownload.get(download);\n    }\n\n    const id = ++this.currentId;\n    let item = new DownloadItem(id, download, extension);\n    this.byId.set(id, item);\n    this.byDownload.set(download, item);\n    return item;\n  }\n\n  erase(item) {\n    return this.getDownloadList().then(list => {\n      list.remove(item.download);\n    });\n  }\n\n}();"}],"downloadQuery":[{"filepath":"toolkit/components/extensions/parent/ext-downloads.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const downloadQuery = query => {\n  let queryTerms = [];\n  let queryNegativeTerms = [];\n\n  if (query.query != null) {\n    for (let term of query.query) {\n      if (term[0] == \"-\") {\n        queryNegativeTerms.push(term.slice(1).toLowerCase());\n      } else {\n        queryTerms.push(term.toLowerCase());\n      }\n    }\n  }\n\n  function normalizeDownloadTime(arg, before) {\n    if (arg == null) {\n      return before ? Number.MAX_VALUE : 0;\n    }\n\n    return ExtensionCommon.normalizeTime(arg).getTime();\n  }\n\n  const startedBefore = normalizeDownloadTime(query.startedBefore, true);\n  const startedAfter = normalizeDownloadTime(query.startedAfter, false);\n  const totalBytesGreater = query.totalBytesGreater !== null ? query.totalBytesGreater : -1;\n  const totalBytesLess = query.totalBytesLess !== null ? query.totalBytesLess : Number.MAX_VALUE;\n\n  function makeMatch(regex, value, field) {\n    if (value == null && regex == null) {\n      return input => true;\n    }\n\n    let re;\n\n    try {\n      re = new RegExp(regex || \"\", \"i\");\n    } catch (err) {\n      throw new Error(`Invalid ${field}Regex: ${err.message}`);\n    }\n\n    if (value == null) {\n      return input => re.test(input);\n    }\n\n    value = value.toLowerCase();\n\n    if (re.test(value)) {\n      return input => value == input;\n    }\n\n    return input => false;\n  }\n\n  const matchFilename = makeMatch(query.filenameRegex, query.filename, \"filename\");\n  const matchUrl = makeMatch(query.urlRegex, query.url, \"url\");\n  return function (item) {\n    const url = item.url.toLowerCase();\n    const filename = item.filename.toLowerCase();\n\n    if (!queryTerms.every(term => url.includes(term) || filename.includes(term))) {\n      return false;\n    }\n\n    if (queryNegativeTerms.some(term => url.includes(term) || filename.includes(term))) {\n      return false;\n    }\n\n    if (!matchFilename(filename) || !matchUrl(url)) {\n      return false;\n    }\n\n    if (!item.startTime) {\n      if (query.startedBefore != null || query.startedAfter != null) {\n        return false;\n      }\n    } else if (item.startTime > startedBefore || item.startTime < startedAfter) {\n      return false;\n    }\n\n    if (item.totalBytes == -1) {\n      if (query.totalBytesGreater !== null || query.totalBytesLess !== null) {\n        return false;\n      }\n    } else if (item.totalBytes <= totalBytesGreater || item.totalBytes >= totalBytesLess) {\n      return false;\n    }\n\n    const SIMPLE_ITEMS = [\"id\", \"mime\", \"startTime\", \"endTime\", \"state\", \"paused\", \"error\", \"incognito\", \"bytesReceived\", \"totalBytes\", \"fileSize\", \"exists\"];\n\n    for (let field of SIMPLE_ITEMS) {\n      if (query[field] != null && item[field] != query[field]) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n};"}],"queryHelper":[{"filepath":"toolkit/components/extensions/parent/ext-downloads.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const queryHelper = query => {\n  let matchFn;\n\n  try {\n    matchFn = downloadQuery(query);\n  } catch (err) {\n    return Promise.reject({\n      message: err.message\n    });\n  }\n\n  let compareFn;\n\n  if (query.orderBy != null) {\n    const fields = query.orderBy.map(field => field[0] == \"-\" ? {\n      reverse: true,\n      name: field.slice(1)\n    } : {\n      reverse: false,\n      name: field\n    });\n\n    for (let field of fields) {\n      if (!DOWNLOAD_ITEM_FIELDS.includes(field.name)) {\n        return Promise.reject({\n          message: `Invalid orderBy field ${field.name}`\n        });\n      }\n    }\n\n    compareFn = (dl1, dl2) => {\n      for (let field of fields) {\n        const val1 = dl1[field.name];\n        const val2 = dl2[field.name];\n\n        if (val1 < val2) {\n          return field.reverse ? 1 : -1;\n        } else if (val1 > val2) {\n          return field.reverse ? -1 : 1;\n        }\n      }\n\n      return 0;\n    };\n  }\n\n  return DownloadMap.getAll().then(downloads => {\n    if (compareFn) {\n      downloads = Array.from(downloads);\n      downloads.sort(compareFn);\n    }\n\n    let results = [];\n\n    for (let download of downloads) {\n      if (query.limit && results.length >= query.limit) {\n        break;\n      }\n\n      if (matchFn(download)) {\n        results.push(download);\n      }\n    }\n\n    return results;\n  });\n};"}],"downloadEventManagerAPI":[{"filepath":"toolkit/components/extensions/parent/ext-downloads.js","kind":"function","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"function downloadEventManagerAPI(context, name, event, listener) {\n  let register = fire => {\n    const handler = (what, item) => {\n      if (context.privateBrowsingAllowed || !item.incognito) {\n        listener(fire, what, item);\n      }\n    };\n\n    let registerPromise = DownloadMap.getDownloadList().then(() => {\n      DownloadMap.on(event, handler);\n    });\n    return () => {\n      registerPromise.then(() => {\n        DownloadMap.off(event, handler);\n      });\n    };\n  };\n\n  return new EventManager({\n    context,\n    name,\n    register\n  }).api();\n}"}],"downloads":[{"filepath":"toolkit/components/extensions/parent/ext-downloads.js","kind":"globalThisAssignment","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"this.downloads = class extends ExtensionAPI {\n  getAPI(context) {\n    let {\n      extension\n    } = context;\n    return {\n      downloads: {\n        download(options) {\n          let {\n            filename\n          } = options;\n\n          if (filename && AppConstants.platform === \"win\") {\n            filename = filename.replace(/\\//g, \"\\\\\");\n          }\n\n          if (filename != null) {\n            if (!filename.length) {\n              return Promise.reject({\n                message: \"filename must not be empty\"\n              });\n            }\n\n            let path = OS.Path.split(filename);\n\n            if (path.absolute) {\n              return Promise.reject({\n                message: \"filename must not be an absolute path\"\n              });\n            }\n\n            if (path.components.some(component => component == \"..\")) {\n              return Promise.reject({\n                message: \"filename must not contain back-references (..)\"\n              });\n            }\n\n            if (path.components.some(component => component != DownloadPaths.sanitize(component))) {\n              return Promise.reject({\n                message: \"filename must not contain illegal characters\"\n              });\n            }\n          }\n\n          if (options.incognito && !context.privateBrowsingAllowed) {\n            return Promise.reject({\n              message: \"private browsing access not allowed\"\n            });\n          }\n\n          if (options.conflictAction == \"prompt\") {\n            return Promise.reject({\n              message: \"conflictAction prompt not yet implemented\"\n            });\n          }\n\n          if (options.headers) {\n            for (let {\n              name\n            } of options.headers) {\n              if (FORBIDDEN_HEADERS.includes(name.toUpperCase()) || name.match(FORBIDDEN_PREFIXES)) {\n                return Promise.reject({\n                  message: \"Forbidden request header name\"\n                });\n              }\n            }\n          }\n\n          function adjustChannel(channel) {\n            if (channel instanceof Ci.nsIHttpChannel) {\n              const method = options.method || \"GET\";\n              channel.requestMethod = method;\n\n              if (options.headers) {\n                for (let {\n                  name,\n                  value\n                } of options.headers) {\n                  channel.setRequestHeader(name, value, false);\n                }\n              }\n\n              if (options.body != null) {\n                const stream = Cc[\"@mozilla.org/io/string-input-stream;1\"].createInstance(Ci.nsIStringInputStream);\n                stream.setData(options.body, options.body.length);\n                channel.QueryInterface(Ci.nsIUploadChannel2);\n                channel.explicitSetUploadStream(stream, null, -1, method, false);\n              }\n            }\n\n            return Promise.resolve();\n          }\n\n          function allowHttpStatus(download, status) {\n            const item = DownloadMap.byDownload.get(download);\n\n            if (item === null) {\n              return true;\n            }\n\n            let error = null;\n\n            switch (status) {\n              case 204:\n              case 205:\n              case 404:\n                error = \"SERVER_BAD_CONTENT\";\n                break;\n\n              case 403:\n                error = \"SERVER_FORBIDDEN\";\n                break;\n\n              case 402:\n              case 407:\n                error = \"SERVER_UNAUTHORIZED\";\n                break;\n\n              default:\n                if (status >= 400) {\n                  error = \"SERVER_FAILED\";\n                }\n\n                break;\n            }\n\n            if (error) {\n              item.error = error;\n              return false;\n            }\n\n            return true;\n          }\n\n          async function createTarget(downloadsDir) {\n            if (!filename) {\n              let uri = Services.io.newURI(options.url);\n\n              if (uri instanceof Ci.nsIURL) {\n                filename = DownloadPaths.sanitize(Services.textToSubURI.unEscapeURIForUI(\"UTF-8\", uri.fileName));\n              }\n            }\n\n            let target = OS.Path.join(downloadsDir, filename || \"download\");\n            let saveAs;\n\n            if (options.saveAs !== null) {\n              saveAs = options.saveAs;\n            } else {\n              saveAs = !Services.prefs.getBoolPref(PROMPTLESS_DOWNLOAD_PREF, true);\n            }\n\n            const dir = OS.Path.dirname(target);\n            await OS.File.makeDir(dir, {\n              from: downloadsDir\n            });\n\n            if (await OS.File.exists(target)) {\n              switch (options.conflictAction) {\n                case \"uniquify\":\n                default:\n                  target = DownloadPaths.createNiceUniqueFile(new FileUtils.File(target)).path;\n\n                  if (saveAs) {\n                    await OS.File.remove(target);\n                  }\n\n                  break;\n\n                case \"overwrite\":\n                  break;\n              }\n            }\n\n            if (!saveAs || AppConstants.platform === \"android\") {\n              return target;\n            }\n\n            const window = Services.wm.getMostRecentWindow(\"navigator:browser\");\n            const basename = OS.Path.basename(target);\n            const ext = basename.match(/\\.([^.]+)$/);\n            const picker = Cc[\"@mozilla.org/filepicker;1\"].createInstance(Ci.nsIFilePicker);\n            picker.init(window, null, Ci.nsIFilePicker.modeSave);\n            picker.displayDirectory = new FileUtils.File(dir);\n            picker.appendFilters(Ci.nsIFilePicker.filterAll);\n            picker.defaultString = basename;\n            picker.defaultExtension = ext && ext[1];\n            return new Promise((resolve, reject) => {\n              picker.open(result => {\n                if (result === Ci.nsIFilePicker.returnCancel) {\n                  reject({\n                    message: \"Download canceled by the user\"\n                  });\n                } else {\n                  resolve(picker.file.path);\n                }\n              });\n            });\n          }\n\n          let download;\n          return Downloads.getPreferredDownloadsDirectory().then(downloadsDir => createTarget(downloadsDir)).then(target => {\n            const source = {\n              url: options.url,\n              isPrivate: options.incognito\n            };\n\n            if (!options.allowHttpErrors) {\n              source.allowHttpStatus = allowHttpStatus;\n            }\n\n            if (options.method || options.headers || options.body) {\n              source.adjustChannel = adjustChannel;\n            }\n\n            return Downloads.createDownload({\n              source,\n              target: {\n                path: target,\n                partFilePath: target + \".part\"\n              }\n            });\n          }).then(dl => {\n            download = dl;\n            return DownloadMap.getDownloadList();\n          }).then(list => {\n            const item = DownloadMap.newFromDownload(download, extension);\n            list.add(download);\n            download.tryToKeepPartialData = true;\n            download.start().catch(() => {});\n            return item.id;\n          });\n        },\n\n        removeFile(id) {\n          return DownloadMap.lazyInit().then(() => {\n            let item;\n\n            try {\n              item = DownloadMap.fromId(id, context.privateBrowsingAllowed);\n            } catch (err) {\n              return Promise.reject({\n                message: `Invalid download id ${id}`\n              });\n            }\n\n            if (item.state !== \"complete\") {\n              return Promise.reject({\n                message: `Cannot remove incomplete download id ${id}`\n              });\n            }\n\n            return OS.File.remove(item.filename, {\n              ignoreAbsent: false\n            }).catch(err => {\n              return Promise.reject({\n                message: `Could not remove download id ${item.id} because the file doesn't exist`\n              });\n            });\n          });\n        },\n\n        search(query) {\n          if (!context.privateBrowsingAllowed) {\n            query.incognito = false;\n          }\n\n          return queryHelper(query).then(items => items.map(item => item.serialize()));\n        },\n\n        pause(id) {\n          return DownloadMap.lazyInit().then(() => {\n            let item;\n\n            try {\n              item = DownloadMap.fromId(id, context.privateBrowsingAllowed);\n            } catch (err) {\n              return Promise.reject({\n                message: `Invalid download id ${id}`\n              });\n            }\n\n            if (item.state != \"in_progress\") {\n              return Promise.reject({\n                message: `Download ${id} cannot be paused since it is in state ${item.state}`\n              });\n            }\n\n            return item.download.cancel();\n          });\n        },\n\n        resume(id) {\n          return DownloadMap.lazyInit().then(() => {\n            let item;\n\n            try {\n              item = DownloadMap.fromId(id, context.privateBrowsingAllowed);\n            } catch (err) {\n              return Promise.reject({\n                message: `Invalid download id ${id}`\n              });\n            }\n\n            if (!item.canResume) {\n              return Promise.reject({\n                message: `Download ${id} cannot be resumed`\n              });\n            }\n\n            item.error = null;\n            return item.download.start();\n          });\n        },\n\n        cancel(id) {\n          return DownloadMap.lazyInit().then(() => {\n            let item;\n\n            try {\n              item = DownloadMap.fromId(id, context.privateBrowsingAllowed);\n            } catch (err) {\n              return Promise.reject({\n                message: `Invalid download id ${id}`\n              });\n            }\n\n            if (item.download.succeeded) {\n              return Promise.reject({\n                message: `Download ${id} is already complete`\n              });\n            }\n\n            return item.download.finalize(true);\n          });\n        },\n\n        showDefaultFolder() {\n          Downloads.getPreferredDownloadsDirectory().then(dir => {\n            let dirobj = new FileUtils.File(dir);\n\n            if (dirobj.isDirectory()) {\n              dirobj.launch();\n            } else {\n              throw new Error(`Download directory ${dirobj.path} is not actually a directory`);\n            }\n          }).catch(Cu.reportError);\n        },\n\n        erase(query) {\n          if (!context.privateBrowsingAllowed) {\n            query.incognito = false;\n          }\n\n          return queryHelper(query).then(items => {\n            let results = [];\n            let promises = [];\n\n            for (let item of items) {\n              promises.push(DownloadMap.erase(item));\n              results.push(item.id);\n            }\n\n            return Promise.all(promises).then(() => results);\n          });\n        },\n\n        open(downloadId) {\n          return DownloadMap.lazyInit().then(() => {\n            let download = DownloadMap.fromId(downloadId, context.privateBrowsingAllowed).download;\n\n            if (download.succeeded) {\n              return download.launch();\n            }\n\n            return Promise.reject({\n              message: \"Download has not completed.\"\n            });\n          }).catch(error => {\n            return Promise.reject({\n              message: error.message\n            });\n          });\n        },\n\n        show(downloadId) {\n          return DownloadMap.lazyInit().then(() => {\n            let download = DownloadMap.fromId(downloadId, context.privateBrowsingAllowed);\n            return download.download.showContainingDirectory();\n          }).then(() => {\n            return true;\n          }).catch(error => {\n            return Promise.reject({\n              message: error.message\n            });\n          });\n        },\n\n        getFileIcon(downloadId, options) {\n          return DownloadMap.lazyInit().then(() => {\n            let size = options && options.size ? options.size : 32;\n            let download = DownloadMap.fromId(downloadId, context.privateBrowsingAllowed).download;\n            let pathPrefix = \"\";\n            let path;\n\n            if (download.succeeded) {\n              let file = FileUtils.File(download.target.path);\n              path = Services.io.newFileURI(file).spec;\n            } else {\n              path = OS.Path.basename(download.target.path);\n              pathPrefix = \"//\";\n            }\n\n            return new Promise((resolve, reject) => {\n              let chromeWebNav = Services.appShell.createWindowlessBrowser(true);\n              let system = Services.scriptSecurityManager.getSystemPrincipal();\n              chromeWebNav.docShell.createAboutBlankContentViewer(system, system);\n              let img = chromeWebNav.document.createElement(\"img\");\n              img.width = size;\n              img.height = size;\n              let handleLoad;\n              let handleError;\n\n              const cleanup = () => {\n                img.removeEventListener(\"load\", handleLoad);\n                img.removeEventListener(\"error\", handleError);\n                chromeWebNav.close();\n                chromeWebNav = null;\n              };\n\n              handleLoad = () => {\n                let canvas = chromeWebNav.document.createElement(\"canvas\");\n                canvas.width = size;\n                canvas.height = size;\n                let context = canvas.getContext(\"2d\");\n                context.drawImage(img, 0, 0, size, size);\n                let dataURL = canvas.toDataURL(\"image/png\");\n                cleanup();\n                resolve(dataURL);\n              };\n\n              handleError = error => {\n                Cu.reportError(error);\n                cleanup();\n                reject(new Error(\"An unexpected error occurred\"));\n              };\n\n              img.addEventListener(\"load\", handleLoad);\n              img.addEventListener(\"error\", handleError);\n              img.src = `moz-icon:${pathPrefix}${path}?size=${size}`;\n            });\n          }).catch(error => {\n            return Promise.reject({\n              message: error.message\n            });\n          });\n        },\n\n        onChanged: downloadEventManagerAPI(context, \"downloads.onChanged\", \"change\", (fire, what, item) => {\n          let changes = {};\n\n          const noundef = val => val === undefined ? null : val;\n\n          DOWNLOAD_ITEM_CHANGE_FIELDS.forEach(fld => {\n            if (item[fld] != item.prechange[fld]) {\n              changes[fld] = {\n                previous: noundef(item.prechange[fld]),\n                current: noundef(item[fld])\n              };\n            }\n          });\n\n          if (Object.keys(changes).length) {\n            changes.id = item.id;\n            fire.async(changes);\n          }\n        }),\n        onCreated: downloadEventManagerAPI(context, \"downloads.onCreated\", \"create\", (fire, what, item) => {\n          fire.async(item.serialize());\n        }),\n        onErased: downloadEventManagerAPI(context, \"downloads.onErased\", \"erase\", (fire, what, item) => {\n          fire.async(item.id);\n        }),\n        onDeterminingFilename: ignoreEvent(context, \"downloads.onDeterminingFilename\")\n      }\n    };\n  }\n\n}"}],"POPUP_PRELOAD_TIMEOUT_MS":[{"filepath":"browser/components/extensions/parent/ext-browserAction.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const POPUP_PRELOAD_TIMEOUT_MS = 200;"}],"READER_MODE_PREFIX":[{"filepath":"browser/components/extensions/parent/ext-browser.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const READER_MODE_PREFIX = \"about:reader\";"}],"isPrivateTab":[{"filepath":"browser/components/extensions/parent/ext-browser.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function isPrivateTab(nativeTab) {\n  return PrivateBrowsingUtils.isBrowserPrivate(nativeTab.linkedBrowser);\n}"}],"isPrivateWindow":[{"filepath":"browser/components/extensions/parent/ext-browser.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function isPrivateWindow(window) {\n  return PrivateBrowsingUtils.isContentWindowPrivate(window);\n}"}],"ACTION_MENU_TOP_LEVEL_LIMIT":[{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const ACTION_MENU_TOP_LEVEL_LIMIT = 6;"}],"gMenuMap":[{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var gMenuMap = new Map();"}],"gRootItems":[{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var gRootItems = new Map();"}],"gShownMenuItems":[{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var gShownMenuItems = new DefaultMap(() => []);"}],"gOnShownSubscribers":[{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var gOnShownSubscribers = new Set();"}],"gNextRadioGroupID":[{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var gNextRadioGroupID = 0;"}],"gMaxLabelLength":[{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var gMaxLabelLength = 64;"}],"gMenuBuilder":[{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"var","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"var gMenuBuilder = {\n  build(contextData) {\n    contextData = this.maybeOverrideContextData(contextData);\n    let xulMenu = contextData.menu;\n    xulMenu.addEventListener(\"popuphidden\", this);\n    this.xulMenu = xulMenu;\n\n    for (let [, root] of gRootItems) {\n      this.createAndInsertTopLevelElements(root, contextData, null);\n    }\n\n    this.afterBuildingMenu(contextData);\n\n    if (contextData.webExtContextData && !contextData.webExtContextData.showDefaults) {\n      Promise.resolve().then(() => this.hideDefaultMenuItems());\n    }\n  },\n\n  maybeOverrideContextData(contextData) {\n    let {\n      webExtContextData\n    } = contextData;\n\n    if (!webExtContextData || !webExtContextData.overrideContext) {\n      return contextData;\n    }\n\n    let contextDataBase = {\n      menu: contextData.menu,\n      originalViewType: getContextViewType(contextData),\n      originalViewUrl: contextData.inFrame ? contextData.frameUrl : contextData.pageUrl,\n      webExtContextData\n    };\n\n    if (webExtContextData.overrideContext === \"bookmark\") {\n      return { ...contextDataBase,\n        bookmarkId: webExtContextData.bookmarkId,\n        onBookmark: true\n      };\n    }\n\n    if (webExtContextData.overrideContext === \"tab\") {\n      let tab = tabTracker.getTab(webExtContextData.tabId);\n      return { ...contextDataBase,\n        tab,\n        pageUrl: tab.linkedBrowser.currentURI.spec,\n        onTab: true\n      };\n    }\n\n    throw new Error(`Unexpected overrideContext: ${webExtContextData.overrideContext}`);\n  },\n\n  canAccessContext(extension, contextData) {\n    if (!extension.privateBrowsingAllowed) {\n      let nativeTab = contextData.tab;\n\n      if (nativeTab && PrivateBrowsingUtils.isBrowserPrivate(nativeTab.linkedBrowser)) {\n        return false;\n      } else if (PrivateBrowsingUtils.isWindowPrivate(contextData.menu.ownerGlobal)) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  createAndInsertTopLevelElements(root, contextData, nextSibling) {\n    let rootElements;\n\n    if (!this.canAccessContext(root.extension, contextData)) {\n      return;\n    }\n\n    if (contextData.onBrowserAction || contextData.onPageAction) {\n      if (contextData.extension.id !== root.extension.id) {\n        return;\n      }\n\n      rootElements = this.buildTopLevelElements(root, contextData, ACTION_MENU_TOP_LEVEL_LIMIT, false);\n      nextSibling = nextSibling || this.xulMenu.firstElementChild;\n\n      if (rootElements.length && !this.itemsToCleanUp.has(nextSibling)) {\n        rootElements.push(this.xulMenu.ownerDocument.createXULElement(\"menuseparator\"));\n      }\n    } else if (contextData.webExtContextData) {\n      let {\n        extensionId,\n        showDefaults,\n        overrideContext\n      } = contextData.webExtContextData;\n\n      if (extensionId === root.extension.id) {\n        rootElements = this.buildTopLevelElements(root, contextData, Infinity, false);\n        nextSibling = nextSibling || this.xulMenu.querySelector(\":scope > #context-sep-navigation + *\");\n\n        if (rootElements.length && showDefaults && !this.itemsToCleanUp.has(nextSibling)) {\n          rootElements.push(this.xulMenu.ownerDocument.createXULElement(\"menuseparator\"));\n        }\n      } else if (!showDefaults && !overrideContext) {\n        return;\n      }\n    }\n\n    if (!rootElements) {\n      rootElements = this.buildTopLevelElements(root, contextData, 1, true);\n\n      if (rootElements.length && !this.itemsToCleanUp.has(this.xulMenu.lastElementChild)) {\n        rootElements.unshift(this.xulMenu.ownerDocument.createXULElement(\"menuseparator\"));\n      }\n    }\n\n    if (!rootElements.length) {\n      return;\n    }\n\n    if (nextSibling) {\n      nextSibling.before(...rootElements);\n    } else {\n      this.xulMenu.append(...rootElements);\n    }\n\n    for (let item of rootElements) {\n      this.itemsToCleanUp.add(item);\n    }\n  },\n\n  buildElementWithChildren(item, contextData) {\n    const element = this.buildSingleElement(item, contextData);\n    const children = this.buildChildren(item, contextData);\n\n    if (children.length) {\n      element.firstElementChild.append(...children);\n    }\n\n    return element;\n  },\n\n  buildChildren(item, contextData) {\n    let groupName;\n    let children = [];\n\n    for (let child of item.children) {\n      if (child.type == \"radio\" && !child.groupName) {\n        if (!groupName) {\n          groupName = `webext-radio-group-${gNextRadioGroupID++}`;\n        }\n\n        child.groupName = groupName;\n      } else {\n        groupName = null;\n      }\n\n      if (child.enabledForContext(contextData)) {\n        children.push(this.buildElementWithChildren(child, contextData));\n      }\n    }\n\n    return children;\n  },\n\n  buildTopLevelElements(root, contextData, maxCount, forceManifestIcons) {\n    let children = this.buildChildren(root, contextData);\n\n    if (children.length === 1 && maxCount === 1 && forceManifestIcons && AppConstants.platform === \"linux\" && children[0].getAttribute(\"type\") === \"checkbox\") {\n      maxCount = 0;\n    }\n\n    if (children.length > maxCount) {\n      let rootElement = this.buildSingleElement(root, contextData);\n      rootElement.setAttribute(\"ext-type\", \"top-level-menu\");\n      rootElement.firstElementChild.append(...children.splice(maxCount - 1));\n      children.push(rootElement);\n    }\n\n    if (forceManifestIcons) {\n      for (let rootElement of children) {\n        if (root.extension.manifest.icons) {\n          this.setMenuItemIcon(rootElement, root.extension, contextData, root.extension.manifest.icons);\n        } else {\n          this.removeMenuItemIcon(rootElement);\n        }\n      }\n    }\n\n    return children;\n  },\n\n  removeSeparatorIfNoTopLevelItems() {\n    let isNonExtensionSeparator = item => item.nodeName === \"menuseparator\" && !item.id;\n\n    let isExtensionMenuItemSibling = item => item && this.itemsToCleanUp.has(item) && !isNonExtensionSeparator(item);\n\n    for (let item of this.itemsToCleanUp) {\n      if (isNonExtensionSeparator(item)) {\n        if (!isExtensionMenuItemSibling(item.previousElementSibling) && !isExtensionMenuItemSibling(item.nextElementSibling)) {\n          item.remove();\n          this.itemsToCleanUp.delete(item);\n        }\n      }\n    }\n  },\n\n  buildSingleElement(item, contextData) {\n    let doc = contextData.menu.ownerDocument;\n    let element;\n\n    if (item.children.length) {\n      element = this.createMenuElement(doc, item);\n    } else if (item.type == \"separator\") {\n      element = doc.createXULElement(\"menuseparator\");\n    } else {\n      element = doc.createXULElement(\"menuitem\");\n    }\n\n    return this.customizeElement(element, item, contextData);\n  },\n\n  createMenuElement(doc, item) {\n    let element = doc.createXULElement(\"menu\");\n    let menupopup = doc.createXULElement(\"menupopup\");\n    element.appendChild(menupopup);\n    return element;\n  },\n\n  customizeElement(element, item, contextData) {\n    let label = item.title;\n\n    if (label) {\n      let accessKey;\n      label = label.replace(/&([\\S\\s]|$)/g, (_, nextChar, i) => {\n        if (nextChar === \"&\") {\n          return \"&\";\n        }\n\n        if (accessKey === undefined) {\n          if (nextChar === \"%\" && label.charAt(i + 2) === \"s\") {\n            accessKey = \"\";\n          } else {\n            accessKey = nextChar;\n          }\n        }\n\n        return nextChar;\n      });\n      element.setAttribute(\"accesskey\", accessKey || \"\");\n\n      if (contextData.isTextSelected && label.indexOf(\"%s\") > -1) {\n        let selection = contextData.selectionText.trim();\n        let codePointsToRemove = 0;\n        let selectionArray = Array.from(selection);\n        let completeLabelLength = label.length - 2 + selectionArray.length;\n\n        if (completeLabelLength > gMaxLabelLength) {\n          codePointsToRemove = completeLabelLength - gMaxLabelLength;\n        }\n\n        if (codePointsToRemove) {\n          let ellipsis = \"\\u2026\";\n\n          try {\n            ellipsis = Services.prefs.getComplexValue(\"intl.ellipsis\", Ci.nsIPrefLocalizedString).data;\n          } catch (e) {}\n\n          codePointsToRemove += 1;\n          selection = selectionArray.slice(0, -codePointsToRemove).join(\"\") + ellipsis;\n        }\n\n        label = label.replace(/%s/g, selection);\n      }\n\n      element.setAttribute(\"label\", label);\n    }\n\n    element.setAttribute(\"id\", item.elementId);\n\n    if (\"icons\" in item) {\n      if (item.icons) {\n        this.setMenuItemIcon(element, item.extension, contextData, item.icons);\n      } else {\n        this.removeMenuItemIcon(element);\n      }\n    }\n\n    if (item.type == \"checkbox\") {\n      element.setAttribute(\"type\", \"checkbox\");\n\n      if (item.checked) {\n        element.setAttribute(\"checked\", \"true\");\n      }\n    } else if (item.type == \"radio\") {\n      element.setAttribute(\"type\", \"radio\");\n      element.setAttribute(\"name\", item.groupName);\n\n      if (item.checked) {\n        element.setAttribute(\"checked\", \"true\");\n      }\n    }\n\n    if (!item.enabled) {\n      element.setAttribute(\"disabled\", \"true\");\n    }\n\n    let button;\n    element.addEventListener(\"command\", event => {\n      if (event.target !== event.currentTarget) {\n        return;\n      }\n\n      const wasChecked = item.checked;\n\n      if (item.type == \"checkbox\") {\n        item.checked = !item.checked;\n      } else if (item.type == \"radio\") {\n        for (let child of item.parent.children) {\n          if (child.type == \"radio\" && child.groupName == item.groupName) {\n            child.checked = false;\n          }\n        }\n\n        item.checked = true;\n      }\n\n      let {\n        webExtContextData\n      } = contextData;\n\n      if (contextData.tab && (!webExtContextData || webExtContextData.extensionId !== item.extension.id)) {\n        item.tabManager.addActiveTabPermission(contextData.tab);\n      }\n\n      let info = item.getClickInfo(contextData, wasChecked);\n      const map = {\n        shiftKey: \"Shift\",\n        altKey: \"Alt\",\n        metaKey: \"Command\",\n        ctrlKey: \"Ctrl\"\n      };\n      info.modifiers = Object.keys(map).filter(key => event[key]).map(key => map[key]);\n\n      if (event.ctrlKey && AppConstants.platform === \"macosx\") {\n        info.modifiers.push(\"MacCtrl\");\n      }\n\n      info.button = button;\n      let actionFor = {\n        _execute_page_action: global.pageActionFor,\n        _execute_browser_action: global.browserActionFor,\n        _execute_sidebar_action: global.sidebarActionFor\n      }[item.command];\n\n      if (actionFor) {\n        let win = event.target.ownerGlobal;\n        actionFor(item.extension).triggerAction(win);\n      }\n\n      item.extension.emit(\"webext-menu-menuitem-click\", info, contextData.tab);\n    }, {\n      once: true\n    });\n    element.addEventListener(\"click\", event => {\n      if (event.target !== event.currentTarget || element.localName !== \"menuitem\" || element.disabled) {\n        return;\n      }\n\n      button = event.button;\n\n      if (event.button) {\n        element.doCommand();\n        contextData.menu.hidePopup();\n      }\n    });\n\n    if (item.parent) {\n      gShownMenuItems.get(item.extension).push(item.id);\n    }\n\n    return element;\n  },\n\n  setMenuItemIcon(element, extension, contextData, icons) {\n    let parentWindow = contextData.menu.ownerGlobal;\n    let {\n      icon\n    } = IconDetails.getPreferredIcon(icons, extension, 16 * parentWindow.devicePixelRatio);\n    let resolvedURL = extension.baseURI.resolve(icon);\n\n    if (element.localName == \"menu\") {\n      element.setAttribute(\"class\", \"menu-iconic\");\n    } else if (element.localName == \"menuitem\") {\n      element.setAttribute(\"class\", \"menuitem-iconic\");\n    }\n\n    element.setAttribute(\"image\", resolvedURL);\n  },\n\n  removeMenuItemIcon(element) {\n    element.removeAttribute(\"class\");\n    element.removeAttribute(\"image\");\n  },\n\n  rebuildMenu(extension) {\n    let {\n      contextData\n    } = this;\n\n    if (!contextData) {\n      return;\n    }\n\n    let elementIdPrefix = `${makeWidgetId(extension.id)}-menuitem-`;\n    let nextSibling = null;\n\n    for (let item of this.itemsToCleanUp) {\n      if (item.id && item.id.startsWith(elementIdPrefix)) {\n        nextSibling = item.nextSibling;\n        item.remove();\n        this.itemsToCleanUp.delete(item);\n      }\n    }\n\n    let root = gRootItems.get(extension);\n\n    if (root) {\n      this.createAndInsertTopLevelElements(root, contextData, nextSibling);\n    }\n\n    this.removeSeparatorIfNoTopLevelItems();\n  },\n\n  afterBuildingMenu(contextData) {\n    let dispatchOnShownEvent = extension => {\n      if (!this.canAccessContext(extension, contextData)) {\n        return;\n      }\n\n      let menuIds = gShownMenuItems.get(extension);\n      extension.emit(\"webext-menu-shown\", menuIds, contextData);\n    };\n\n    if (contextData.onBrowserAction || contextData.onPageAction) {\n      dispatchOnShownEvent(contextData.extension);\n    } else {\n      gOnShownSubscribers.forEach(dispatchOnShownEvent);\n    }\n\n    this.contextData = contextData;\n  },\n\n  hideDefaultMenuItems() {\n    for (let item of this.xulMenu.children) {\n      if (!this.itemsToCleanUp.has(item)) {\n        item.hidden = true;\n      }\n    }\n  },\n\n  handleEvent(event) {\n    if (this.xulMenu != event.target || event.type != \"popuphidden\") {\n      return;\n    }\n\n    delete this.xulMenu;\n    delete this.contextData;\n    let target = event.target;\n    target.removeEventListener(\"popuphidden\", this);\n\n    for (let item of this.itemsToCleanUp) {\n      item.remove();\n    }\n\n    this.itemsToCleanUp.clear();\n\n    for (let extension of gShownMenuItems.keys()) {\n      extension.emit(\"webext-menu-hidden\");\n    }\n\n    gShownMenuItems.clear();\n  },\n\n  itemsToCleanUp: new Set()\n};"}],"contextsMap":[{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const contextsMap = {\n  onAudio: \"audio\",\n  onEditable: \"editable\",\n  inFrame: \"frame\",\n  onImage: \"image\",\n  onLink: \"link\",\n  onPassword: \"password\",\n  isTextSelected: \"selection\",\n  onVideo: \"video\",\n  onBookmark: \"bookmark\",\n  onBrowserAction: \"browser_action\",\n  onPageAction: \"page_action\",\n  onTab: \"tab\",\n  inToolsMenu: \"tools_menu\"\n};"}],"getMenuContexts":[{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const getMenuContexts = contextData => {\n  let contexts = new Set();\n\n  for (const [key, value] of Object.entries(contextsMap)) {\n    if (contextData[key]) {\n      contexts.add(value);\n    }\n  }\n\n  if (contexts.size === 0) {\n    contexts.add(\"page\");\n  }\n\n  if (!contextData.onBookmark && !contextData.onTab && !contextData.inToolsMenu) {\n    contexts.add(\"all\");\n  }\n\n  return contexts;\n};"}],"getContextViewType":[{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function getContextViewType(contextData) {\n  if (\"originalViewType\" in contextData) {\n    return contextData.originalViewType;\n  }\n\n  if (contextData.webExtBrowserType === \"popup\" || contextData.webExtBrowserType === \"sidebar\") {\n    return contextData.webExtBrowserType;\n  }\n\n  if (contextData.tab && contextData.menu.id === \"contentAreaContextMenu\") {\n    return \"tab\";\n  }\n\n  return undefined;\n}"}],"addMenuEventInfo":[{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function addMenuEventInfo(info, contextData, extension, includeSensitiveData) {\n  info.viewType = getContextViewType(contextData);\n\n  if (contextData.onVideo) {\n    info.mediaType = \"video\";\n  } else if (contextData.onAudio) {\n    info.mediaType = \"audio\";\n  } else if (contextData.onImage) {\n    info.mediaType = \"image\";\n  }\n\n  if (contextData.frameId !== undefined) {\n    info.frameId = contextData.frameId;\n  }\n\n  if (contextData.onBookmark) {\n    info.bookmarkId = contextData.bookmarkId;\n  }\n\n  info.editable = contextData.onEditable || false;\n\n  if (includeSensitiveData) {\n    if (contextData.timeStamp && extension.hasPermission(\"menus\")) {\n      info.targetElementId = Math.floor(contextData.timeStamp);\n    }\n\n    if (contextData.onLink) {\n      info.linkText = contextData.linkText;\n      info.linkUrl = contextData.linkUrl;\n    }\n\n    if (contextData.onAudio || contextData.onImage || contextData.onVideo) {\n      info.srcUrl = contextData.srcUrl;\n    }\n\n    if (!contextData.onBookmark) {\n      info.pageUrl = contextData.pageUrl;\n    }\n\n    if (contextData.inFrame) {\n      info.frameUrl = contextData.frameUrl;\n    }\n\n    if (contextData.isTextSelected) {\n      info.selectionText = contextData.selectionText;\n    }\n  }\n\n  if (contextData.originalViewUrl) {\n    info.frameUrl = contextData.originalViewUrl;\n  }\n}"}],"MenuItem":[{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function MenuItem(extension, createProperties, isRoot = false) {\n  this.extension = extension;\n  this.children = [];\n  this.parent = null;\n  this.tabManager = extension.tabManager;\n  this.setDefaults();\n  this.setProps(createProperties);\n\n  if (!this.hasOwnProperty(\"_id\")) {\n    this.id = gNextMenuItemID++;\n  }\n\n  if (!isRoot && !this.parent) {\n    this.root.addChild(this);\n  }\n}"}],"libraryTracker":[{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const libraryTracker = {\n  libraryWindowType: \"Places:Organizer\",\n\n  isLibraryWindow(window) {\n    let winType = window.document.documentElement.getAttribute(\"windowtype\");\n    return winType === this.libraryWindowType;\n  },\n\n  init(listener) {\n    this._listener = listener;\n    Services.ww.registerNotification(this);\n\n    for (let window of Services.wm.getEnumerator(\"\")) {\n      if (window.document.readyState === \"complete\") {\n        if (this.isLibraryWindow(window)) {\n          this.notify(window);\n        }\n      } else {\n        window.addEventListener(\"load\", this, {\n          once: true\n        });\n      }\n    }\n  },\n\n  uninit(cleanupWindow) {\n    Services.ww.unregisterNotification(this);\n\n    for (let window of Services.wm.getEnumerator(\"\")) {\n      window.removeEventListener(\"load\", this);\n\n      try {\n        if (this.isLibraryWindow(window)) {\n          cleanupWindow(window);\n        }\n      } catch (e) {\n        Cu.reportError(e);\n      }\n    }\n  },\n\n  observe(window, topic) {\n    if (topic === \"domwindowopened\") {\n      window.addEventListener(\"load\", this, {\n        once: true\n      });\n    }\n  },\n\n  handleEvent(event) {\n    let window = event.target.defaultView;\n\n    if (this.isLibraryWindow(window)) {\n      this.notify(window);\n    }\n  },\n\n  notify(window) {\n    try {\n      this._listener.call(null, window);\n    } catch (e) {\n      Cu.reportError(e);\n    }\n  }\n\n};"}],"menuTracker":[{"filepath":"browser/components/extensions/parent/ext-menus.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const menuTracker = {\n  menuIds: [\"placesContext\", \"menu_ToolsPopup\", \"tabContextMenu\"],\n\n  register() {\n    Services.obs.addObserver(this, \"on-build-contextmenu\");\n\n    for (const window of windowTracker.browserWindows()) {\n      this.onWindowOpen(window);\n    }\n\n    windowTracker.addOpenListener(this.onWindowOpen);\n    libraryTracker.init(this.onLibraryOpen);\n  },\n\n  unregister() {\n    Services.obs.removeObserver(this, \"on-build-contextmenu\");\n\n    for (const window of windowTracker.browserWindows()) {\n      this.cleanupWindow(window);\n    }\n\n    windowTracker.removeOpenListener(this.onWindowOpen);\n    libraryTracker.uninit(this.cleanupLibrary);\n  },\n\n  observe(subject, topic, data) {\n    subject = subject.wrappedJSObject;\n    gMenuBuilder.build(subject);\n  },\n\n  async onWindowOpen(window) {\n    for (const id of menuTracker.menuIds) {\n      const menu = window.document.getElementById(id);\n      menu.addEventListener(\"popupshowing\", menuTracker);\n    }\n\n    const sidebarHeader = window.document.getElementById(\"sidebar-switcher-target\");\n    sidebarHeader.addEventListener(\"SidebarShown\", menuTracker.onSidebarShown);\n    await window.SidebarUI.promiseInitialized;\n\n    if (!window.closed && window.SidebarUI.currentID === \"viewBookmarksSidebar\") {\n      menuTracker.onSidebarShown({\n        currentTarget: sidebarHeader\n      });\n    }\n  },\n\n  cleanupWindow(window) {\n    for (const id of this.menuIds) {\n      const menu = window.document.getElementById(id);\n      menu.removeEventListener(\"popupshowing\", this);\n    }\n\n    const sidebarHeader = window.document.getElementById(\"sidebar-switcher-target\");\n    sidebarHeader.removeEventListener(\"SidebarShown\", this.onSidebarShown);\n\n    if (window.SidebarUI.currentID === \"viewBookmarksSidebar\") {\n      let sidebarBrowser = window.SidebarUI.browser;\n      sidebarBrowser.removeEventListener(\"load\", this.onSidebarShown);\n      const menu = sidebarBrowser.contentDocument.getElementById(\"placesContext\");\n      menu.removeEventListener(\"popupshowing\", this.onBookmarksContextMenu);\n    }\n  },\n\n  onSidebarShown(event) {\n    const window = event.currentTarget.ownerGlobal;\n\n    if (window.SidebarUI.currentID === \"viewBookmarksSidebar\") {\n      let sidebarBrowser = window.SidebarUI.browser;\n\n      if (sidebarBrowser.contentDocument.readyState !== \"complete\") {\n        sidebarBrowser.addEventListener(\"load\", menuTracker.onSidebarShown, {\n          once: true\n        });\n        return;\n      }\n\n      const menu = sidebarBrowser.contentDocument.getElementById(\"placesContext\");\n      menu.addEventListener(\"popupshowing\", menuTracker.onBookmarksContextMenu);\n    }\n  },\n\n  onLibraryOpen(window) {\n    const menu = window.document.getElementById(\"placesContext\");\n    menu.addEventListener(\"popupshowing\", menuTracker.onBookmarksContextMenu);\n  },\n\n  cleanupLibrary(window) {\n    const menu = window.document.getElementById(\"placesContext\");\n    menu.removeEventListener(\"popupshowing\", menuTracker.onBookmarksContextMenu);\n  },\n\n  handleEvent(event) {\n    const menu = event.target;\n\n    if (menu.id === \"placesContext\") {\n      const trigger = menu.triggerNode;\n\n      if (!trigger._placesNode) {\n        return;\n      }\n\n      gMenuBuilder.build({\n        menu,\n        bookmarkId: trigger._placesNode.bookmarkGuid,\n        onBookmark: true\n      });\n    }\n\n    if (menu.id === \"menu_ToolsPopup\") {\n      const tab = tabTracker.activeTab;\n      const pageUrl = tab.linkedBrowser.currentURI.spec;\n      gMenuBuilder.build({\n        menu,\n        tab,\n        pageUrl,\n        inToolsMenu: true\n      });\n    }\n\n    if (menu.id === \"tabContextMenu\") {\n      let trigger = menu.triggerNode;\n\n      while (trigger && trigger.localName != \"tab\") {\n        trigger = trigger.parentNode;\n      }\n\n      const tab = trigger || tabTracker.activeTab;\n      const pageUrl = tab.linkedBrowser.currentURI.spec;\n      gMenuBuilder.build({\n        menu,\n        tab,\n        pageUrl,\n        onTab: true\n      });\n    }\n  },\n\n  onBookmarksContextMenu(event) {\n    const menu = event.target;\n    const tree = menu.triggerNode.parentElement;\n    const cell = tree.getCellAt(event.x, event.y);\n    const node = tree.view.nodeForTreeIndex(cell.row);\n\n    if (!node.bookmarkGuid || Bookmarks.isVirtualRootItem(node.bookmarkGuid)) {\n      return;\n    }\n\n    gMenuBuilder.build({\n      menu,\n      bookmarkId: node.bookmarkGuid,\n      onBookmark: true\n    });\n  }\n\n};"}],"TABHIDE_PREFNAME":[{"filepath":"browser/components/extensions/parent/ext-tabs.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const TABHIDE_PREFNAME = \"extensions.webextensions.tabhide.enabled\";"}],"MULTISELECT_PREFNAME":[{"filepath":"browser/components/extensions/parent/ext-tabs.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const MULTISELECT_PREFNAME = \"browser.tabs.multiselect\";"}],"TAB_HIDE_CONFIRMED_TYPE":[{"filepath":"browser/components/extensions/parent/ext-tabs.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const TAB_HIDE_CONFIRMED_TYPE = \"tabHideNotification\";"}],"TAB_ID_NONE":[{"filepath":"browser/components/extensions/parent/ext-tabs.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const TAB_ID_NONE = -1;"}],"showHiddenTabs":[{"filepath":"browser/components/extensions/parent/ext-tabs.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function showHiddenTabs(id) {\n  for (let win of Services.wm.getEnumerator(\"navigator:browser\")) {\n    if (win.closed || !win.gBrowser) {\n      continue;\n    }\n\n    for (let tab of win.gBrowser.tabs) {\n      if (tab.hidden && tab.ownerGlobal && SessionStore.getCustomTabValue(tab, \"hiddenBy\") === id) {\n        win.gBrowser.showTab(tab);\n      }\n    }\n  }\n}"}],"allAttrs":[{"filepath":"browser/components/extensions/parent/ext-tabs.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const allAttrs = new Set([\"attention\", \"audible\", \"favIconUrl\", \"mutedInfo\", \"sharingState\", \"title\"]);"}],"allProperties":[{"filepath":"browser/components/extensions/parent/ext-tabs.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const allProperties = new Set([\"attention\", \"audible\", \"discarded\", \"favIconUrl\", \"hidden\", \"isArticle\", \"mutedInfo\", \"pinned\", \"sharingState\", \"status\", \"title\"]);"}],"restricted":[{"filepath":"browser/components/extensions/parent/ext-tabs.js","kind":"const","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"const restricted = new Set([\"url\", \"favIconUrl\", \"title\"]);"}],"TabEventManager":[{"filepath":"browser/components/extensions/parent/ext-tabs.js","kind":"function","metadata":{"toolkit":false,"browser":true,"mobile":false,"parent":true,"child":false},"jscode":"function TabEventManager({\n  context,\n  name,\n  event,\n  listener\n}) {\n  let register = fire => {\n    let listener2 = (eventName, eventData, ...args) => {\n      if (!(\"isPrivate\" in eventData)) {\n        throw new Error(`isPrivate property missing in tabTracker event \"${eventName}\"`);\n      }\n\n      if (eventData.isPrivate && !context.privateBrowsingAllowed) {\n        return;\n      }\n\n      listener(fire, eventData, ...args);\n    };\n\n    tabTracker.on(event, listener2);\n    return () => {\n      tabTracker.off(event, listener2);\n    };\n  };\n\n  return new EventManager({\n    context,\n    name,\n    register\n  }).api();\n}"}],"WINDOW_ID_NONE":[{"filepath":"toolkit/components/extensions/parent/ext-tabs-base.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const WINDOW_ID_NONE = -1;"}],"WINDOW_ID_CURRENT":[{"filepath":"toolkit/components/extensions/parent/ext-tabs-base.js","kind":"const","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"const WINDOW_ID_CURRENT = -2;"}],"getUserContextIdForCookieStoreId":[{"filepath":"toolkit/components/extensions/parent/ext-tabs-base.js","kind":"function","metadata":{"toolkit":true,"browser":false,"mobile":false,"parent":true,"child":false},"jscode":"function getUserContextIdForCookieStoreId(extension, cookieStoreId, isPrivateBrowsing) {\n  if (!extension.hasPermission(\"cookies\")) {\n    throw new ExtensionError(`No permission for cookieStoreId: ${cookieStoreId}`);\n  }\n\n  if (!isValidCookieStoreId(cookieStoreId)) {\n    throw new ExtensionError(`Illegal cookieStoreId: ${cookieStoreId}`);\n  }\n\n  if (isPrivateBrowsing && !isPrivateCookieStoreId(cookieStoreId)) {\n    throw new ExtensionError(`Illegal to set non-private cookieStoreId in a private window`);\n  }\n\n  if (!isPrivateBrowsing && isPrivateCookieStoreId(cookieStoreId)) {\n    throw new ExtensionError(`Illegal to set private cookieStoreId in a non-private window`);\n  }\n\n  if (isContainerCookieStoreId(cookieStoreId)) {\n    if (PrivateBrowsingUtils.permanentPrivateBrowsing) {\n      throw new ExtensionError(`Contextual identities are unavailable in permanent private browsing mode`);\n    }\n\n    if (!containersEnabled) {\n      throw new ExtensionError(`Contextual identities are currently disabled`);\n    }\n\n    let userContextId = getContainerForCookieStoreId(cookieStoreId);\n\n    if (!userContextId) {\n      throw new ExtensionError(`No cookie store exists with ID ${cookieStoreId}`);\n    }\n\n    return userContextId;\n  }\n\n  return Services.scriptSecurityManager.DEFAULT_USER_CONTEXT_ID;\n}"}]}